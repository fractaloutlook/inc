<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Quantum Garden</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üå∏</text></svg>">
    <style>
/* ============================================
   CSS RESET & BASE STYLES
   ============================================ */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

:root {
    /* Color Palette - Quantum Theme */
    --bg-dark: #0a0a12;
    --bg-panel: #12121f;
    --bg-card: #1a1a2e;
    --bg-card-hover: #242438;
    --border-dim: #2a2a4a;
    --border-bright: #4a4a8a;
    
    /* Accent Colors */
    --quantum-blue: #4fc3f7;
    --quantum-purple: #b388ff;
    --quantum-green: #69f0ae;
    --quantum-gold: #ffd54f;
    --quantum-red: #ff5252;
    --quantum-pink: #f48fb1;
    --quantum-cyan: #18ffff;
    --quantum-orange: #ffab40;
    
    /* Text Colors */
    --text-primary: #e0e0e0;
    --text-secondary: #9e9e9e;
    --text-dim: #616161;
    
    /* Spacing */
    --spacing-xs: 4px;
    --spacing-sm: 8px;
    --spacing-md: 16px;
    --spacing-lg: 24px;
    --spacing-xl: 32px;
    
    /* Border Radius */
    --radius-sm: 4px;
    --radius-md: 8px;
    --radius-lg: 12px;
    
    /* Transitions */
    --transition-fast: 0.15s ease;
    --transition-normal: 0.3s ease;
}

html, body {
    height: 100%;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg-dark);
    color: var(--text-primary);
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
}

/* Scrollbar Styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-dark);
}

::-webkit-scrollbar-thumb {
    background: var(--border-dim);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--border-bright);
}

/* ============================================
   LAYOUT
   ============================================ */
#game-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    max-height: 100vh;
    overflow: hidden;
}

#header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border-dim);
    flex-shrink: 0;
}

#header h1 {
    font-size: 1.25rem;
    font-weight: 600;
    background: linear-gradient(135deg, var(--quantum-blue), var(--quantum-purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

#header-controls {
    display: flex;
    gap: var(--spacing-sm);
}

.header-btn {
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    color: var(--text-secondary);
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    cursor: pointer;
    font-size: 0.75rem;
    transition: var(--transition-fast);
}

.header-btn:hover {
    background: var(--bg-card-hover);
    border-color: var(--border-bright);
    color: var(--text-primary);
}

#main-content {
    display: flex;
    flex: 1;
    overflow: hidden;
}

/* Left Panel - Resources & Core Interaction */
#left-panel {
    width: 280px;
    min-width: 280px;
    display: flex;
    flex-direction: column;
    background: var(--bg-panel);
    border-right: 1px solid var(--border-dim);
    overflow-y: auto;
}

/* Center Panel - Garden */
#center-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    padding: var(--spacing-md);
    align-items: center;  /* Center garden horizontally */
    justify-content: center;  /* Center garden vertically */
    position: relative;  /* For harvest effects positioning */
}

/* Right Panel - Upgrades & Info */
#right-panel {
    width: 320px;
    min-width: 320px;
    display: flex;
    flex-direction: column;
    background: var(--bg-panel);
    border-left: 1px solid var(--border-dim);
    overflow-y: auto;
}

/* Tab Navigation */
.tab-nav {
    display: flex;
    background: var(--bg-dark);
    border-bottom: 1px solid var(--border-dim);
    flex-shrink: 0;
}

.tab-btn {
    flex: 1;
    padding: var(--spacing-sm) var(--spacing-md);
    background: transparent;
    border: none;
    color: var(--text-secondary);
    font-size: 0.8rem;
    cursor: pointer;
    transition: var(--transition-fast);
    border-bottom: 2px solid transparent;
}

.tab-btn:hover {
    background: var(--bg-card);
    color: var(--text-primary);
}

.tab-btn.active {
    color: var(--quantum-blue);
    border-bottom-color: var(--quantum-blue);
    background: var(--bg-panel);
}

.tab-content {
    display: none;
    flex: 1;
    overflow-y: auto;
    padding: var(--spacing-md);
}

.tab-content.active {
    display: block;
}

/* ============================================
   RESOURCES DISPLAY
   ============================================ */
#resources-section {
    padding: var(--spacing-sm);
    border-bottom: 1px solid var(--border-dim);
    position: relative;
}

.resource-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 4px 8px;
    margin-bottom: 2px;
    background: var(--bg-card);
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-dim);
    cursor: help;
    position: relative;
    font-size: 0.85rem;
}

.resource-rate.negative {
    color: var(--quantum-red);
}

/* Global tooltip styles - using a single tooltip element to prevent jitter */
#tooltip {
    position: fixed;
    background: var(--bg-dark);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-sm);
    padding: 10px 14px;
    font-size: 0.75rem;
    color: var(--text-secondary);
    max-width: 280px;
    z-index: 1000;
    pointer-events: none;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    opacity: 0;
    transition: opacity 0.15s ease;
    line-height: 1.4;
}

#tooltip.visible {
    opacity: 1;
}

#tooltip .tooltip-title {
    color: var(--text-primary);
    font-weight: 600;
    margin-bottom: 4px;
}

#tooltip .tooltip-detail {
    color: var(--quantum-cyan);
    font-size: 0.7rem;
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid var(--border-dim);
}

.resource-info {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.resource-icon {
    font-size: 1.2rem;
    width: 28px;
    text-align: center;
}

.resource-name {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.resource-values {
    text-align: right;
}

.resource-amount {
    font-size: 1rem;
    font-weight: 600;
    font-variant-numeric: tabular-nums;
}

.resource-rate {
    font-size: 0.7rem;
    color: var(--text-dim);
}

.resource-rate.positive {
    color: var(--quantum-green);
}

/* ============================================
   QUANTUM CORE (Main Click Area)
   ============================================ */
#quantum-core-section {
    padding: var(--spacing-sm);
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
    border-bottom: 1px solid var(--border-dim);
}

#quantum-core {
    width: 100px;
    height: 100px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, var(--quantum-blue), var(--quantum-purple));
    border: 3px solid var(--quantum-blue);
    cursor: pointer;
    position: relative;
    transition: transform 0.1s ease, box-shadow 0.3s ease;
    box-shadow: 
        0 0 15px rgba(79, 195, 247, 0.3),
        0 0 30px rgba(179, 136, 255, 0.2),
        inset 0 0 20px rgba(255, 255, 255, 0.1);
}

#quantum-core:hover {
    transform: scale(1.05);
    box-shadow: 
        0 0 30px rgba(79, 195, 247, 0.5),
        0 0 60px rgba(179, 136, 255, 0.3),
        inset 0 0 30px rgba(255, 255, 255, 0.15);
}

#quantum-core:active {
    transform: scale(0.95);
}

/* Core pulses when coherence is low - encouraging clicks */
#quantum-core.low-coherence {
    animation: coherence-pulse 1.5s ease-in-out infinite;
    border-color: var(--quantum-red);
}

@keyframes coherence-pulse {
    0%, 100% {
        box-shadow: 0 0 20px rgba(255, 99, 99, 0.5), 0 0 40px rgba(255, 99, 99, 0.3);
    }
    50% {
        box-shadow: 0 0 40px rgba(255, 99, 99, 0.7), 0 0 80px rgba(255, 99, 99, 0.5);
    }
}

/* Quantum burst flash effect */
#quantum-core.burst {
    animation: quantum-burst 0.5s ease-out !important;
}

@keyframes quantum-burst {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.3);
        box-shadow: 0 0 80px var(--quantum-cyan), 0 0 150px var(--quantum-cyan), 0 0 200px white;
    }
    100% {
        transform: scale(1);
    }
}

/* Burst indicator bar */
#burst-indicator {
    margin: 4px var(--spacing-sm);
    text-align: center;
}

.burst-bar {
    height: 4px;
    background: var(--bg-card);
    border-radius: 2px;
    overflow: hidden;
    border: 1px solid var(--border-dim);
}

.burst-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--quantum-cyan), var(--quantum-purple));
    transition: width 0.1s ease-out;
    box-shadow: 0 0 8px var(--quantum-cyan);
}

.burst-label {
    font-size: 0.6rem;
    color: var(--text-dim);
    margin-top: 1px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Coherence-boosted click particles */
.click-particle.coherence-boosted {
    color: var(--quantum-cyan) !important;
    text-shadow: 0 0 10px var(--quantum-cyan), 0 0 20px var(--quantum-cyan) !important;
}

/* Click combo display */
.combo-display {
    position: absolute;
    bottom: -30px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 0.9rem;
    font-weight: bold;
    color: var(--quantum-gold);
    text-shadow: 0 0 10px var(--quantum-gold);
    animation: combo-pop 0.2s ease-out;
    white-space: nowrap;
}

.combo-display.super {
    font-size: 1.1rem;
    color: var(--quantum-orange);
    text-shadow: 0 0 15px var(--quantum-orange), 0 0 25px var(--quantum-orange);
}

.combo-display.mega {
    font-size: 1.3rem;
    color: var(--quantum-cyan);
    text-shadow: 0 0 20px var(--quantum-cyan), 0 0 30px var(--quantum-cyan);
    animation: combo-mega 0.3s ease-out;
}

.combo-display.fading {
    animation: combo-fade 0.5s ease-out forwards;
}

@keyframes combo-pop {
    0% { transform: translateX(-50%) scale(1.5); opacity: 0; }
    100% { transform: translateX(-50%) scale(1); opacity: 1; }
}

@keyframes combo-mega {
    0% { transform: translateX(-50%) scale(2); opacity: 0; }
    50% { transform: translateX(-50%) scale(1.2); }
    100% { transform: translateX(-50%) scale(1); opacity: 1; }
}

@keyframes combo-fade {
    0% { opacity: 1; transform: translateX(-50%) translateY(0); }
    100% { opacity: 0; transform: translateX(-50%) translateY(-20px); }
}

#quantum-core::before {
    content: '';
    position: absolute;
    top: 10%;
    left: 10%;
    width: 80%;
    height: 80%;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 40%, rgba(255,255,255,0.3), transparent 60%);
    pointer-events: none;
}

#core-power-display {
    margin-top: var(--spacing-xs);
    text-align: center;
}

#core-power-display .label {
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1px;
}

#core-power-display .value {
    font-size: 1.1rem;
    font-weight: 700;
    color: var(--quantum-blue);
}

/* Click Particles */
.click-particle {
    position: fixed;
    pointer-events: none;
    font-weight: bold;
    font-size: 1rem;
    color: var(--quantum-gold);
    text-shadow: 0 0 10px var(--quantum-gold);
    animation: floatUp 1s ease-out forwards;
    z-index: 1000;
}

@keyframes floatUp {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-60px) scale(0.5);
    }
}

/* Combo Display */
#combo-display {
    text-align: center;
    margin-top: var(--spacing-sm);
    font-size: 0.9rem;
    font-weight: 700;
    color: var(--quantum-gold);
    text-shadow: 0 0 10px var(--quantum-gold);
    animation: combo-pulse 0.3s ease-out;
}

#combo-display.hidden {
    display: none;
}

#combo-value {
    font-size: 1.2rem;
    color: var(--quantum-orange);
}

@keyframes combo-pulse {
    0% { transform: scale(1.3); }
    100% { transform: scale(1); }
}

/* Burst Bar */
#burst-container {
    margin-top: var(--spacing-md);
    padding: 0 var(--spacing-md);
}

.burst-label {
    font-size: 0.65rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1px;
    text-align: center;
    margin-bottom: 4px;
}

#burst-bar {
    height: 6px;
    background: var(--bg-dark);
    border-radius: 3px;
    overflow: hidden;
    border: 1px solid var(--border-dim);
}

#burst-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--quantum-purple), var(--quantum-cyan));
    border-radius: 3px;
    transition: width 0.15s ease-out;
}

#burst-fill.charged {
    background: linear-gradient(90deg, var(--quantum-gold), var(--quantum-orange));
    animation: burst-ready 0.5s ease-in-out infinite;
}

@keyframes burst-ready {
    0%, 100% { box-shadow: 0 0 5px var(--quantum-gold); }
    50% { box-shadow: 0 0 15px var(--quantum-gold); }
}

/* ============================================
   GARDEN GRID
   ============================================ */
#garden-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-md);
    flex-wrap: wrap;
    gap: var(--spacing-sm);
}

#garden-header h2 {
    font-size: 1.1rem;
    color: var(--text-primary);
}

#garden-controls {
    display: flex;
    gap: var(--spacing-sm);
    align-items: center;
}

.auto-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-sm);
    font-size: 0.7rem;
    color: var(--text-secondary);
    cursor: pointer;
    transition: var(--transition-fast);
}

.auto-toggle:hover {
    border-color: var(--border-bright);
}

.auto-toggle.active {
    background: var(--quantum-green);
    border-color: var(--quantum-green);
    color: var(--bg-dark);
}

.auto-toggle .toggle-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
    transition: all 0.3s ease;
}

.auto-toggle.active .toggle-indicator {
    background: #ff3333;
    box-shadow: 0 0 4px #ff3333, 0 0 8px #ff3333, 0 0 12px rgba(255, 51, 51, 0.5);
    animation: led-pulse 1.5s ease-in-out infinite;
}

@keyframes led-pulse {
    0%, 100% { 
        box-shadow: 0 0 4px #ff3333, 0 0 8px #ff3333, 0 0 12px rgba(255, 51, 51, 0.5);
    }
    50% { 
        box-shadow: 0 0 6px #ff5555, 0 0 12px #ff3333, 0 0 18px rgba(255, 51, 51, 0.7);
    }
}

#garden-info {
    font-size: 0.8rem;
    color: var(--text-secondary);
}

#garden-grid {
    display: grid;
    gap: var(--spacing-sm);
    align-content: center;
    justify-content: center;
    position: relative;
    padding: var(--spacing-sm);
    /* Removed flex:1, width:100%, height:100% - let grid size naturally and parent centers it */
}

.garden-plot {
    aspect-ratio: 1;
    background: var(--bg-card);
    border: 2px solid var(--border-dim);
    border-radius: var(--radius-md);
    cursor: pointer;
    position: relative;
    transition: var(--transition-fast);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.garden-plot:hover {
    border-color: var(--border-bright);
    background: var(--bg-card-hover);
}

.garden-plot.empty::after {
    content: '+';
    font-size: 1.5rem;
    color: var(--text-dim);
    opacity: 0;
    transition: var(--transition-fast);
}

.garden-plot.empty:hover::after {
    opacity: 1;
}

.garden-plot.planted {
    border-color: var(--quantum-green);
}

.garden-plot.ready {
    border-color: var(--quantum-gold);
    animation: pulse-glow 2s ease-in-out infinite;
}

@keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 5px var(--quantum-gold); }
    50% { box-shadow: 0 0 20px var(--quantum-gold); }
}

.plot-plant {
    font-size: 1.8rem;
    line-height: 1;
}

.plot-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 4px;
    background: var(--quantum-green);
    transition: width 0.5s linear;
}

.plot-timer {
    position: absolute;
    top: 2px;
    right: 4px;
    font-size: 0.65rem;
    color: var(--text-dim);
}

/* ============================================
   PLANT SELECTOR MODAL
   ============================================ */
#plant-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 100;
    align-items: center;
    justify-content: center;
}

#plant-modal.active, .modal.active {
    display: flex;
}

.modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.85);
    z-index: 150;
    align-items: center;
    justify-content: center;
    animation: modal-fade-in 0.3s ease-out;
}

@keyframes modal-fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
}

.modal-content {
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-lg);
    padding: var(--spacing-xl);
    box-shadow: 0 0 40px rgba(79, 195, 247, 0.3);
    animation: modal-slide-in 0.3s ease-out;
}

@keyframes modal-slide-in {
    from { transform: translateY(-20px); opacity: 0; }
    to { transform: translateY(0); opacity: 1; }
}

.offline-gain {
    padding: 0.5rem 0;
    font-size: 1.1rem;
    color: var(--quantum-green);
    border-bottom: 1px solid var(--border-dim);
}

.offline-gain:last-child {
    border-bottom: none;
}

#plant-modal-content {
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
    max-width: 400px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

#plant-modal h3 {
    margin-bottom: var(--spacing-md);
    color: var(--quantum-blue);
}

.plant-option {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-md);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: var(--transition-fast);
}

.plant-option:hover:not(.locked) {
    border-color: var(--quantum-green);
    background: var(--bg-card-hover);
}

.plant-option.locked {
    opacity: 0.5;
    cursor: not-allowed;
}

.plant-option.selected {
    border-color: var(--quantum-green);
    background: rgba(105, 240, 174, 0.1);
}

.plant-option.clear-option {
    border-color: var(--quantum-red);
    opacity: 0.8;
}

.plant-option.clear-option:hover {
    opacity: 1;
    background: rgba(255, 99, 99, 0.1);
}

.plot-preference {
    position: absolute;
    bottom: 2px;
    left: 2px;
    font-size: 0.6rem;
    opacity: 0.6;
    background: var(--bg-dark);
    padding: 1px 3px;
    border-radius: 2px;
}

/* Mutation indicator */
.mutation-indicator {
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 0.8rem;
    animation: mutation-sparkle 2s ease-in-out infinite;
    text-shadow: 0 0 6px var(--mutation-color, gold);
    z-index: 10;
}

/* If both mutated and entangled, shift the entanglement link right */
.garden-plot.mutated.entangled::before {
    left: 22px;
}

@keyframes mutation-sparkle {
    0%, 100% { transform: scale(1); opacity: 0.8; }
    50% { transform: scale(1.2); opacity: 1; }
}

/* Mutated plant glow */
.garden-plot.mutated {
    box-shadow: 0 0 15px var(--mutation-color, gold);
}

.garden-plot.mutated .plot-plant {
    filter: drop-shadow(0 0 8px var(--mutation-color, gold));
}

.garden-plot.mutated.ready {
    animation: mutation-pulse 1s ease-in-out infinite;
}

@keyframes mutation-pulse {
    0%, 100% { box-shadow: 0 0 15px var(--mutation-color, gold); }
    50% { box-shadow: 0 0 25px var(--mutation-color, gold), 0 0 40px var(--mutation-color, gold); }
}

/* Enhanced observer effect - magnifying lens */
.garden-plot.observed .plot-plant {
    transform: scale(1.3);
    filter: brightness(1.2) drop-shadow(0 0 8px var(--quantum-cyan));
    transition: transform 0.2s ease, filter 0.2s ease;
}

/* Floating time reduction text */
.observer-float {
    position: absolute;
    color: var(--quantum-cyan);
    font-size: 0.7rem;
    font-weight: bold;
    pointer-events: none;
    animation: observer-float-up 1s ease-out forwards;
    text-shadow: 0 0 4px var(--quantum-cyan);
    z-index: 20;
}

@keyframes observer-float-up {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-30px) scale(0.8);
    }
}

.observer-float.entangled-boost {
    color: var(--quantum-orange);
    text-shadow: 0 0 4px var(--quantum-orange);
    font-size: 0.6rem;
}

/* Harvest floating numbers */
#harvest-effects-container {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 30;
    overflow: visible;
}

.harvest-float {
    position: absolute;
    color: var(--quantum-green);
    font-size: 0.9rem;
    font-weight: bold;
    pointer-events: none;
    animation: harvest-float-up 1.2s ease-out forwards;
    text-shadow: 0 0 6px var(--quantum-green), 0 2px 4px rgba(0,0,0,0.5);
    z-index: 35;
    white-space: nowrap;
}

@keyframes harvest-float-up {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1.2);
    }
    20% {
        transform: translateY(-10px) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-50px) scale(0.8);
    }
}

/* Resource gain indicators on left panel */
.resource-gain {
    position: absolute;
    right: -5px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--quantum-green);
    font-size: 0.75rem;
    font-weight: bold;
    text-shadow: 0 0 4px var(--quantum-green);
    animation: gain-pulse 0.3s ease-out;
    pointer-events: none;
}

@keyframes gain-pulse {
    0% {
        transform: translateY(-50%) scale(1.5);
        opacity: 0;
    }
    50% {
        opacity: 1;
    }
    100% {
        transform: translateY(-50%) scale(1);
        opacity: 1;
    }
}

.resource-gain.fading {
    animation: gain-fade 0.5s ease-out forwards;
}

@keyframes gain-fade {
    0% {
        opacity: 1;
    }
    100% {
        opacity: 0;
        transform: translateY(-50%) translateX(10px);
    }
}

.plant-option-icon {
    font-size: 2rem;
}

.plant-option-info {
    flex: 1;
}

.plant-option-name {
    font-weight: 600;
    margin-bottom: 2px;
}

.plant-option-desc {
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.plant-option-cost {
    font-size: 0.8rem;
    color: var(--quantum-gold);
}

#close-plant-modal {
    margin-top: var(--spacing-md);
    width: 100%;
    padding: var(--spacing-sm);
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    color: var(--text-primary);
    border-radius: var(--radius-sm);
    cursor: pointer;
}

/* ============================================
   GENERATORS (Plants/Buildings)
   ============================================ */
.generator-item {
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    transition: var(--transition-fast);
}

.generator-item:hover:not(.locked) {
    border-color: var(--border-bright);
}

.generator-item.locked {
    opacity: 0.4;
}

.generator-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
}

.generator-icon {
    font-size: 1.5rem;
}

.generator-title {
    flex: 1;
}

.generator-name {
    font-weight: 600;
    font-size: 0.9rem;
}

.generator-owned {
    font-size: 0.75rem;
    color: var(--text-dim);
}

.generator-desc {
    font-size: 0.75rem;
    color: var(--text-secondary);
    margin-bottom: var(--spacing-sm);
}

.generator-stats {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text-dim);
    margin-bottom: var(--spacing-sm);
}

.generator-harvest {
    font-size: 0.7rem;
    color: var(--quantum-green);
    margin-bottom: var(--spacing-sm);
    padding: 4px 8px;
    background: rgba(105, 240, 174, 0.1);
    border-radius: var(--radius-sm);
}

.generator-buy-btn {
    padding: var(--spacing-sm);
    background: linear-gradient(135deg, var(--quantum-purple), var(--quantum-blue));
    border: none;
    border-radius: var(--radius-sm);
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-fast);
    flex: 1;
    min-height: 36px;
    box-sizing: border-box;
}

.generator-buy-btn.small {
    flex: 0;
    min-width: 50px;
    padding: var(--spacing-sm) var(--spacing-md);
    font-size: 0.8rem;
    min-height: 36px;
}

.generator-buy-btn.max-btn {
    flex: 0;
    min-width: 58px;
    width: 58px;
    padding: 2px 4px;
    font-size: 0.7rem;
    min-height: 36px;
    text-align: center;
    line-height: 1.2;
}

.generator-buttons {
    display: flex;
    gap: var(--spacing-xs);
    margin-top: var(--spacing-sm);
    min-height: 36px;
}

.generator-buy-btn:hover:not(:disabled) {
    filter: brightness(1.2);
    box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
}

.generator-buy-btn:disabled {
    background: var(--bg-card);
    color: var(--text-dim);
    cursor: not-allowed;
    min-height: 36px;
}

/* ============================================
   UPGRADES
   ============================================ */
.upgrade-item {
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: var(--transition-fast);
}

.upgrade-item:hover:not(.purchased):not(.locked) {
    border-color: var(--quantum-gold);
}

.upgrade-item.purchased {
    opacity: 0.5;
    border-color: var(--quantum-green);
}

.upgrade-item.locked {
    opacity: 0.3;
}

.upgrade-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-xs);
}

.upgrade-icon {
    font-size: 1.2rem;
}

.upgrade-name {
    flex: 1;
    font-weight: 600;
    font-size: 0.85rem;
}

.upgrade-cost {
    font-size: 0.8rem;
    color: var(--quantum-gold);
}

.upgrade-desc {
    font-size: 0.75rem;
    color: var(--text-secondary);
}

/* ============================================
   LOG / MESSAGES
   ============================================ */
#log-section {
    padding: var(--spacing-sm);
    border-top: 1px solid var(--border-dim);
    flex: 1;
    min-height: 120px;
    overflow-y: auto;
}

#log-section h4 {
    font-size: 0.7rem;
    color: var(--text-dim);
    margin-bottom: 4px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.log-entry {
    font-size: 0.7rem;
    color: var(--text-secondary);
    padding: 2px 0;
    border-bottom: 1px solid var(--border-dim);
    opacity: 0;
    animation: fadeIn 0.3s ease forwards;
    line-height: 1.3;
}

.log-entry:last-child {
    border-bottom: none;
}

.log-entry.highlight {
    color: var(--quantum-gold);
}

.log-entry.success {
    color: var(--quantum-green);
}

.log-entry.warning {
    color: var(--quantum-red);
}

.log-entry.mysterious {
    color: var(--quantum-purple);
    font-style: italic;
    text-shadow: 0 0 10px var(--quantum-purple);
}

.log-entry.tip {
    color: var(--quantum-cyan);
    background: rgba(24, 255, 255, 0.1);
    padding: 4px 6px;
    border-radius: 4px;
    border-left: 2px solid var(--quantum-cyan);
    margin: 4px 0;
}

@keyframes fadeIn {
    to { opacity: 1; }
}

/* ============================================
   STATISTICS TAB
   ============================================ */
.stat-group {
    margin-bottom: var(--spacing-lg);
}

.stat-group h4 {
    font-size: 0.85rem;
    color: var(--quantum-blue);
    margin-bottom: var(--spacing-sm);
    padding-bottom: var(--spacing-xs);
    border-bottom: 1px solid var(--border-dim);
}

.stat-row {
    display: flex;
    justify-content: space-between;
    padding: var(--spacing-xs) 0;
    font-size: 0.8rem;
}

.stat-label {
    color: var(--text-secondary);
}

.stat-value {
    color: var(--text-primary);
    font-weight: 500;
}

/* Prestige / Reality Collapse UI */
.prestige-section {
    background: linear-gradient(135deg, rgba(138, 43, 226, 0.15), rgba(75, 0, 130, 0.15));
    border: 1px solid var(--quantum-purple);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-lg);
}

.prestige-section h4 {
    color: var(--quantum-purple);
    font-size: 1rem;
    margin-bottom: var(--spacing-md);
    text-shadow: 0 0 10px var(--quantum-purple);
}

.prestige-info {
    display: grid;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-md);
}

.prestige-stat {
    display: flex;
    justify-content: space-between;
    font-size: 0.85rem;
}

.prestige-stat .label {
    color: var(--text-secondary);
}

.prestige-stat .value {
    color: var(--quantum-purple);
    font-weight: bold;
}

.prestige-stat .value.highlight {
    color: var(--quantum-gold);
    text-shadow: 0 0 8px var(--quantum-gold);
}

.collapse-btn {
    width: 100%;
    padding: var(--spacing-md);
    background: linear-gradient(135deg, var(--quantum-purple), #4a0080);
    border: none;
    border-radius: var(--radius-md);
    color: white;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
}

.collapse-btn:hover:not(:disabled) {
    transform: scale(1.02);
    box-shadow: 0 0 20px var(--quantum-purple);
}

.collapse-btn:disabled {
    background: var(--bg-card);
    color: var(--text-dim);
    cursor: not-allowed;
}

.collapse-warning {
    font-size: 0.75rem;
    color: var(--text-dim);
    text-align: center;
    margin-top: var(--spacing-sm);
}

/* Achievement badges */
.achievement-badge {
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-size: 1.2rem;
    cursor: help;
    transition: var(--transition-fast);
}

.achievement-badge.unlocked {
    background: linear-gradient(135deg, var(--quantum-gold), var(--quantum-orange));
    box-shadow: 0 0 10px rgba(255, 213, 79, 0.5);
}

.achievement-badge.unlocked:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255, 213, 79, 0.8);
}

.achievement-badge.locked {
    background: var(--bg-dark);
    border: 1px solid var(--border-dim);
    opacity: 0.5;
}

/* ============================================
   SETTINGS TAB
   ============================================ */
.settings-group {
    margin-bottom: var(--spacing-lg);
}

.settings-group h4 {
    font-size: 0.85rem;
    color: var(--quantum-purple);
    margin-bottom: var(--spacing-sm);
}

.setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-sm);
    background: var(--bg-card);
    border-radius: var(--radius-sm);
    margin-bottom: var(--spacing-xs);
}

.setting-label {
    font-size: 0.85rem;
}

.setting-toggle {
    width: 48px;
    height: 24px;
    background: var(--bg-dark);
    border: 1px solid var(--border-dim);
    border-radius: 12px;
    cursor: pointer;
    position: relative;
    transition: var(--transition-fast);
}

.setting-toggle.active {
    background: var(--quantum-green);
    border-color: var(--quantum-green);
}

.setting-toggle::after {
    content: '';
    position: absolute;
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
    top: 2px;
    left: 2px;
    transition: var(--transition-fast);
}

.setting-toggle.active::after {
    left: 26px;
}

.settings-btn {
    width: 100%;
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-xs);
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    cursor: pointer;
    transition: var(--transition-fast);
}

.settings-btn:hover {
    border-color: var(--border-bright);
    background: var(--bg-card-hover);
}

.settings-btn.danger {
    border-color: var(--quantum-red);
    color: var(--quantum-red);
}

.settings-btn.danger:hover {
    background: var(--quantum-red);
    color: white;
}

/* ============================================
   NOTIFICATIONS / TOASTS
   ============================================ */
#notification-container {
    position: fixed;
    top: var(--spacing-lg);
    right: var(--spacing-lg);
    z-index: 200;
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
    pointer-events: none;
}

.notification {
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    min-width: 250px;
    animation: slideIn 0.3s ease;
    pointer-events: auto;
}

.notification.success {
    border-color: var(--quantum-green);
}

.notification.warning {
    border-color: var(--quantum-gold);
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(100px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.notification-title {
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
}

.notification-message {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

/* ============================================
   RESPONSIVE DESIGN
   ============================================ */
@media (max-width: 1024px) {
    #left-panel {
        width: 240px;
        min-width: 240px;
    }
    #right-panel {
        width: 280px;
        min-width: 280px;
    }
}

@media (max-width: 768px) {
    #main-content {
        flex-direction: column;
    }
    
    #left-panel, #right-panel {
        width: 100%;
        min-width: 100%;
        max-height: 40vh;
    }
    
    #center-panel {
        order: -1;
        flex: none;
        height: 50vh;
    }
    
    #quantum-core {
        width: 100px;
        height: 100px;
    }
}

/* ============================================
   UTILITY CLASSES
   ============================================ */
.hidden {
    display: none !important;
}

.text-energy { color: var(--quantum-blue); }
.text-seeds { color: var(--quantum-green); }
.text-time { color: var(--quantum-purple); }
.text-knowledge { color: var(--quantum-gold); }
.text-reality { color: var(--quantum-pink); }
.text-coherence { color: var(--quantum-cyan); }
.text-entanglement { color: var(--quantum-orange); }
.text-fragments { color: var(--quantum-pink); }

/* ============================================
   QUANTUM EFFECTS
   ============================================ */

/* Superposition shimmer */
@keyframes superposition {
    0%, 100% { opacity: 1; filter: hue-rotate(0deg); }
    25% { opacity: 0.8; filter: hue-rotate(20deg); }
    50% { opacity: 1; filter: hue-rotate(-20deg); }
    75% { opacity: 0.9; filter: hue-rotate(10deg); }
}

.quantum-state {
    animation: superposition 2s ease-in-out infinite;
}

/* Entanglement glow */
.entangled {
    box-shadow: 0 0 15px var(--quantum-orange), 0 0 30px rgba(255, 171, 64, 0.3);
}

.entangled::before {
    content: 'üîó';
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 0.7rem;
    z-index: 10;
}

.entangle-source {
    border-color: var(--quantum-orange) !important;
    box-shadow: 0 0 20px var(--quantum-orange);
    animation: entangle-pulse 0.5s ease-in-out infinite;
}

.entangle-target {
    border-color: var(--quantum-cyan) !important;
    cursor: crosshair !important;
}

.entangle-target:hover {
    box-shadow: 0 0 20px var(--quantum-cyan);
}

@keyframes entangle-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
}

/* Entanglement SVG overlay */
.entanglement-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 15;
}

.entanglement-line {
    stroke: var(--quantum-orange);
    stroke-width: 2;
    fill: none;
    stroke-dasharray: 8 4;
    animation: entangle-flow 1s linear infinite;
    filter: drop-shadow(0 0 4px var(--quantum-orange));
}

@keyframes entangle-flow {
    0% { stroke-dashoffset: 0; }
    100% { stroke-dashoffset: -24; }
}

/* Entanglement particle effect (pulsing dots along line) */
.entanglement-particle {
    fill: var(--quantum-orange);
    filter: drop-shadow(0 0 6px var(--quantum-orange));
}

#garden-section {
    position: relative;
}

/* Observer effect - plant being watched */
.observed {
    border-color: var(--quantum-cyan) !important;
    box-shadow: 0 0 20px var(--quantum-cyan);
    cursor: zoom-in;  /* Magnifying glass cursor for observer effect */
}

.observed .plot-plant {
    animation: observed-pulse 0.5s ease-in-out infinite;
}

@keyframes observed-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* Quantum tunneling flash */
@keyframes tunnel-flash {
    0% { background: transparent; }
    50% { background: rgba(79, 195, 247, 0.3); }
    100% { background: transparent; }
}

.tunneling {
    animation: tunnel-flash 0.3s ease-out;
}

/* Reality destabilizing */
@keyframes reality-shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-2px) rotate(-0.5deg); }
    75% { transform: translateX(2px) rotate(0.5deg); }
}

.reality-unstable {
    animation: reality-shake 0.1s ease-in-out infinite;
}

/* Coherence bar */
#coherence-bar-container {
    margin: var(--spacing-sm);
    padding: 6px 8px;
    background: var(--bg-card);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-dim);
    cursor: help;
    position: relative;
}

#coherence-bar-container:hover {
    border-color: var(--border-bright);
}

#coherence-bar-container.hidden {
    display: none;
}

#coherence-bar-container.coherence-maxed {
    animation: coherence-flash 0.5s ease-out;
}

@keyframes coherence-flash {
    0%, 100% { 
        box-shadow: none; 
        border-color: var(--border-dim);
    }
    50% { 
        box-shadow: 0 0 20px var(--quantum-cyan), inset 0 0 10px rgba(24, 255, 255, 0.2);
        border-color: var(--quantum-cyan);
    }
}

.coherence-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.7rem;
    margin-bottom: 2px;
}

.coherence-bar {
    height: 6px;
    background: var(--bg-dark);
    border-radius: 3px;
    overflow: hidden;
}

.coherence-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--quantum-red), var(--quantum-cyan));
    transition: width 0.3s ease;
}

/* Production efficiency indicator */
.efficiency-indicator {
    display: flex;
    justify-content: space-between;
    font-size: 0.65rem;
    margin-top: 4px;
    padding-top: 4px;
    border-top: 1px solid var(--border-dim);
    color: var(--text-dim);
}

#efficiency-value {
    font-weight: bold;
    transition: color 0.3s;
}

#efficiency-value.high {
    color: var(--quantum-green);
}

#efficiency-value.medium {
    color: var(--quantum-gold);
}

#efficiency-value.low {
    color: var(--quantum-red);
    animation: efficiency-pulse 1s ease-in-out infinite;
}

@keyframes efficiency-pulse {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.5; }
}

/* Next Unlock Indicator */
#next-unlock-indicator {
    margin: var(--spacing-sm);
    padding: 6px 8px;
    background: linear-gradient(135deg, var(--bg-card) 0%, rgba(79, 195, 247, 0.1) 100%);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-dim);
    border-left: 3px solid var(--quantum-blue);
}

#next-unlock-indicator.hidden {
    display: none;
}

.next-unlock-label {
    font-size: 0.6rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 0.5px;
    margin-bottom: 2px;
}

.next-unlock-name {
    font-size: 0.8rem;
    font-weight: 600;
    color: var(--quantum-blue);
    margin-bottom: 4px;
}

.next-unlock-progress {
    display: flex;
    align-items: center;
    gap: var(--spacing-xs);
}

.next-unlock-bar {
    flex: 1;
    height: 4px;
    background: var(--bg-dark);
    border-radius: 2px;
    overflow: hidden;
}

.next-unlock-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--quantum-blue), var(--quantum-cyan));
    transition: width 0.3s ease;
    border-radius: 2px;
}

.next-unlock-percent {
    font-size: 0.65rem;
    font-weight: bold;
    color: var(--quantum-blue);
    min-width: 30px;
    text-align: right;
}

/* Milestone celebration pulse */
@keyframes milestone-pulse {
    0%, 100% { 
        box-shadow: 0 0 0 0 rgba(79, 195, 247, 0.4);
    }
    50% { 
        box-shadow: 0 0 20px 5px rgba(79, 195, 247, 0.6);
    }
}

#next-unlock-indicator.near-unlock {
    animation: milestone-pulse 1.5s ease-in-out infinite;
    border-left-color: var(--quantum-green);
}

#next-unlock-indicator.near-unlock .next-unlock-fill {
    background: linear-gradient(90deg, var(--quantum-green), var(--quantum-cyan));
}

/* Event notification */
.quantum-event {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    background: linear-gradient(135deg, var(--bg-panel) 0%, rgba(179, 136, 255, 0.15) 100%);
    border: 2px solid var(--quantum-purple);
    border-radius: var(--radius-md);
    padding: var(--spacing-sm);
    z-index: 300;
    text-align: center;
    animation: event-appear 0.3s ease-out;
    box-shadow: 0 0 20px rgba(179, 136, 255, 0.5);
}

@keyframes event-appear {
    from {
        opacity: 0;
        transform: scale(0.9);
    }
    to {
        opacity: 1;
        transform: scale(1);
    }
}

.quantum-event h3 {
    color: var(--quantum-purple);
    margin-bottom: 4px;
    font-size: 0.9rem;
}

.quantum-event p {
    color: var(--text-secondary);
    margin-bottom: 6px;
    line-height: 1.3;
    font-size: 0.75rem;
}

.quantum-event button {
    padding: 4px var(--spacing-md);
    background: linear-gradient(135deg, var(--quantum-purple), var(--quantum-blue));
    border: none;
    border-radius: var(--radius-sm);
    color: white;
    font-weight: 600;
    cursor: pointer;
    font-size: 0.75rem;
}

/* Probability tooltip */
.probability-tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    font-size: 0.7rem;
    white-space: nowrap;
    z-index: 50;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
}

.garden-plot:hover .probability-tooltip {
    opacity: 1;
}

/* Glitch text effect for mysterious messages */
.glitch {
    position: relative;
}

.glitch::before,
.glitch::after {
    content: attr(data-text);
    position: absolute;
    left: 0;
    top: 0;
    opacity: 0.8;
}

.glitch::before {
    animation: glitch-1 0.3s infinite;
    color: var(--quantum-cyan);
    clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
}

.glitch::after {
    animation: glitch-2 0.3s infinite;
    color: var(--quantum-pink);
    clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
}

@keyframes glitch-1 {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-2px); }
    40% { transform: translateX(2px); }
}

@keyframes glitch-2 {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(2px); }
    40% { transform: translateX(-2px); }
}

/* Narrative Ticker */
#narrative-ticker {
    width: 100%;
    height: 24px;
    background: linear-gradient(90deg, var(--bg-dark) 0%, rgba(179, 136, 255, 0.1) 50%, var(--bg-dark) 100%);
    border-bottom: 1px solid var(--quantum-purple);
    overflow: hidden;
    position: relative;
}

#ticker-content {
    position: absolute;
    white-space: nowrap;
    animation: ticker-scroll 60s linear infinite;
    color: var(--quantum-purple);
    font-size: 0.75rem;
    line-height: 24px;
    opacity: 0.8;
    letter-spacing: 0.5px;
}

#ticker-content.paused {
    animation-play-state: paused;
}

@keyframes ticker-scroll {
    0% { transform: translateX(100vw); }
    100% { transform: translateX(-100%); }
}

/* Low coherence text glitch effect */
.glitch-text {
    position: relative;
    animation: text-glitch 0.3s infinite;
}

@keyframes text-glitch {
    0%, 90%, 100% { 
        opacity: 1;
        transform: none;
        filter: none;
    }
    92% { 
        opacity: 0.8;
        transform: translateX(-2px);
        filter: hue-rotate(90deg);
    }
    94% { 
        opacity: 0.9;
        transform: translateX(2px) skewX(5deg);
        filter: hue-rotate(-90deg);
    }
    96% { 
        opacity: 0.7;
        transform: translateX(-1px);
    }
}

/* Severe glitch for very low coherence */
.glitch-severe {
    animation: severe-glitch 0.15s infinite;
}

@keyframes severe-glitch {
    0%, 100% { 
        opacity: 1;
        transform: none;
        text-shadow: none;
    }
    25% { 
        opacity: 0.6;
        transform: translateX(-3px) skewX(-5deg);
        text-shadow: 2px 0 var(--quantum-red), -2px 0 var(--quantum-cyan);
    }
    50% { 
        opacity: 0.8;
        transform: translateX(3px) skewY(2deg);
        text-shadow: -2px 0 var(--quantum-purple), 2px 0 var(--quantum-green);
    }
    75% { 
        opacity: 0.5;
        transform: translateX(-2px);
        text-shadow: 1px 2px var(--quantum-red);
    }
}

/* Reality fracture overlay for extremely low coherence */
#reality-fracture-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    pointer-events: none;
    z-index: 9999;
    opacity: 0;
    transition: opacity 0.5s;
    background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(179, 136, 255, 0.03) 2px,
        rgba(179, 136, 255, 0.03) 4px
    );
}

#reality-fracture-overlay.active {
    opacity: 1;
    animation: reality-flicker 2s infinite;
}

@keyframes reality-flicker {
    0%, 95%, 100% { opacity: 0.3; }
    96% { opacity: 0.6; }
    97% { opacity: 0.2; }
    98% { opacity: 0.8; }
}

/* Story modal for major narrative beats */
#story-modal {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.9);
    z-index: 500;
    display: none;
    align-items: center;
    justify-content: center;
}

#story-modal.active {
    display: flex;
}

#story-content {
    max-width: 600px;
    padding: var(--spacing-xl);
    text-align: center;
    color: var(--text-primary);
}

#story-content h2 {
    color: var(--quantum-purple);
    margin-bottom: var(--spacing-lg);
    font-size: 1.5rem;
    text-shadow: 0 0 20px var(--quantum-purple);
}

#story-content p {
    line-height: 1.8;
    margin-bottom: var(--spacing-md);
    font-size: 1rem;
    opacity: 0;
    animation: story-fade-in 1s forwards;
}

#story-content p:nth-child(2) { animation-delay: 0.5s; }
#story-content p:nth-child(3) { animation-delay: 1s; }
#story-content p:nth-child(4) { animation-delay: 1.5s; }
#story-content p:nth-child(5) { animation-delay: 2s; }

@keyframes story-fade-in {
    to { opacity: 1; }
}

#story-content button {
    margin-top: var(--spacing-lg);
    padding: var(--spacing-md) var(--spacing-xl);
    background: linear-gradient(135deg, var(--quantum-purple), var(--quantum-blue));
    border: none;
    border-radius: var(--radius-md);
    color: white;
    font-size: 1rem;
    cursor: pointer;
    opacity: 0;
    animation: story-fade-in 1s forwards;
    animation-delay: 2.5s;
}
    </style>
</head>
<body>
    <!-- Narrative Ticker - mysterious messages scroll across -->
    <div id="narrative-ticker">
        <div id="ticker-content"></div>
    </div>
    
    <div id="game-container">
        <!-- Header -->
        <header id="header">
            <h1>‚öõÔ∏è Quantum Garden</h1>
            <div id="header-controls">
                <button class="header-btn" id="save-btn">üíæ Save</button>
                <button class="header-btn" id="reset-btn" style="color: var(--quantum-red);">üóëÔ∏è Reset</button>
                <button class="header-btn" id="settings-btn">‚öôÔ∏è</button>
            </div>
        </header>

        <!-- Main Content -->
        <main id="main-content">
            <!-- Left Panel: Resources & Core -->
            <aside id="left-panel">
                <div id="quantum-events-container" style="position: relative; min-height: 0;">
                    <!-- Quantum events pop up here -->
                </div>
                <section id="resources-section">
                    <!-- Resources rendered by JS -->
                </section>
                
                <div id="next-unlock-indicator">
                    <div class="next-unlock-label">üéØ Next Unlock</div>
                    <div class="next-unlock-name" id="next-unlock-name">Loading...</div>
                    <div class="next-unlock-progress">
                        <div class="next-unlock-bar">
                            <div class="next-unlock-fill" id="next-unlock-fill" style="width: 0%"></div>
                        </div>
                        <span class="next-unlock-percent" id="next-unlock-percent">0%</span>
                    </div>
                </div>
                
                <div id="coherence-bar-container" class="hidden">
                    <div class="coherence-label">
                        <span>üåÄ Coherence</span>
                        <span id="coherence-value">100%</span>
                    </div>
                    <div class="coherence-bar">
                        <div class="coherence-fill" id="coherence-fill" style="width: 100%"></div>
                    </div>
                    <div id="production-efficiency" class="efficiency-indicator">
                        <span>‚öôÔ∏è Production:</span>
                        <span id="efficiency-value">100%</span>
                    </div>
                </div>
                
                <section id="quantum-core-section">
                    <div id="quantum-core"></div>
                    <div id="core-power-display">
                        <div class="label">Click Power</div>
                        <div class="value" id="click-power-value">1</div>
                    </div>
                    <div id="combo-display" class="hidden">
                        <span id="combo-value">1</span>x Combo!
                    </div>
                    <div id="burst-container">
                        <div class="burst-label">Quantum Burst</div>
                        <div id="burst-bar">
                            <div id="burst-fill"></div>
                        </div>
                    </div>
                </section>
                
                <section id="log-section">
                    <h4>üìú Log</h4>
                    <div id="log-container"></div>
                </section>
            </aside>

            <!-- Center Panel: Garden -->
            <section id="center-panel">
                <div id="garden-header">
                    <h2>üå± Quantum Garden</h2>
                    <div id="garden-controls">
                        <!-- Auto toggles and entangle button rendered by JS -->
                    </div>
                    <span id="garden-info">Plots: <span id="plots-used">0</span>/<span id="plots-total">9</span></span>
                </div>
                <div id="garden-grid">
                    <!-- Garden plots rendered by JS -->
                </div>
                <div id="harvest-effects-container"></div>
                <svg id="entanglement-lines" class="entanglement-overlay"></svg>
            </section>

            <!-- Right Panel: Tabs -->
            <aside id="right-panel">
                <nav class="tab-nav">
                    <button class="tab-btn active" data-tab="generators">Plants</button>
                    <button class="tab-btn" data-tab="upgrades">Upgrades</button>
                    <button class="tab-btn" data-tab="stats">Stats</button>
                </nav>
                
                <div id="generators-tab" class="tab-content active">
                    <div id="generators-list"></div>
                </div>
                
                <div id="upgrades-tab" class="tab-content">
                    <div id="upgrades-list"></div>
                </div>
                
                <div id="stats-tab" class="tab-content">
                    <div id="stats-content"></div>
                </div>
            </aside>
        </main>
    </div>

    <!-- Plant Selection Modal -->
    <div id="plant-modal">
        <div id="plant-modal-content">
            <h3>üå± Select a Plant</h3>
            <div id="plant-options"></div>
            <button id="close-plant-modal">Cancel</button>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notification-container"></div>
    
    <!-- Global Tooltip -->
    <div id="tooltip"></div>
    
    <!-- Reality Fracture Overlay (low coherence effect) -->
    <div id="reality-fracture-overlay"></div>
    
    <!-- Story Modal for major narrative moments -->
    <div id="story-modal">
        <div id="story-content">
            <!-- Populated by JS -->
        </div>
    </div>

<script>
// ============================================
// QUANTUM GARDEN - CORE GAME ENGINE
// ============================================
// Modular architecture for maintainability
// Each system is self-contained and communicates via events

'use strict';

// ============================================
// MODULE: Utility Functions
// ============================================
const Utils = {
    // Format large numbers nicely
    formatNumber(num, decimals = 0) {
        if (num === undefined || num === null || isNaN(num)) return '0';
        
        const suffixes = ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc'];
        
        if (num < 1000) {
            return decimals > 0 ? num.toFixed(decimals) : Math.floor(num).toString();
        }
        
        let tier = Math.floor(Math.log10(Math.abs(num)) / 3);
        if (tier >= suffixes.length) tier = suffixes.length - 1;
        
        const scaled = num / Math.pow(1000, tier);
        const precision = scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2;
        
        return scaled.toFixed(precision) + suffixes[tier];
    },
    
    // Format time (seconds to human readable)
    formatTime(seconds) {
        if (seconds < 60) return Math.ceil(seconds) + 's';
        if (seconds < 3600) return Math.floor(seconds / 60) + 'm ' + (seconds % 60).toFixed(0) + 's';
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        return hours + 'h ' + mins + 'm';
    },
    
    // Deep clone an object
    deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    },
    
    // Simple event emitter
    createEventEmitter() {
        const listeners = {};
        return {
            on(event, callback) {
                if (!listeners[event]) listeners[event] = [];
                listeners[event].push(callback);
            },
            off(event, callback) {
                if (!listeners[event]) return;
                listeners[event] = listeners[event].filter(cb => cb !== callback);
            },
            emit(event, data) {
                if (!listeners[event]) return;
                listeners[event].forEach(callback => callback(data));
            }
        };
    },
    
    // Generate unique ID
    uid() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
};

// ============================================
// MODULE: Tooltip Manager
// ============================================
const TooltipManager = (() => {
    let tooltipEl = null;
    let currentTarget = null;
    let checkInterval = null;
    
    function init() {
        tooltipEl = document.getElementById('tooltip');
        
        // Periodically check if tooltip should be hidden
        // This catches cases where mouseleave doesn't fire (e.g., element removed)
        checkInterval = setInterval(() => {
            if (currentTarget && tooltipEl?.classList.contains('visible')) {
                // Check if mouse is still over the target
                const rect = currentTarget.getBoundingClientRect();
                const mouseX = lastMouseX;
                const mouseY = lastMouseY;
                
                // If target is no longer in DOM or mouse is far from it, hide tooltip
                if (!document.body.contains(currentTarget) ||
                    mouseX < rect.left - 50 || mouseX > rect.right + 50 ||
                    mouseY < rect.top - 50 || mouseY > rect.bottom + 50) {
                    hide();
                }
            }
        }, 500);
        
        // Track mouse position
        document.addEventListener('mousemove', (e) => {
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
        });
    }
    
    let lastMouseX = 0;
    let lastMouseY = 0;
    
    function show(target, content, detail = null) {
        if (!tooltipEl) return;
        
        currentTarget = target;
        
        let html = '';
        if (typeof content === 'object') {
            html = `<div class="tooltip-title">${content.title || ''}</div>`;
            html += `<div>${content.description || ''}</div>`;
            if (content.detail) {
                html += `<div class="tooltip-detail">${content.detail}</div>`;
            }
        } else {
            html = content;
            if (detail) {
                html += `<div class="tooltip-detail">${detail}</div>`;
            }
        }
        
        tooltipEl.innerHTML = html;
        tooltipEl.classList.add('visible');
        
        // Position to the right of the target element
        positionTooltip(target);
    }
    
    function hide() {
        if (tooltipEl) {
            tooltipEl.classList.remove('visible');
        }
        currentTarget = null;
    }
    
    function positionTooltip(target) {
        if (!tooltipEl || !target) return;
        
        const padding = 10;
        const rect = target.getBoundingClientRect();
        
        // First render to get tooltip dimensions
        tooltipEl.style.left = '-9999px';
        tooltipEl.style.top = '-9999px';
        const tooltipRect = tooltipEl.getBoundingClientRect();
        
        // Default: position to the right of target, vertically centered
        let left = rect.right + padding;
        let top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);
        
        // If tooltip would go off right edge, position to the left instead
        if (left + tooltipRect.width > window.innerWidth - padding) {
            left = rect.left - tooltipRect.width - padding;
        }
        
        // Keep tooltip on screen vertically
        if (top + tooltipRect.height > window.innerHeight - padding) {
            top = window.innerHeight - tooltipRect.height - padding;
        }
        if (top < padding) {
            top = padding;
        }
        
        tooltipEl.style.left = left + 'px';
        tooltipEl.style.top = top + 'px';
    }
    
    // Helper to attach tooltip to elements
    function attach(element, content, detailFn = null) {
        element.addEventListener('mouseenter', () => {
            const detail = detailFn ? detailFn() : null;
            show(element, content, detail);
        });
        element.addEventListener('mouseleave', hide);
    }
    
    return { init, show, hide, attach };
})();

// ============================================
// MODULE: Resource Gain Tracker (floating +X on left panel)
// ============================================
const ResourceGainTracker = (() => {
    const pendingGains = {}; // { resourceId: { amount: X, timer: Y, element: Z } }
    const DISPLAY_TIME = 3000; // 3 seconds before fade
    
    function addGain(resourceId, amount) {
        if (!pendingGains[resourceId]) {
            pendingGains[resourceId] = { amount: 0, timer: null, element: null };
        }
        
        const gain = pendingGains[resourceId];
        gain.amount += amount;
        
        // Clear existing fade timer
        if (gain.timer) {
            clearTimeout(gain.timer);
        }
        
        // Update or create the display element
        updateDisplay(resourceId);
        
        // Set new fade timer
        gain.timer = setTimeout(() => fadeOut(resourceId), DISPLAY_TIME);
    }
    
    function updateDisplay(resourceId) {
        const gain = pendingGains[resourceId];
        const resourceItem = document.querySelector(`.resource-item[data-resource="${resourceId}"]`);
        
        if (!resourceItem) return;
        
        // Create element if needed
        if (!gain.element) {
            gain.element = document.createElement('div');
            gain.element.className = 'resource-gain';
            resourceItem.appendChild(gain.element);
        }
        
        // Remove fading class if re-triggered
        gain.element.classList.remove('fading');
        
        // Update text
        const sign = gain.amount >= 0 ? '+' : '';
        gain.element.textContent = sign + Utils.formatNumber(gain.amount, 0);
        
        // Re-trigger animation
        gain.element.style.animation = 'none';
        gain.element.offsetHeight; // Force reflow
        gain.element.style.animation = '';
    }
    
    function fadeOut(resourceId) {
        const gain = pendingGains[resourceId];
        if (!gain || !gain.element) return;
        
        gain.element.classList.add('fading');
        
        // Remove after fade animation
        setTimeout(() => {
            if (gain.element && gain.element.parentNode) {
                gain.element.remove();
            }
            gain.element = null;
            gain.amount = 0;
            gain.timer = null;
        }, 500);
    }
    
    // Show floating harvest numbers at a position
    function showHarvestFloat(plotIndex, yields) {
        const plotEl = document.querySelector(`.garden-plot[data-index="${plotIndex}"]`);
        const container = document.getElementById('harvest-effects-container');
        if (!plotEl || !container) return;
        
        // Get plot position relative to center panel
        const centerPanel = document.getElementById('center-panel');
        const panelRect = centerPanel.getBoundingClientRect();
        const plotRect = plotEl.getBoundingClientRect();
        
        const centerX = plotRect.left - panelRect.left + plotRect.width / 2;
        const startY = plotRect.top - panelRect.top + plotRect.height / 3;
        
        let yOffset = 0;
        
        Object.entries(yields).forEach(([resourceId, amount], i) => {
            const data = GameData.resources[resourceId];
            if (!data) return;
            
            // Don't show floaty numbers for resources the player hasn't unlocked yet
            if (!ResourceManager.isUnlocked(resourceId)) return;
            
            const floater = document.createElement('div');
            floater.className = 'harvest-float';
            floater.textContent = `${data.icon}+${Utils.formatNumber(amount, 0)}`;
            floater.style.left = centerX + 'px';
            floater.style.top = (startY + yOffset) + 'px';
            floater.style.transform = 'translateX(-50%)';
            floater.style.animationDelay = (i * 0.1) + 's';
            
            container.appendChild(floater);
            
            yOffset += 20;
            
            // Also add to left panel tracker
            addGain(resourceId, amount);
            
            // Remove after animation
            setTimeout(() => floater.remove(), 1500 + i * 100);
        });
    }
    
    return { addGain, showHarvestFloat };
})();

// ============================================
// MODULE: Game Data Definitions
// ============================================
const GameData = {
    resources: {
        energy: {
            id: 'energy',
            name: 'Quantum Energy',
            icon: '‚ö°',
            color: 'text-energy',
            baseAmount: 0,
            unlocked: true,
            description: 'The fundamental force of the quantum garden'
        },
        seeds: {
            id: 'seeds',
            name: 'Seeds',
            icon: 'üå±',
            color: 'text-seeds',
            baseAmount: 0,
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 50 },
            description: 'Required to plant in your garden'
        },
        time: {
            id: 'time',
            name: 'Time Crystals',
            icon: '‚è≥',
            color: 'text-time',
            baseAmount: 0,
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 500 },
            description: 'Crystallized moments of temporal energy'
        },
        knowledge: {
            id: 'knowledge',
            name: 'Quantum Knowledge',
            icon: 'üìö',
            color: 'text-knowledge',
            baseAmount: 0,
            unlocked: false,
            unlockAt: { resource: 'time', amount: 100 },
            description: 'Understanding of quantum phenomena'
        },
        coherence: {
            id: 'coherence',
            name: 'Coherence',
            icon: 'üåÄ',
            color: 'text-coherence',
            baseAmount: 100,
            maxAmount: 100,
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 50 },
            description: 'The stability of your quantum state. Depletes as reality becomes classical.'
        },
        entanglement: {
            id: 'entanglement',
            name: 'Entanglement Threads',
            icon: 'üîó',
            color: 'text-entanglement',
            baseAmount: 0,
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 100 },
            description: 'Quantum links between plants. Harvest carefully.'
        },
        fragments: {
            id: 'fragments',
            name: 'Reality Fragments',
            icon: 'üí†',
            color: 'text-fragments',
            baseAmount: 0,
            unlocked: false,
            isPermanent: true, // Survives reality collapse
            description: 'Shards of collapsed realities. Persist across all timelines.'
        }
    },
    
    generators: {
        quantumLily: {
            id: 'quantumLily',
            name: 'Quantum Lily',
            icon: 'üå∏',
            description: 'A delicate flower that absorbs ambient quantum fluctuations',
            baseCost: { energy: 15 },
            costMultiplier: 1.15,
            production: { energy: 0.5 },
            unlocked: true,
            gardenPlantable: true,
            growthTime: 10, // seconds
            harvestYield: { energy: 5, seeds: 1 }
        },
        timeTulip: {
            id: 'timeTulip',
            name: 'Time Tulip',
            icon: 'üå∑',
            description: 'Petals that shimmer with temporal energy',
            baseCost: { energy: 100, seeds: 5 },
            costMultiplier: 1.18,
            production: { energy: 2, time: 0.1 },
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 75 },
            gardenPlantable: true,
            growthTime: 30,
            harvestYield: { energy: 20, time: 3, seeds: 2 }
        },
        energyRose: {
            id: 'energyRose',
            name: 'Energy Rose',
            icon: 'üåπ',
            description: 'Radiates concentrated quantum energy',
            baseCost: { energy: 500, seeds: 15 },
            costMultiplier: 1.2,
            production: { energy: 10 },
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 400 },
            gardenPlantable: true,
            growthTime: 60,
            harvestYield: { energy: 100, seeds: 3 }
        },
        dimensionDaisy: {
            id: 'dimensionDaisy',
            name: 'Dimension Daisy',
            icon: 'üåº',
            description: 'Blooms across multiple realities simultaneously',
            baseCost: { energy: 2000, time: 50 },
            costMultiplier: 1.22,
            production: { energy: 25, knowledge: 0.1 },
            unlocked: false,
            unlockAt: { resource: 'time', amount: 30 },
            gardenPlantable: true,
            growthTime: 120,
            harvestYield: { energy: 200, knowledge: 10, entanglement: 1, seeds: 5 }
        },
        voidViolet: {
            id: 'voidViolet',
            name: 'Void Violet',
            icon: 'üíú',
            description: 'Draws power from the space between spaces. Produces entanglement threads.',
            baseCost: { energy: 10000, knowledge: 25 },
            costMultiplier: 1.25,
            production: { energy: 100, time: 1, entanglement: 0.05 },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 20 },
            gardenPlantable: true,
            growthTime: 300,
            harvestYield: { energy: 1000, time: 50, entanglement: 2, seeds: 10 }
        }
    },
    
    upgrades: {
        // Click Power Upgrades
        efficientClicking: {
            id: 'efficientClicking',
            name: 'Quantum Resonance',
            icon: '‚ú®',
            description: 'Double your click power',
            cost: { energy: 50 },
            effect: { clickPowerMultiplier: 2 },
            unlocked: true,
            purchased: false
        },
        improvedClicking: {
            id: 'improvedClicking',
            name: 'Harmonic Amplification',
            icon: 'üîä',
            description: 'Triple your click power',
            cost: { energy: 500 },
            effect: { clickPowerMultiplier: 3 },
            requires: ['efficientClicking'],
            unlocked: false,
            purchased: false
        },
        quantumClicking: {
            id: 'quantumClicking',
            name: 'Quantum Superposition Click',
            icon: '‚öõÔ∏è',
            description: 'Your clicks exist in multiple states. +5 base click power.',
            cost: { energy: 2000, time: 20 },
            effect: { clickPowerBonus: 5 },
            requires: ['improvedClicking'],
            unlocked: false,
            purchased: false
        },
        
        // Seed & Garden Upgrades
        seedProduction: {
            id: 'seedProduction',
            name: 'Seed Synthesis',
            icon: 'üå±',
            description: 'Unlock seeds and gain 5 to start. Quantum Lilies now produce seeds.',
            cost: { energy: 30 },
            effect: { unlockSeeds: true, grantSeeds: 5 },
            unlocked: true,
            purchased: false
        },
        largerGarden: {
            id: 'largerGarden',
            name: 'Garden Expansion',
            icon: 'üåø',
            description: 'Expand your garden to 16 plots',
            cost: { energy: 200, seeds: 20 },
            effect: { gardenSize: 16 },
            requires: ['seedProduction'],
            unlocked: false,
            purchased: false
        },
        fasterGrowth: {
            id: 'fasterGrowth',
            name: 'Temporal Growth',
            icon: '‚è±Ô∏è',
            description: 'Plants grow 25% faster',
            cost: { energy: 1000, time: 15 },
            effect: { growthSpeedMultiplier: 1.25 },
            requires: ['seedProduction'],
            unlocked: false,
            purchased: false
        },
        
        // Production Upgrades
        quantumLilyBoost: {
            id: 'quantumLilyBoost',
            name: 'Lily Enhancement',
            icon: 'üå∏',
            description: 'Quantum Lilies produce 50% more energy',
            cost: { energy: 100 },
            effect: { generatorBoost: { quantumLily: 1.5 } },
            unlocked: true,
            purchased: false
        },
        timeTulipBoost: {
            id: 'timeTulipBoost',
            name: 'Temporal Bloom',
            icon: 'üå∑',
            description: 'Time Tulips produce double time crystals',
            cost: { energy: 750, time: 10 },
            effect: { generatorBoost: { timeTulip: 2 } },
            requires: ['quantumLilyBoost'],
            unlocked: false,
            purchased: false
        },
        
        // Time Unlocks
        unlockTime: {
            id: 'unlockTime',
            name: 'Temporal Awareness',
            icon: '‚è≥',
            description: 'Unlock Time Crystals resource',
            cost: { energy: 250 },
            effect: { unlockResource: 'time' },
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 200 },
            purchased: false
        },
        
        // Observer upgrades
        keenObserver: {
            id: 'keenObserver',
            name: 'Keen Observer',
            icon: 'üëÅÔ∏è',
            description: 'Plants grow 50% faster while you watch them',
            cost: { energy: 300, knowledge: 10 },
            effect: { observerBonus: 1.5 },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 5 },
            purchased: false
        },
        
        // Quantum upgrades
        superpositionMastery: {
            id: 'superpositionMastery',
            name: 'Superposition Mastery',
            icon: 'üé≠',
            description: 'Harvest yields have higher variance but better average outcomes',
            cost: { energy: 1500, knowledge: 30 },
            effect: { yieldVarianceBonus: 0.25 },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 20 },
            purchased: false
        },
        coherenceStabilizer: {
            id: 'coherenceStabilizer',
            name: 'Coherence Stabilizer',
            icon: 'üåÄ',
            description: 'Coherence decays 50% slower',
            cost: { energy: 5000, time: 100 },
            effect: { coherenceDecayReduction: 0.5 },
            requires: ['superpositionMastery'],
            unlocked: false,
            purchased: false
        },
        
        // Entanglement upgrades
        entanglementBasics: {
            id: 'entanglementBasics',
            name: 'Quantum Entanglement',
            icon: 'üîó',
            description: 'Unlock the ability to entangle plants. Entangled plants share growth and harvests.',
            cost: { energy: 2000, knowledge: 50 },
            effect: { unlockEntanglement: true },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 40 },
            purchased: false
        },
        deepEntanglement: {
            id: 'deepEntanglement',
            name: 'Deep Entanglement',
            icon: '‚õìÔ∏è',
            description: 'Entangled plants boost each other\'s yield by 25%',
            cost: { energy: 10000, entanglement: 10 },
            effect: { entanglementYieldBonus: 0.25 },
            requires: ['entanglementBasics'],
            unlocked: false,
            purchased: false
        },
        
        // Automation upgrades
        autoHarvest: {
            id: 'autoHarvest',
            name: 'Quantum Auto-Harvester',
            icon: 'ü§ñ',
            description: 'Mature plants are automatically harvested every 10 seconds',
            cost: { energy: 15000, time: 200, knowledge: 100 },
            effect: { autoHarvest: true },
            unlocked: false,
            unlockAt: { resource: 'time', amount: 150 },
            purchased: false
        },
        autoPlant: {
            id: 'autoPlant',
            name: 'Quantum Auto-Planter',
            icon: 'üå±',
            description: 'Empty plots automatically plant your most efficient seed',
            cost: { energy: 25000, time: 300, knowledge: 150 },
            effect: { autoPlant: true },
            requires: ['autoHarvest'],
            unlocked: false,
            purchased: false
        },
        
        // Late game multipliers
        quantumResonance: {
            id: 'quantumResonance',
            name: 'Quantum Resonance Field',
            icon: 'üì°',
            description: 'All generators produce 50% more',
            cost: { energy: 50000, knowledge: 200 },
            effect: { globalProductionMultiplier: 1.5 },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 150 },
            purchased: false
        },
        
        // Garden expansions
        largerGarden2: {
            id: 'largerGarden2',
            name: 'Garden Expansion II',
            icon: 'üå≥',
            description: 'Expand your garden to 25 plots',
            cost: { energy: 5000, seeds: 50, time: 50 },
            effect: { gardenSize: 25 },
            requires: ['largerGarden'],
            unlocked: false,
            purchased: false
        },
        largerGarden3: {
            id: 'largerGarden3',
            name: 'Infinite Garden',
            icon: 'üåå',
            description: 'Expand your garden to 36 plots',
            cost: { energy: 25000, seeds: 100, time: 150 },
            effect: { gardenSize: 36 },
            requires: ['largerGarden2'],
            unlocked: false,
            purchased: false
        },
        
        // PRESTIGE SYSTEM
        realityAwareness: {
            id: 'realityAwareness',
            name: 'Reality Awareness',
            icon: 'üîÆ',
            description: 'Become aware of the fragile nature of reality. Unlocks Reality Collapse (requires 1M+ total energy to earn fragments).',
            cost: { energy: 100000, knowledge: 500, entanglement: 50 },
            effect: { unlockPrestige: true },
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 75000 },
            purchased: false
        },
        
        // Post-prestige upgrades (unlocked by fragments)
        fragmentBoost1: {
            id: 'fragmentBoost1',
            name: 'Echoes of Past Realities',
            icon: 'üí†',
            description: 'Each Reality Fragment grants +5% base production',
            cost: { fragments: 5 },
            effect: { fragmentProductionBonus: 0.05 },
            unlocked: false,
            unlockAt: { resource: 'fragments', amount: 3 },
            purchased: false,
            persistent: true  // Survives reality collapse
        },
        fragmentBoost2: {
            id: 'fragmentBoost2',
            name: 'Quantum Memory',
            icon: 'üß†',
            description: 'Start each reality with 100 energy and 10 seeds',
            cost: { fragments: 10 },
            effect: { startingBonus: { energy: 100, seeds: 10 } },
            requires: ['fragmentBoost1'],
            unlocked: false,
            purchased: false,
            persistent: true
        },
        fragmentBoost3: {
            id: 'fragmentBoost3',
            name: 'Temporal Persistence',
            icon: '‚è≥',
            description: 'Retain 10% of your Time Crystals through Reality Collapse',
            cost: { fragments: 25 },
            effect: { retainTimePercent: 0.1 },
            requires: ['fragmentBoost2'],
            unlocked: false,
            purchased: false,
            persistent: true
        }
    },
    
    // Initial game state template
    initialState: {
        resources: {
            energy: { amount: 0, total: 0, rate: 0 },
            seeds: { amount: 0, total: 0, rate: 0 },
            time: { amount: 0, total: 0, rate: 0 },
            knowledge: { amount: 0, total: 0, rate: 0 },
            coherence: { amount: 100, total: 100, rate: 0 },
            entanglement: { amount: 0, total: 0, rate: 0 },
            fragments: { amount: 0, total: 0, rate: 0 }
        },
        generators: {},
        upgrades: {},
        achievements: {},
        garden: {
            size: 9, // 3x3 starting
            plots: []
        },
        stats: {
            totalClicks: 0,
            totalEnergyEarned: 0,
            totalPlantsHarvested: 0,
            quantumEventsWitnessed: 0,
            quantumBursts: 0,
            plantsEntangled: 0,
            highCoherenceTime: 0,
            clicksWithManyGens: 0,
            mutationsWitnessed: 0,
            playTime: 0,
            startDate: Date.now()
        },
        settings: {
            notificationsEnabled: true,
            particlesEnabled: true,
            autosaveInterval: 30, // seconds
            autoHarvestEnabled: true,
            autoPlantEnabled: true
        },
        meta: {
            version: '1.0.0',
            lastSave: null
        }
    },
    
    // Achievements
    achievements: {
        // Click achievements
        firstClick: {
            id: 'firstClick',
            name: 'Quantum Awakening',
            description: 'Make your first click',
            icon: 'üëÜ',
            check: () => StateManager.get('stats.totalClicks') >= 1
        },
        click100: {
            id: 'click100',
            name: 'Probability Manipulator',
            description: 'Click 100 times',
            icon: '‚úã',
            check: () => StateManager.get('stats.totalClicks') >= 100
        },
        click1000: {
            id: 'click1000',
            name: 'Wave Function Collapser',
            description: 'Click 1,000 times',
            icon: 'üñêÔ∏è',
            check: () => StateManager.get('stats.totalClicks') >= 1000
        },
        
        // Energy achievements
        energy100: {
            id: 'energy100',
            name: 'Spark of Creation',
            description: 'Accumulate 100 Quantum Energy',
            icon: '‚ö°',
            check: () => StateManager.get('resources.energy.total') >= 100
        },
        energy10k: {
            id: 'energy10k',
            name: 'Power Surge',
            description: 'Accumulate 10,000 Quantum Energy',
            icon: 'üí´',
            check: () => StateManager.get('resources.energy.total') >= 10000
        },
        energy1m: {
            id: 'energy1m',
            name: 'Supernova',
            description: 'Accumulate 1,000,000 Quantum Energy',
            icon: 'üåü',
            check: () => StateManager.get('resources.energy.total') >= 1000000
        },
        
        // Garden achievements
        firstHarvest: {
            id: 'firstHarvest',
            name: 'First Bloom',
            description: 'Harvest your first plant',
            icon: 'üå∏',
            check: () => StateManager.get('stats.totalPlantsHarvested') >= 1
        },
        harvest10: {
            id: 'harvest10',
            name: 'Green Thumb',
            description: 'Harvest 10 plants',
            icon: 'üåø',
            check: () => StateManager.get('stats.totalPlantsHarvested') >= 10
        },
        harvest100: {
            id: 'harvest100',
            name: 'Master Gardener',
            description: 'Harvest 100 plants',
            icon: 'üë®‚Äçüåæ',
            check: () => StateManager.get('stats.totalPlantsHarvested') >= 100
        },
        fullGarden: {
            id: 'fullGarden',
            name: 'No Empty Plots',
            description: 'Fill every garden plot with a growing plant',
            icon: 'üè°',
            check: () => {
                const plots = StateManager.get('garden.plots') || [];
                const size = StateManager.get('garden.size') || 9;
                return plots.length >= size && plots.every(p => p.plant !== null);
            }
        },
        
        // Generator achievements
        firstGenerator: {
            id: 'firstGenerator',
            name: 'Automation Begins',
            description: 'Purchase your first generator',
            icon: '‚öôÔ∏è',
            check: () => {
                return Object.keys(GameData.generators).some(id => 
                    GeneratorManager.getOwned(id) >= 1
                );
            }
        },
        tenLilies: {
            id: 'tenLilies',
            name: 'Lily Pad',
            description: 'Own 10 Quantum Lilies',
            icon: 'üå∏',
            check: () => GeneratorManager.getOwned('quantumLily') >= 10
        },
        allGenerators: {
            id: 'allGenerators',
            name: 'Biodiversity',
            description: 'Own at least one of every plant type',
            icon: 'üåà',
            check: () => {
                return Object.keys(GameData.generators).every(id => 
                    GeneratorManager.getOwned(id) >= 1
                );
            }
        },
        
        // Quantum achievements
        firstEvent: {
            id: 'firstEvent',
            name: 'Quantum Observer',
            description: 'Witness your first quantum event',
            icon: 'üëÅÔ∏è',
            check: () => StateManager.get('stats.quantumEventsWitnessed') >= 1
        },
        tenEvents: {
            id: 'tenEvents',
            name: 'Reality Bender',
            description: 'Witness 10 quantum events',
            icon: 'üîÆ',
            check: () => StateManager.get('stats.quantumEventsWitnessed') >= 10
        },
        lowCoherence: {
            id: 'lowCoherence',
            name: 'Edge of Classical',
            description: 'Let coherence drop below 10%',
            icon: '‚ö†Ô∏è',
            check: () => {
                const coherence = ResourceManager.get('coherence');
                return ResourceManager.isUnlocked('coherence') && coherence < 10;
            }
        },
        
        // Secret achievements
        speedrunner: {
            id: 'speedrunner',
            name: 'Speedrunner',
            description: 'Reach 1000 energy in under 5 minutes',
            icon: 'üèÉ',
            secret: true,
            check: () => {
                const playTime = StateManager.get('stats.playTime') || 0;
                const energy = StateManager.get('resources.energy.total') || 0;
                return energy >= 1000 && playTime < 300;
            }
        },
        patient: {
            id: 'patient',
            name: 'Patience of a Physicist',
            description: 'Play for over an hour',
            icon: '‚è∞',
            check: () => StateManager.get('stats.playTime') >= 3600
        },
        nightOwl: {
            id: 'nightOwl',
            name: 'Night Owl',
            description: 'Play between midnight and 4 AM',
            icon: 'ü¶â',
            secret: true,
            check: () => {
                const hour = new Date().getHours();
                return hour >= 0 && hour < 4;
            }
        },
        
        // New coherence achievements
        coherenceMaster: {
            id: 'coherenceMaster',
            name: 'Coherence Master',
            description: 'Maintain 90%+ coherence for 5 minutes with 50+ generators',
            icon: 'üåÄ',
            check: () => {
                const generators = Object.keys(GameData.generators).reduce((sum, id) => 
                    sum + GeneratorManager.getOwned(id), 0);
                const coherence = ResourceManager.get('coherence') || 0;
                const highTime = StateManager.get('stats.highCoherenceTime') || 0;
                return generators >= 50 && coherence >= 90 && highTime >= 300;
            }
        },
        zeroCoherence: {
            id: 'zeroCoherence',
            name: 'Completely Classical',
            description: 'Let coherence reach exactly 0%',
            icon: 'üìâ',
            check: () => {
                const coherence = ResourceManager.get('coherence');
                return ResourceManager.isUnlocked('coherence') && coherence <= 0;
            }
        },
        
        // Quantum burst achievements
        firstBurst: {
            id: 'firstBurst',
            name: 'Quantum Surge',
            description: 'Trigger your first Quantum Burst',
            icon: '‚ö°',
            check: () => StateManager.get('stats.quantumBursts') >= 1
        },
        tenBursts: {
            id: 'tenBursts',
            name: 'Chain Reaction',
            description: 'Trigger 10 Quantum Bursts',
            icon: 'üí•',
            check: () => StateManager.get('stats.quantumBursts') >= 10
        },
        
        // Entanglement achievements
        firstEntangle: {
            id: 'firstEntangle',
            name: 'Spooky Action',
            description: 'Entangle two plants together',
            icon: 'üîó',
            check: () => StateManager.get('stats.plantsEntangled') >= 2
        },
        entangleFive: {
            id: 'entangleFive',
            name: 'Quantum Network',
            description: 'Have 5 pairs of entangled plants simultaneously',
            icon: 'üï∏Ô∏è',
            check: () => {
                const plots = StateManager.get('garden.plots') || [];
                const pairs = plots.filter(p => p.entangledWith !== null).length / 2;
                return pairs >= 5;
            }
        },
        
        // Late-game clicking achievement
        clickerReborn: {
            id: 'clickerReborn',
            name: 'Return to Basics',
            description: 'Click 100 times while owning 100+ generators',
            icon: 'üîÑ',
            secret: true,
            check: () => {
                const generators = Object.keys(GameData.generators).reduce((sum, id) => 
                    sum + GeneratorManager.getOwned(id), 0);
                const clicks = StateManager.get('stats.clicksWithManyGens') || 0;
                return generators >= 100 && clicks >= 100;
            }
        },
        
        // Big numbers
        energy100m: {
            id: 'energy100m',
            name: 'Cosmic Power',
            description: 'Accumulate 100,000,000 Quantum Energy',
            icon: 'üåå',
            check: () => StateManager.get('resources.energy.total') >= 100000000
        },
        harvest1000: {
            id: 'harvest1000',
            name: 'Legendary Farmer',
            description: 'Harvest 1,000 plants',
            icon: 'üèÜ',
            check: () => StateManager.get('stats.totalPlantsHarvested') >= 1000
        },
        
        // Mutation achievements
        firstMutation: {
            id: 'firstMutation',
            name: 'Genetic Surprise',
            description: 'Witness your first plant mutation',
            icon: 'üß¨',
            check: () => StateManager.get('stats.mutationsWitnessed') >= 1
        },
        mutationCollector: {
            id: 'mutationCollector',
            name: 'Mutation Collector',
            description: 'Witness 10 plant mutations',
            icon: 'üåà',
            check: () => StateManager.get('stats.mutationsWitnessed') >= 10
        },
        mutationMaster: {
            id: 'mutationMaster',
            name: 'Mutation Master',
            description: 'Witness 50 plant mutations',
            icon: 'üß™',
            check: () => StateManager.get('stats.mutationsWitnessed') >= 50
        },
        luckyWinner: {
            id: 'luckyWinner',
            name: 'Lucky Winner',
            description: 'Hit the jackpot in the Quantum Lottery',
            icon: 'üé∞',
            secret: true,
            check: () => StateManager.get('stats.lotteryJackpot') || false
        },
        
        // Prestige achievements
        firstCollapse: {
            id: 'firstCollapse',
            name: 'Reality Shattered',
            description: 'Collapse reality for the first time',
            icon: 'üí†',
            check: () => (StateManager.get('stats.totalCollapses') || 0) >= 1
        },
        realityVeteran: {
            id: 'realityVeteran',
            name: 'Reality Veteran',
            description: 'Collapse reality 5 times',
            icon: 'üîÆ',
            check: () => (StateManager.get('stats.totalCollapses') || 0) >= 5
        },
        fragmentHoarder: {
            id: 'fragmentHoarder',
            name: 'Fragment Hoarder',
            description: 'Accumulate 50 Reality Fragments',
            icon: 'üíé',
            check: () => (ResourceManager.get('fragments') || 0) >= 50
        },
        speedCollapse: {
            id: 'speedCollapse',
            name: 'Speed Collapser',
            description: 'Collapse reality within 30 minutes of a previous collapse',
            icon: '‚ö°',
            secret: true,
            check: () => {
                // Check if we've collapsed at least twice and the last two were close together
                const totalCollapses = StateManager.get('stats.totalCollapses') || 0;
                const fastCollapse = StateManager.get('stats.fastCollapse') || false;
                return totalCollapses >= 2 && fastCollapse;
            }
        },
        
        // Narrative achievements
        quantumWitness: {
            id: 'quantumWitness',
            name: 'Quantum Witness',
            description: 'Experience 50 quantum events',
            icon: 'üëÅÔ∏è',
            check: () => (StateManager.get('stats.quantumEventsWitnessed') || 0) >= 50
        },
        storySeeker: {
            id: 'storySeeker',
            name: 'Story Seeker',
            description: 'Unlock 3 major story moments',
            icon: 'üìñ',
            check: () => (StateManager.get('triggeredStories') || []).length >= 3
        },
        theObserver: {
            id: 'theObserver',
            name: 'The Observer',
            description: 'Use the observer effect to grow plants for 10 minutes total',
            icon: 'üî≠',
            check: () => (StateManager.get('stats.totalObservationTime') || 0) >= 600
        },
        realityBender: {
            id: 'realityBender',
            name: 'Reality Bender',
            description: 'Reach Reality Level 10',
            icon: 'üåÄ',
            secret: true,
            check: () => (StateManager.get('stats.realityLevel') || 0) >= 10
        },
        transcendent: {
            id: 'transcendent',
            name: 'Transcendent',
            description: 'Generate 1 trillion total energy',
            icon: '‚àû',
            secret: true,
            check: () => StateManager.get('resources.energy.total') >= 1000000000000
        }
    }
};

// ============================================
// MODULE: Game State Manager
// ============================================
const StateManager = (() => {
    let state = null;
    const events = Utils.createEventEmitter();
    
    function initialize() {
        // Try to load saved game
        const saved = localStorage.getItem('quantumGarden_save');
        if (saved) {
            try {
                state = JSON.parse(saved);
                // Migrate if needed
                migrateState();
                events.emit('loaded', state);
                return true;
            } catch (e) {
                console.error('Failed to load save:', e);
            }
        }
        
        // Create new game
        state = Utils.deepClone(GameData.initialState);
        
        // Initialize generators owned count
        Object.keys(GameData.generators).forEach(id => {
            state.generators[id] = { owned: 0 };
        });
        
        // Initialize upgrades purchased state
        Object.keys(GameData.upgrades).forEach(id => {
            state.upgrades[id] = { purchased: false };
        });
        
        // Initialize achievements
        Object.keys(GameData.achievements).forEach(id => {
            state.achievements[id] = false;
        });
        
        // Initialize garden plots
        for (let i = 0; i < state.garden.size; i++) {
            state.garden.plots.push({ plant: null, progress: 0, plantedAt: null });
        }
        
        // Set initial coherence
        state.resources.coherence = { amount: 100, total: 100, rate: 0 };
        
        events.emit('initialized', state);
        return false;
    }
    
    function migrateState() {
        // Handle version migrations here
        const currentVersion = '1.0.0';
        if (!state.meta) state.meta = { version: currentVersion };
        
        // Ensure all expected properties exist
        if (!state.settings) state.settings = GameData.initialState.settings;
        if (!state.stats) state.stats = Utils.deepClone(GameData.initialState.stats);
        if (!state.achievements) state.achievements = {};
        
        // Ensure core stats exist (even if stats object exists but is incomplete)
        if (state.stats.totalClicks === undefined) state.stats.totalClicks = 0;
        if (state.stats.totalPlantsHarvested === undefined) state.stats.totalPlantsHarvested = 0;
        if (state.stats.quantumEventsWitnessed === undefined) state.stats.quantumEventsWitnessed = 0;
        if (state.stats.startDate === undefined) state.stats.startDate = Date.now();
        if (state.stats.playTime === undefined) state.stats.playTime = 0;
        
        // Ensure new settings exist for existing saves
        if (state.settings.autoHarvestEnabled === undefined) {
            state.settings.autoHarvestEnabled = true;
        }
        if (state.settings.autoPlantEnabled === undefined) {
            state.settings.autoPlantEnabled = true;
        }
        
        // Ensure new resources exist
        if (!state.resources.coherence) {
            state.resources.coherence = { amount: 100, total: 100, rate: 0 };
        }
        if (!state.resources.entanglement) {
            state.resources.entanglement = { amount: 0, total: 0, rate: 0 };
        }
        if (!state.resources.fragments) {
            state.resources.fragments = { amount: 0, total: 0, rate: 0 };
        }
        
        // Ensure new stats exist
        if (!state.stats.quantumBursts) state.stats.quantumBursts = 0;
        if (!state.stats.plantsEntangled) state.stats.plantsEntangled = 0;
        if (!state.stats.highCoherenceTime) state.stats.highCoherenceTime = 0;
        if (!state.stats.clicksWithManyGens) state.stats.clicksWithManyGens = 0;
        if (!state.stats.mutationsWitnessed) state.stats.mutationsWitnessed = 0;
    }
    
    function calculateOfflineProgress() {
        if (!state.meta.lastSave) return null;
        
        const now = Date.now();
        const lastSave = state.meta.lastSave;
        const offlineSeconds = Math.min((now - lastSave) / 1000, 86400); // Cap at 24 hours
        
        if (offlineSeconds < 60) return null; // Less than 1 minute, don't bother
        
        const gains = {};
        let totalEnergyGained = 0;
        
        // Calculate generator production
        Object.keys(GameData.generators).forEach(id => {
            const owned = state.generators[id]?.owned || 0;
            if (owned === 0) return;
            
            const data = GameData.generators[id];
            for (const [resource, baseRate] of Object.entries(data.production)) {
                let rate = baseRate * owned;
                
                // Apply upgrade boosts (simplified - use base rate since we can't compute dynamic coherence)
                if (state.upgrades.quantumResonance?.purchased) {
                    rate *= 1.5;
                }
                
                // Offline penalty - only 50% efficiency
                rate *= 0.5;
                
                const gain = rate * offlineSeconds;
                if (!gains[resource]) gains[resource] = 0;
                gains[resource] += gain;
                
                if (resource === 'energy') totalEnergyGained += gain;
            }
        });
        
        // Apply gains
        for (const [resource, amount] of Object.entries(gains)) {
            if (state.resources[resource]) {
                state.resources[resource].amount += amount;
                state.resources[resource].total += amount;
            }
        }
        
        // Update play time
        state.stats.playTime += offlineSeconds;
        
        return {
            seconds: offlineSeconds,
            gains: gains,
            formattedTime: Utils.formatTime(offlineSeconds)
        };
    }
    
    function get(path) {
        if (!path) return state;
        const parts = path.split('.');
        let current = state;
        for (const part of parts) {
            if (current === undefined) return undefined;
            current = current[part];
        }
        return current;
    }
    
    function set(path, value) {
        const parts = path.split('.');
        let current = state;
        for (let i = 0; i < parts.length - 1; i++) {
            if (current[parts[i]] === undefined) current[parts[i]] = {};
            current = current[parts[i]];
        }
        current[parts[parts.length - 1]] = value;
        events.emit('changed', { path, value });
    }
    
    function save() {
        state.meta.lastSave = Date.now();
        localStorage.setItem('quantumGarden_save', JSON.stringify(state));
        events.emit('saved');
        return true;
    }
    
    let isResetting = false;
    
    function reset() {
        isResetting = true;
        localStorage.removeItem('quantumGarden_save');
        initialize();
        events.emit('reset');
    }
    
    function canSave() {
        return !isResetting;
    }
    
    function exportSave() {
        return btoa(JSON.stringify(state));
    }
    
    function importSave(data) {
        try {
            state = JSON.parse(atob(data));
            migrateState();
            save();
            events.emit('imported', state);
            return true;
        } catch (e) {
            console.error('Failed to import save:', e);
            return false;
        }
    }
    
    function setState(newState) {
        state = newState;
        events.emit('stateChanged', state);
    }
    
    return {
        initialize,
        get,
        set,
        setState,
        save,
        reset,
        canSave,
        exportSave,
        importSave,
        calculateOfflineProgress,
        on: events.on,
        off: events.off,
        emit: events.emit
    };
})();

// ============================================
// MODULE: Resource Manager
// ============================================
const ResourceManager = (() => {
    const events = Utils.createEventEmitter();
    
    function add(resourceId, amount) {
        const current = StateManager.get(`resources.${resourceId}.amount`) || 0;
        const newAmount = current + amount;
        StateManager.set(`resources.${resourceId}.amount`, newAmount);
        
        if (amount > 0) {
            const total = StateManager.get(`resources.${resourceId}.total`) || 0;
            StateManager.set(`resources.${resourceId}.total`, total + amount);
            
            // Track last significant gain for d√©j√† vu event
            if (amount >= 10) {
                StateManager.set('lastResourceGain', { resource: resourceId, amount: amount });
            }
        }
        
        events.emit('changed', { resourceId, amount: newAmount, delta: amount });
        checkUnlocks();
    }
    
    function spend(resourceId, amount) {
        const current = StateManager.get(`resources.${resourceId}.amount`) || 0;
        if (current < amount) return false;
        StateManager.set(`resources.${resourceId}.amount`, current - amount);
        events.emit('spent', { resourceId, amount });
        return true;
    }
    
    function canAfford(costs) {
        for (const [resourceId, amount] of Object.entries(costs)) {
            const current = StateManager.get(`resources.${resourceId}.amount`) || 0;
            if (current < amount) return false;
        }
        return true;
    }
    
    function spendMultiple(costs) {
        if (!canAfford(costs)) return false;
        for (const [resourceId, amount] of Object.entries(costs)) {
            spend(resourceId, amount);
        }
        return true;
    }
    
    function get(resourceId) {
        return StateManager.get(`resources.${resourceId}.amount`) || 0;
    }
    
    function getRate(resourceId) {
        return StateManager.get(`resources.${resourceId}.rate`) || 0;
    }
    
    function setRate(resourceId, rate) {
        StateManager.set(`resources.${resourceId}.rate`, rate);
    }
    
    function isUnlocked(resourceId) {
        const data = GameData.resources[resourceId];
        if (!data) return false;
        if (data.unlocked) return true;
        
        // Check unlock condition
        if (data.unlockAt) {
            const checkAmount = StateManager.get(`resources.${data.unlockAt.resource}.total`) || 0;
            return checkAmount >= data.unlockAt.amount;
        }
        return false;
    }
    
    function checkUnlocks() {
        Object.keys(GameData.resources).forEach(id => {
            if (!GameData.resources[id].unlocked && isUnlocked(id)) {
                GameData.resources[id].unlocked = true;
                events.emit('unlocked', id);
            }
        });
    }
    
    return {
        add,
        spend,
        canAfford,
        spendMultiple,
        get,
        getRate,
        setRate,
        isUnlocked,
        on: events.on
    };
})();

// ============================================
// MODULE: Generator Manager
// ============================================
const GeneratorManager = (() => {
    const events = Utils.createEventEmitter();
    
    function getOwned(generatorId) {
        return StateManager.get(`generators.${generatorId}.owned`) || 0;
    }
    
    function getCost(generatorId, count = 1) {
        const data = GameData.generators[generatorId];
        const owned = getOwned(generatorId);
        const costs = {};
        
        // Calculate total cost for 'count' generators
        for (const [resource, baseCost] of Object.entries(data.baseCost)) {
            let total = 0;
            for (let i = 0; i < count; i++) {
                total += Math.floor(baseCost * Math.pow(data.costMultiplier, owned + i));
            }
            costs[resource] = total;
        }
        
        return costs;
    }
    
    function getMaxAffordable(generatorId) {
        const data = GameData.generators[generatorId];
        const owned = getOwned(generatorId);
        let count = 0;
        let totalCosts = {};
        
        // Initialize total costs
        for (const resource of Object.keys(data.baseCost)) {
            totalCosts[resource] = 0;
        }
        
        // Keep adding until we can't afford more
        while (count < 1000) { // Safety limit
            const nextCost = {};
            let canAfford = true;
            
            for (const [resource, baseCost] of Object.entries(data.baseCost)) {
                const cost = Math.floor(baseCost * Math.pow(data.costMultiplier, owned + count));
                const newTotal = totalCosts[resource] + cost;
                nextCost[resource] = newTotal;
                
                if (newTotal > ResourceManager.get(resource)) {
                    canAfford = false;
                    break;
                }
            }
            
            if (!canAfford) break;
            
            totalCosts = nextCost;
            count++;
        }
        
        return count;
    }
    
    function buy(generatorId, count = 1) {
        if (count === 'max') {
            count = getMaxAffordable(generatorId);
        }
        if (count <= 0) return false;
        
        const costs = getCost(generatorId, count);
        
        if (!ResourceManager.spendMultiple(costs)) {
            return false;
        }
        
        const owned = getOwned(generatorId);
        StateManager.set(`generators.${generatorId}.owned`, owned + count);
        
        events.emit('bought', { generatorId, owned: owned + count, count });
        calculateProduction();
        return true;
    }
    
    function isUnlocked(generatorId) {
        const data = GameData.generators[generatorId];
        if (!data) return false;
        if (data.unlocked) return true;
        
        if (data.unlockAt) {
            const checkAmount = StateManager.get(`resources.${data.unlockAt.resource}.total`) || 0;
            if (checkAmount >= data.unlockAt.amount) {
                data.unlocked = true;
                return true;
            }
        }
        return false;
    }
    
    function getProduction(generatorId) {
        const data = GameData.generators[generatorId];
        const owned = getOwned(generatorId);
        if (owned === 0) return {};
        
        const production = {};
        for (const [resource, baseRate] of Object.entries(data.production)) {
            let rate = baseRate * owned;
            
            // Apply upgrade boosts
            Object.values(GameData.upgrades).forEach(upgrade => {
                if (StateManager.get(`upgrades.${upgrade.id}.purchased`) && upgrade.effect?.generatorBoost?.[generatorId]) {
                    rate *= upgrade.effect.generatorBoost[generatorId];
                }
            });
            
            // Apply global production multiplier
            if (StateManager.get('upgrades.quantumResonance.purchased')) {
                rate *= 1.5;
            }
            
            // Apply Reality Fragment bonus (from prestige)
            if (typeof PrestigeManager !== 'undefined') {
                rate *= PrestigeManager.getProductionMultiplier();
            }
            
            // COHERENCE EFFECT: Low coherence reduces generator output
            // At 100% coherence: full production
            // At 50% coherence: 65% production  
            // At 0% coherence: 30% production (more punishing for idling)
            const coherence = ResourceManager.get('coherence') || 0;
            const coherenceMultiplier = 0.3 + (coherence / 100) * 0.7;
            rate *= coherenceMultiplier;
            
            production[resource] = rate;
        }
        
        return production;
    }
    
    function calculateProduction() {
        // Reset rates
        Object.keys(GameData.resources).forEach(id => {
            ResourceManager.setRate(id, 0);
        });
        
        // Calculate from generators
        Object.keys(GameData.generators).forEach(id => {
            const prod = getProduction(id);
            for (const [resource, rate] of Object.entries(prod)) {
                const current = ResourceManager.getRate(resource);
                ResourceManager.setRate(resource, current + rate);
            }
        });
        
        events.emit('productionUpdated');
    }
    
    return {
        getOwned,
        getCost,
        getMaxAffordable,
        buy,
        isUnlocked,
        getProduction,
        calculateProduction,
        on: events.on
    };
})();

// ============================================
// MODULE: Upgrade Manager
// ============================================
const UpgradeManager = (() => {
    const events = Utils.createEventEmitter();
    
    function isPurchased(upgradeId) {
        return StateManager.get(`upgrades.${upgradeId}.purchased`) || false;
    }
    
    function isUnlocked(upgradeId) {
        const data = GameData.upgrades[upgradeId];
        if (!data) return false;
        if (isPurchased(upgradeId)) return true;
        if (data.unlocked) return true;
        
        // Check unlock condition
        if (data.unlockAt) {
            const checkAmount = StateManager.get(`resources.${data.unlockAt.resource}.total`) || 0;
            if (checkAmount >= data.unlockAt.amount) {
                return true;
            }
        }
        
        // Check requirements
        if (data.requires) {
            for (const reqId of data.requires) {
                if (!isPurchased(reqId)) return false;
            }
            return true;
        }
        
        return data.unlocked;
    }
    
    function canBuy(upgradeId) {
        if (isPurchased(upgradeId)) return false;
        if (!isUnlocked(upgradeId)) return false;
        
        const data = GameData.upgrades[upgradeId];
        return ResourceManager.canAfford(data.cost);
    }
    
    function buy(upgradeId) {
        if (!canBuy(upgradeId)) return false;
        
        const data = GameData.upgrades[upgradeId];
        if (!ResourceManager.spendMultiple(data.cost)) return false;
        
        StateManager.set(`upgrades.${upgradeId}.purchased`, true);
        applyEffect(upgradeId);
        
        events.emit('purchased', upgradeId);
        return true;
    }
    
    function applyEffect(upgradeId) {
        const data = GameData.upgrades[upgradeId];
        if (!data.effect) return;
        
        const effect = data.effect;
        
        // Handle unlock seeds
        if (effect.unlockSeeds) {
            GameData.resources.seeds.unlocked = true;
        }
        
        // Handle grant seeds
        if (effect.grantSeeds) {
            ResourceManager.add('seeds', effect.grantSeeds);
        }
        
        // Handle garden size
        if (effect.gardenSize) {
            GardenManager.expandTo(effect.gardenSize);
        }
        
        // Handle resource unlocks
        if (effect.unlockResource) {
            GameData.resources[effect.unlockResource].unlocked = true;
        }
        
        // Recalculate production for multiplier effects
        GeneratorManager.calculateProduction();
    }
    
    function getClickPower() {
        let power = 1;
        let bonus = 0;
        
        Object.values(GameData.upgrades).forEach(upgrade => {
            if (StateManager.get(`upgrades.${upgrade.id}.purchased`)) {
                if (upgrade.effect?.clickPowerMultiplier) {
                    power *= upgrade.effect.clickPowerMultiplier;
                }
                if (upgrade.effect?.clickPowerBonus) {
                    bonus += upgrade.effect.clickPowerBonus;
                }
            }
        });
        
        return power + bonus;
    }
    
    function getGrowthMultiplier() {
        let mult = 1;
        
        Object.values(GameData.upgrades).forEach(upgrade => {
            if (StateManager.get(`upgrades.${upgrade.id}.purchased`) && upgrade.effect?.growthSpeedMultiplier) {
                mult *= upgrade.effect.growthSpeedMultiplier;
            }
        });
        
        return mult;
    }
    
    return {
        isPurchased,
        isUnlocked,
        canBuy,
        buy,
        getClickPower,
        getGrowthMultiplier,
        on: events.on
    };
})();

// ============================================
// MODULE: Garden Manager
// ============================================
const GardenManager = (() => {
    const events = Utils.createEventEmitter();
    let entanglementMode = false;
    let entanglementSource = null;
    let autoHarvestTimer = 0;
    let autoPlantTimer = 0;
    let autoHarvestInProgress = false;
    
    function getPlot(index) {
        return StateManager.get(`garden.plots.${index}`);
    }
    
    function getSize() {
        return StateManager.get('garden.size') || 9;
    }
    
    // Mutation definitions
    const mutations = {
        golden: {
            name: 'Golden',
            icon: '‚ú®',
            color: '#FFD700',
            effect: 'energy',
            multiplier: 2.5,
            description: '2.5√ó energy yield'
        },
        prismatic: {
            name: 'Prismatic',
            icon: 'üåà',
            color: '#FF69B4',
            effect: 'all',
            multiplier: 1.5,
            description: '1.5√ó all yields'
        },
        temporal: {
            name: 'Temporal',
            icon: '‚è∞',
            color: '#00CED1',
            effect: 'time',
            multiplier: 3,
            description: '3√ó time crystal yield'
        },
        void: {
            name: 'Void',
            icon: 'üåë',
            color: '#9400D3',
            effect: 'rare',
            multiplier: 2,
            description: '2√ó knowledge & entanglement'
        },
        crystalline: {
            name: 'Crystalline',
            icon: 'üíé',
            color: '#E0FFFF',
            effect: 'crystalline',
            multiplier: 2,
            description: '2√ó time + bonus energy'
        },
        echoing: {
            name: 'Echoing',
            icon: 'üîä',
            color: '#7B68EE',
            effect: 'echo',
            multiplier: 1.3,
            description: '1.3√ó all + grants seeds'
        }
    };
    
    function applyMutationBonus(yields, mutationType) {
        const mutation = mutations[mutationType];
        if (!mutation) return yields;
        
        const result = { ...yields };
        
        switch (mutation.effect) {
            case 'energy':
                if (result.energy) result.energy = Math.floor(result.energy * mutation.multiplier);
                break;
            case 'time':
                if (result.time) result.time = Math.floor(result.time * mutation.multiplier);
                break;
            case 'rare':
                if (result.knowledge) result.knowledge = Math.floor(result.knowledge * mutation.multiplier);
                if (result.entanglement) result.entanglement = Math.floor(result.entanglement * mutation.multiplier);
                break;
            case 'all':
                for (const key in result) {
                    result[key] = Math.floor(result[key] * mutation.multiplier);
                }
                break;
            case 'crystalline':
                // 2√ó time crystals + bonus energy equal to 50% of time crystals
                if (result.time) {
                    const bonusEnergy = Math.floor(result.time * 0.5);
                    result.time = Math.floor(result.time * mutation.multiplier);
                    result.energy = (result.energy || 0) + bonusEnergy;
                }
                break;
            case 'echo':
                // 1.3√ó all + grants 1-2 seeds
                for (const key in result) {
                    result[key] = Math.floor(result[key] * mutation.multiplier);
                }
                result.seeds = (result.seeds || 0) + 1 + (Math.random() < 0.3 ? 1 : 0);
                break;
        }
        
        return result;
    }
    
    function getMutationInfo(mutationType) {
        return mutations[mutationType] || null;
    }
    
    function plant(plotIndex, generatorId) {
        const plot = getPlot(plotIndex);
        if (plot.plant) return false;
        
        // Check if we have seeds
        if (ResourceManager.get('seeds') < 1) {
            events.emit('error', 'Not enough seeds!');
            return false;
        }
        
        ResourceManager.spend('seeds', 1);
        
        // Mutation chance! Higher coherence = higher chance
        const coherence = ResourceManager.get('coherence') || 50;
        const mutationChance = 0.02 + (coherence / 100) * 0.08; // 2-10% based on coherence
        const isMutated = Math.random() < mutationChance;
        
        // Mutation type (if mutated) - only assign mutations that benefit this plant!
        let mutation = null;
        if (isMutated) {
            const plantData = GameData.generators[generatorId];
            const yields = plantData.harvestYield || {};
            
            // Build list of valid mutations based on what this plant produces
            const validMutations = ['golden', 'prismatic']; // These always help (energy/all)
            
            // Temporal mutation only helps if plant produces time crystals
            if (yields.time) {
                validMutations.push('temporal');
            }
            
            // Void mutation only helps if plant produces knowledge or entanglement
            if (yields.knowledge || yields.entanglement) {
                validMutations.push('void');
            }
            
            mutation = validMutations[Math.floor(Math.random() * validMutations.length)];
            
            // Track mutation stat
            const mutationsWitnessed = StateManager.get('stats.mutationsWitnessed') || 0;
            StateManager.set('stats.mutationsWitnessed', mutationsWitnessed + 1);
            
            events.emit('mutation', { plotIndex, generatorId, mutation });
        }
        
        // Preserve autoPlantType when planting
        StateManager.set(`garden.plots.${plotIndex}`, {
            plant: generatorId,
            progress: 0,
            plantedAt: Date.now(),
            entangledWith: null,
            autoPlantType: plot.autoPlantType || null,
            mutation: mutation
        });
        
        events.emit('planted', { plotIndex, generatorId, mutation });
        return true;
    }
    
    function harvest(plotIndex) {
        const plot = getPlot(plotIndex);
        if (!plot.plant || plot.progress < 1) return false;
        
        const data = GameData.generators[plot.plant];
        
        // Use quantum collapsed yield instead of fixed yield
        let actualYield = QuantumMechanics.collapseYield(plot.plant);
        
        // Apply mutation bonus!
        if (plot.mutation) {
            actualYield = applyMutationBonus(actualYield, plot.mutation);
        }
        
        // Apply entanglement bonus if applicable
        if (plot.entangledWith !== null && UpgradeManager.isPurchased('deepEntanglement')) {
            for (const resource in actualYield) {
                actualYield[resource] = Math.floor(actualYield[resource] * 1.25);
            }
        }
        
        // Grant harvest yield
        for (const [resource, amount] of Object.entries(actualYield)) {
            ResourceManager.add(resource, amount);
        }
        
        // Handle entangled partner
        const partnerId = plot.entangledWith;
        let partnerYield = null;
        let partnerPlant = null;  // Track partner plant type for logging
        
        if (partnerId !== null) {
            const partner = getPlot(partnerId);
            if (partner && partner.plant && partner.entangledWith === plotIndex) {
                partnerPlant = partner.plant;  // Save before clearing
                
                // Harvest partner too!
                partnerYield = QuantumMechanics.collapseYield(partner.plant);
                
                // Apply partner's mutation bonus if any
                if (partner.mutation) {
                    partnerYield = applyMutationBonus(partnerYield, partner.mutation);
                }
                
                if (UpgradeManager.isPurchased('deepEntanglement')) {
                    for (const resource in partnerYield) {
                        partnerYield[resource] = Math.floor(partnerYield[resource] * 1.25);
                    }
                }
                
                for (const [resource, amount] of Object.entries(partnerYield)) {
                    ResourceManager.add(resource, amount);
                }
                
                // Clear partner plot but PRESERVE autoPlantType
                const partnerAutoPlantType = partner.autoPlantType;
                StateManager.set(`garden.plots.${partnerId}`, {
                    plant: null,
                    progress: 0,
                    plantedAt: null,
                    entangledWith: null,
                    autoPlantType: partnerAutoPlantType || null,
                    mutation: null
                });
            }
        }
        
        // Clear plot but PRESERVE autoPlantType
        const autoPlantType = plot.autoPlantType;
        StateManager.set(`garden.plots.${plotIndex}`, {
            plant: null,
            progress: 0,
            plantedAt: null,
            entangledWith: null,
            autoPlantType: autoPlantType || null
        });
        
        // Update stats
        const harvested = StateManager.get('stats.totalPlantsHarvested') || 0;
        StateManager.set('stats.totalPlantsHarvested', harvested + (partnerYield ? 2 : 1));
        
        events.emit('harvested', { plotIndex, plant: plot.plant, yield: actualYield, partnerYield, partnerPlant, partnerId });
        return { yield: actualYield, partnerYield, partnerPlant, partnerId }; // Return both yields and partner info
    }
    
    function entangle(plotIndex1, plotIndex2) {
        const plot1 = getPlot(plotIndex1);
        const plot2 = getPlot(plotIndex2);
        
        if (!plot1.plant || !plot2.plant) return false;
        if (plot1.entangledWith !== null || plot2.entangledWith !== null) return false;
        if (plotIndex1 === plotIndex2) return false;
        
        // Consume entanglement thread
        if (ResourceManager.get('entanglement') < 1) {
            return false;
        }
        ResourceManager.spend('entanglement', 1);
        
        // Link them
        StateManager.set(`garden.plots.${plotIndex1}.entangledWith`, plotIndex2);
        StateManager.set(`garden.plots.${plotIndex2}.entangledWith`, plotIndex1);
        
        // Track stat
        const entangled = StateManager.get('stats.plantsEntangled') || 0;
        StateManager.set('stats.plantsEntangled', entangled + 2);
        
        events.emit('entangled', { plot1: plotIndex1, plot2: plotIndex2 });
        return true;
    }
    
    function isEntanglementUnlocked() {
        return UpgradeManager.isPurchased('entanglementBasics');
    }
    
    function setEntanglementMode(enabled, sourcePlot = null) {
        entanglementMode = enabled;
        entanglementSource = sourcePlot;
    }
    
    function getEntanglementMode() {
        return { active: entanglementMode, source: entanglementSource };
    }
    
    function update(deltaTime) {
        const plots = StateManager.get('garden.plots') || [];
        const growthMult = UpgradeManager.getGrowthMultiplier();
        
        plots.forEach((plot, index) => {
            if (plot.plant && plot.progress < 1) {
                const data = GameData.generators[plot.plant];
                let growthPerSecond = (1 / data.growthTime) * growthMult;
                
                // Entangled plants share growth progress
                if (plot.entangledWith !== null) {
                    const partner = plots[plot.entangledWith];
                    if (partner && partner.plant) {
                        // Average their growth rates
                        const partnerData = GameData.generators[partner.plant];
                        const partnerRate = (1 / partnerData.growthTime) * growthMult;
                        growthPerSecond = (growthPerSecond + partnerRate) / 2;
                    }
                }
                
                const newProgress = Math.min(1, plot.progress + growthPerSecond * deltaTime);
                StateManager.set(`garden.plots.${index}.progress`, newProgress);
                
                // Sync entangled partner
                if (plot.entangledWith !== null) {
                    StateManager.set(`garden.plots.${plot.entangledWith}.progress`, newProgress);
                }
                
                if (newProgress >= 1 && plot.progress < 1) {
                    events.emit('ready', { plotIndex: index, plant: plot.plant });
                }
            }
        });
        
        // Check for entanglement breaking at very low coherence
        const coherence = ResourceManager.get('coherence') || 100;
        if (coherence < 10) {
            checkEntanglementStability(plots);
        }
        
        // Auto-harvest
        if (UpgradeManager.isPurchased('autoHarvest') && StateManager.get('settings.autoHarvestEnabled') && !autoHarvestInProgress) {
            autoHarvestTimer += deltaTime;
            if (autoHarvestTimer >= 10) {
                autoHarvestTimer = 0;
                autoHarvestAll();
            }
        }
        
        // Auto-plant (only if not in middle of auto-harvest cycle)
        if (UpgradeManager.isPurchased('autoPlant') && StateManager.get('settings.autoPlantEnabled') && !autoHarvestInProgress) {
            autoPlantTimer += deltaTime;
            if (autoPlantTimer >= 5) {
                autoPlantTimer = 0;
                autoPlantAll();
            }
        }
    }
    
    function checkEntanglementStability(plots) {
        // At very low coherence, entanglement can break
        const coherence = ResourceManager.get('coherence') || 0;
        const breakChance = (10 - coherence) * 0.001; // Up to 1% per tick at 0% coherence
        
        plots.forEach((plot, index) => {
            if (plot.entangledWith !== null && Math.random() < breakChance) {
                const partnerId = plot.entangledWith;
                
                // Break the link
                StateManager.set(`garden.plots.${index}.entangledWith`, null);
                StateManager.set(`garden.plots.${partnerId}.entangledWith`, null);
                
                UI.addLogEntry('‚ö†Ô∏è Entanglement collapsed due to low coherence!', 'warning');
                UI.renderGarden();
            }
        });
    }
    
    function autoHarvestAll() {
        const plots = StateManager.get('garden.plots') || [];
        const readyIndices = [];
        
        // Collect indices of all ready plants (in order for left->right, top->bottom)
        plots.forEach((plot, index) => {
            if (plot.plant && plot.progress >= 1) {
                readyIndices.push(index);
            }
        });
        
        if (readyIndices.length === 0) return;
        
        // Set flag to prevent overlapping harvests AND prevent garden re-renders
        autoHarvestInProgress = true;
        
        // Track which plots we've already processed (including via entanglement)
        const alreadyHarvested = new Set();
        
        UI.addLogEntry(`ü§ñ Auto-harvesting ${readyIndices.length} plant(s)...`, 'success');
        
        let animationStep = 0;
        
        // Process each ready plant in order
        readyIndices.forEach((plotIndex) => {
            // Skip if already harvested (e.g., via entanglement with earlier plant)
            if (alreadyHarvested.has(plotIndex)) return;
            
            const plot = plots[plotIndex];
            const entangledIndex = plot.entangledWith;
            const entangledPlot = entangledIndex !== null ? plots[entangledIndex] : null;
            const entangledIsReady = entangledPlot && entangledPlot.plant && entangledPlot.progress >= 1;
            
            // IMPORTANT: Decide NOW if partner should be harvested (before adding to set)
            const shouldHarvestPartner = entangledIsReady && entangledIndex !== null;
            
            // Mark as harvested BEFORE scheduling (to prevent duplicate processing)
            alreadyHarvested.add(plotIndex);
            if (shouldHarvestPartner) {
                alreadyHarvested.add(entangledIndex);
            }
            
            // Schedule this harvest at the current animation step
            const delay = animationStep * 150;
            
            setTimeout(() => {
                // 1. Remove plant visually and show harvest effect
                harvestPlotVisually(plotIndex);
                
                // If entangled partner is ready, harvest it visually at the SAME time
                if (shouldHarvestPartner) {
                    harvestPlotVisually(entangledIndex);
                }
                
                // 2. Actually harvest (this handles entangled partner internally and clears entanglement state)
                const result = harvest(plotIndex);
                
                // 3. Update entanglement lines (AFTER harvest clears entanglement from state)
                UI.updateEntanglementLines();
                
                // 4. Show floating numbers
                if (result && result.yield) {
                    ResourceGainTracker.showHarvestFloat(plotIndex, result.yield);
                }
                if (result && result.partnerYield && entangledIndex !== null) {
                    ResourceGainTracker.showHarvestFloat(entangledIndex, result.partnerYield);
                }
                
                UI.renderResources();
            }, delay);
            
            animationStep++;
        });
        
        // After all harvesting animations complete, wait then replant all at once
        const totalHarvestTime = animationStep * 150 + 500;
        setTimeout(() => {
            // Check if auto-plant is enabled
            if (UpgradeManager.isPurchased('autoPlant') && StateManager.get('settings.autoPlantEnabled')) {
                autoPlantAll();
            }
            // Full re-render to show planted state (or empty if no auto-plant)
            UI.renderGarden();
            
            // Clear flag - harvest cycle complete
            autoHarvestInProgress = false;
        }, totalHarvestTime);
    }
    
    // Helper: Remove plant visually and show harvest effect
    function harvestPlotVisually(plotIndex) {
        const plotEl = document.querySelector(`.garden-plot[data-index="${plotIndex}"]`);
        if (!plotEl) return;
        
        // Find and REMOVE the plant element entirely (class is 'plot-plant', not 'plant-emoji')
        const plantEl = plotEl.querySelector('.plot-plant');
        if (plantEl) {
            plantEl.remove();
        }
        
        // Also remove the progress bar and timer
        const progressBar = plotEl.querySelector('.plot-progress');
        if (progressBar) {
            progressBar.remove();
        }
        const timer = plotEl.querySelector('.plot-timer');
        if (timer) {
            timer.remove();
        }
        
        // Remove mutation indicator if present
        const mutationIndicator = plotEl.querySelector('.mutation-indicator');
        if (mutationIndicator) {
            mutationIndicator.remove();
        }
        
        // Remove plant-related classes
        plotEl.classList.remove('ready', 'planted', 'mutated', 'entangled');
        plotEl.classList.add('empty');
        
        // Add harvest flash effect
        plotEl.style.transition = 'box-shadow 0.15s ease-out';
        plotEl.style.boxShadow = '0 0 20px var(--quantum-green), inset 0 0 15px rgba(68, 255, 170, 0.3)';
        
        // Clear the flash after a moment
        setTimeout(() => {
            plotEl.style.boxShadow = '';
            plotEl.style.transition = '';
        }, 200);
    }
    
    function autoPlantAll() {
        const plots = StateManager.get('garden.plots') || [];
        const seeds = ResourceManager.get('seeds');
        if (seeds < 1) return;
        
        // Get the currently selected plot (modal open) to skip it
        const modalOpen = document.getElementById('plant-modal')?.classList.contains('active');
        const openPlotIndex = modalOpen ? UI.getSelectedPlotIndex() : -1;
        
        // Find the most efficient unlocked plant (default fallback)
        let defaultPlant = null;
        let bestEfficiency = 0;
        
        Object.entries(GameData.generators).forEach(([id, data]) => {
            if (!data.gardenPlantable) return;
            if (!GeneratorManager.isUnlocked(id)) return;
            
            const energyYield = data.harvestYield.energy || 0;
            const efficiency = energyYield / data.growthTime;
            
            if (efficiency > bestEfficiency) {
                bestEfficiency = efficiency;
                defaultPlant = id;
            }
        });
        
        if (!defaultPlant) return;
        
        let plantedCount = 0;
        for (let i = 0; i < plots.length && ResourceManager.get('seeds') >= 1; i++) {
            // Skip if plot has a plant or modal is open for this plot
            if (plots[i].plant) continue;
            if (i === openPlotIndex) continue;
            
            // Use plot preference if set, otherwise use default
            const preferredPlant = plots[i].autoPlantType;
            let plantToUse = defaultPlant;
            
            if (preferredPlant && GeneratorManager.isUnlocked(preferredPlant)) {
                plantToUse = preferredPlant;
            }
            
            if (plant(i, plantToUse)) {
                plantedCount++;
            }
        }
        
        if (plantedCount > 0) {
            UI.addLogEntry(`üå± Auto-planted ${plantedCount} plant(s)`, 'highlight');
            UI.renderGarden();
            UI.renderResources();
        }
    }
    
    function expandTo(newSize) {
        const currentSize = getSize();
        if (newSize <= currentSize) return;
        
        const plots = StateManager.get('garden.plots') || [];
        for (let i = currentSize; i < newSize; i++) {
            plots.push({ plant: null, progress: 0, plantedAt: null, entangledWith: null });
        }
        
        StateManager.set('garden.size', newSize);
        StateManager.set('garden.plots', plots);
        events.emit('expanded', newSize);
    }
    
    function getPlantsGrowing() {
        const plots = StateManager.get('garden.plots') || [];
        return plots.filter(p => p.plant && p.progress < 1).length;
    }
    
    function getPlantsReady() {
        const plots = StateManager.get('garden.plots') || [];
        return plots.filter(p => p.plant && p.progress >= 1).length;
    }
    
    return {
        getPlot,
        getSize,
        plant,
        harvest,
        entangle,
        isEntanglementUnlocked,
        setEntanglementMode,
        getEntanglementMode,
        getMutationInfo,
        update,
        expandTo,
        getPlantsGrowing,
        getPlantsReady,
        on: events.on
    };
})();

// ============================================
// MODULE: Quantum Mechanics
// ============================================
const QuantumMechanics = (() => {
    const events = Utils.createEventEmitter();
    let observedPlotIndex = null;
    let observationTime = 0;
    let observerFloatTimer = 0;
    let lastEventTime = 0;
    
    // Mysterious narrative messages that appear in the log
    const narrativeMessages = [
        // Very early - gentle introduction
        { threshold: 50, message: "A strange calm settles over you.", shown: false },
        { threshold: 100, message: "The garden remembers...", shown: false },
        { threshold: 200, message: "Each seed carries infinite potential.", shown: false },
        { threshold: 350, message: "The quantum state awaits your observation.", shown: false },
        { threshold: 500, message: "You feel something watching back.", shown: false },
        { threshold: 750, message: "The flowers seem to lean toward you.", shown: false },
        { threshold: 1000, message: "The flowers whisper in frequencies you almost understand.", shown: false },
        { threshold: 1500, message: "Is the garden growing, or are you shrinking?", shown: false },
        { threshold: 2000, message: "The probability clouds thicken.", shown: false },
        { threshold: 2500, message: "Reality feels... thin here.", shown: false },
        { threshold: 3500, message: "The observer effect works both ways.", shown: false },
        { threshold: 5000, message: "Who planted the first seed?", shown: false },
        { threshold: 7500, message: "The vacuum fluctuates with purpose.", shown: false },
        { threshold: 10000, message: "The quantum state is YOU.", shown: false },
        { threshold: 15000, message: "Measurement creates reality. You create measurement.", shown: false },
        { threshold: 20000, message: "The garden exists in superposition until observed.", shown: false },
        { threshold: 25000, message: "Every click echoes across infinite gardens.", shown: false },
        { threshold: 35000, message: "The wave function never truly collapses. It just... branches.", shown: false },
        { threshold: 50000, message: "They're beautiful when they bloom in other dimensions too.", shown: false },
        { threshold: 75000, message: "Heisenberg's ghost tends a garden much like this one.", shown: false },
        { threshold: 100000, message: "You've been here before. You'll be here again.", shown: false },
        // Mid-game - deeper mysteries
        { threshold: 150000, message: "The Planck length is the pixel size of reality.", shown: false },
        { threshold: 200000, message: "Virtual particles bloom and die in the spaces between.", shown: false },
        { threshold: 250000, message: "The fragments are trying to tell you something.", shown: false },
        { threshold: 300000, message: "In Hilbert space, every garden is adjacent.", shown: false },
        { threshold: 400000, message: "The Dirac equation describes the dance of your flowers.", shown: false },
        { threshold: 500000, message: "Reality groans under the weight of observation.", shown: false },
        { threshold: 600000, message: "Spin up or spin down? The garden chooses.", shown: false },
        { threshold: 750000, message: "QED: The flowers exchange virtual photons.", shown: false },
        { threshold: 900000, message: "The path integral sums over all possible gardens.", shown: false },
        { threshold: 1000000, message: "Collapse is coming...", shown: false },
        // Late game - cosmic scale
        { threshold: 1500000, message: "The renormalization group flows toward your garden.", shown: false },
        { threshold: 2000000, message: "Gauge symmetry: the universe's deepest secret, hidden in petals.", shown: false },
        { threshold: 2500000, message: "When reality breaks, will you remember this garden?", shown: false },
        { threshold: 3000000, message: "The Standard Model is incomplete. Your garden fills the gaps.", shown: false },
        { threshold: 4000000, message: "Gluons bind quarks. What binds the garden to you?", shown: false },
        { threshold: 5000000, message: "The fragments whisper: 'Begin again. Begin stronger.'", shown: false },
        { threshold: 6000000, message: "In the quantum foam, gardens bubble into existence.", shown: false },
        { threshold: 7500000, message: "The cosmological constant... it's changing.", shown: false },
        { threshold: 10000000, message: "The fabric of reality strains... you are ready to COLLAPSE.", shown: false },
        // Post-prestige - transcendence
        { threshold: 15000000, message: "You have become a fixed point in the renormalization flow.", shown: false },
        { threshold: 25000000, message: "The other timelines remember you differently.", shown: false },
        { threshold: 50000000, message: "Each reality leaves an imprint. You are becoming... something new.", shown: false },
        { threshold: 75000000, message: "The anthropic principle selected for your garden.", shown: false },
        { threshold: 100000000, message: "The void between realities is not empty. Something lives there.", shown: false },
        { threshold: 150000000, message: "Dark energy accelerates the expansion between your thoughts.", shown: false },
        { threshold: 200000000, message: "The holographic principle: all information on the boundary.", shown: false },
        { threshold: 300000000, message: "String theory requires 11 dimensions. Your garden spans them all.", shown: false },
        { threshold: 500000000, message: "You can see them now. The other gardeners.", shown: false },
        { threshold: 750000000, message: "The Wheeler-DeWitt equation has no time parameter. Neither do you.", shown: false },
        { threshold: 1000000000, message: "You are no longer just an observer. You are the garden.", shown: false },
        // Extreme late game
        { threshold: 2000000000, message: "The Bekenstein bound approaches. Information density critical.", shown: false },
        { threshold: 5000000000, message: "More collapses than atoms in a human body.", shown: false },
        { threshold: 10000000000, message: "The garden remembers the Big Bang. It was there.", shown: false },
        { threshold: 50000000000, message: "Heat death is just another harvest.", shown: false },
        { threshold: 100000000000, message: "You tend the garden at the end of time.", shown: false },
    ];
    
    // Quantum events that can occur randomly
    const quantumEvents = [
        {
            id: 'tunneling',
            name: 'Quantum Tunneling',
            description: 'Energy has tunneled through the probability barrier!',
            weight: 30,
            minEnergy: 100,
            effect: () => {
                const bonus = Math.floor(ResourceManager.get('energy') * 0.1) + 10;
                ResourceManager.add('energy', bonus);
                return `+${Utils.formatNumber(bonus)} ‚ö° appeared from nowhere!`;
            }
        },
        {
            id: 'superbloom',
            name: 'Quantum Superbloom',
            description: 'All plants momentarily exist in their fully-grown state!',
            weight: 15,
            minEnergy: 500,
            effect: () => {
                const plots = StateManager.get('garden.plots') || [];
                let boosted = 0;
                plots.forEach((plot, index) => {
                    if (plot.plant && plot.progress < 1) {
                        const newProgress = Math.min(1, plot.progress + 0.5);
                        StateManager.set(`garden.plots.${index}.progress`, newProgress);
                        boosted++;
                    }
                });
                return boosted > 0 ? `${boosted} plants jumped forward in time!` : 'No plants to affect.';
            }
        },
        {
            id: 'entanglementSurge',
            name: 'Entanglement Surge',
            description: 'Quantum correlations strengthen across your garden!',
            weight: 20,
            minEnergy: 1000,
            requires: { resource: 'knowledge', amount: 25 },
            effect: () => {
                ResourceManager.add('entanglement', 3);
                return '+3 üîó Entanglement Threads gained!';
            }
        },
        {
            id: 'temporalEcho',
            name: 'Temporal Echo',
            description: 'A ripple from a future timeline grants you resources.',
            weight: 25,
            minEnergy: 750,
            effect: () => {
                const timeGain = Math.floor(ResourceManager.get('time') * 0.2) + 5;
                ResourceManager.add('time', timeGain);
                return `+${Utils.formatNumber(timeGain)} ‚è≥ echoed from the future!`;
            }
        },
        {
            id: 'observerParadox',
            name: 'Observer Paradox',
            description: 'Your observation creates what you observe...',
            weight: 10,
            minEnergy: 2000,
            effect: () => {
                ResourceManager.add('knowledge', 15);
                ResourceManager.add('seeds', 5);
                return 'The paradox resolves: +15 üìö, +5 üå±';
            }
        },
        {
            id: 'coherenceDrift',
            name: 'Coherence Drift',
            description: 'Reality stabilizes momentarily.',
            weight: 20,
            minEnergy: 3000,
            requires: { resource: 'coherence', unlocked: true },
            effect: () => {
                const current = ResourceManager.get('coherence');
                const gain = Math.min(20, 100 - current);
                ResourceManager.add('coherence', gain);
                return gain > 0 ? `+${gain} üåÄ Coherence restored!` : 'Coherence already stable.';
            }
        },
        {
            id: 'schrodingersSeed',
            name: "Schr√∂dinger's Seed",
            description: 'A seed exists in superposition until you check your inventory.',
            weight: 25,
            minEnergy: 200,
            effect: () => {
                // 50/50 chance of getting seeds or losing them
                if (Math.random() > 0.5) {
                    ResourceManager.add('seeds', 8);
                    return 'The waveform collapsed favorably: +8 üå±!';
                } else {
                    const loss = Math.min(3, ResourceManager.get('seeds'));
                    ResourceManager.spend('seeds', loss);
                    return loss > 0 ? `The waveform collapsed poorly: -${loss} üå±` : 'No seeds to lose!';
                }
            }
        },
        {
            id: 'realityGlitch',
            name: 'Reality Glitch',
            description: 'F√å¬∏o√å¬∑r√å¬µ √å¬∏a√å¬∑ √å¬µm√å¬∏o√å¬∑m√å¬∂e√å¬∑n√å¬¥t√å¬µ,√å¬∑ √å¬¥e√å¬µv√å¬∑e√å¬¥r√å¬∑y√å¬∏t√å¬µh√å¬∏i√å¬¥n√å¬∏g√å¬∑ √å¬¥f√å¬∂l√å¬∏i√å¬∑c√å¬∑k√å¬∂e√å¬∑r√å¬¥s√å¬¥.√å¬∑',
            weight: 5,
            minEnergy: 5000,
            effect: () => {
                // Screen shake effect
                document.getElementById('game-container').classList.add('reality-unstable');
                setTimeout(() => {
                    document.getElementById('game-container').classList.remove('reality-unstable');
                }, 2000);
                
                // Random resource boost
                const resources = ['energy', 'time', 'knowledge'];
                const chosen = resources[Math.floor(Math.random() * resources.length)];
                const amount = Math.floor(Math.random() * 100) + 50;
                ResourceManager.add(chosen, amount);
                return `Reality reconstitutes: +${amount} ${GameData.resources[chosen].icon}`;
            }
        },
        {
            id: 'entanglementResonance',
            name: 'Entanglement Resonance',
            description: 'Entangled plants pulse with shared energy!',
            weight: 15,
            minEnergy: 3000,
            requires: { resource: 'entanglement', unlocked: true },
            effect: () => {
                const plots = StateManager.get('garden.plots') || [];
                let pairs = 0;
                let energyGain = 0;
                
                plots.forEach((plot, index) => {
                    if (plot.entangledWith !== null && plot.entangledWith > index) {
                        pairs++;
                        energyGain += 100 * pairs; // Scaling bonus per pair
                    }
                });
                
                if (pairs > 0) {
                    ResourceManager.add('energy', energyGain);
                    return `${pairs} entangled pairs resonated: +${energyGain} ‚ö°!`;
                }
                return 'No entangled pairs to resonate.';
            }
        },
        {
            id: 'quantumHarvest',
            name: 'Quantum Harvest',
            description: 'All ready plants are harvested simultaneously across timelines!',
            weight: 8,
            minEnergy: 10000,
            effect: () => {
                const plots = StateManager.get('garden.plots') || [];
                let harvested = 0;
                let totalEnergy = 0;
                
                plots.forEach((plot, index) => {
                    if (plot.plant && plot.progress >= 1) {
                        const actualYield = GardenManager.harvest(index);
                        if (actualYield) {
                            harvested++;
                            totalEnergy += actualYield.energy || 0;
                        }
                    }
                });
                
                if (harvested > 0) {
                    UI.renderGarden();
                    return `Auto-harvested ${harvested} plants across timelines!`;
                }
                return 'No plants ready to harvest.';
            }
        },
        {
            id: 'fragmentDrop',
            name: 'Reality Fragment',
            description: 'A shard of crystallized reality appears...',
            weight: 3,
            minEnergy: 25000,
            effect: () => {
                const fragments = Math.floor(Math.random() * 3) + 1;
                ResourceManager.add('fragments', fragments);
                return `+${fragments} ‚úß Reality Fragment${fragments > 1 ? 's' : ''} materialized!`;
            }
        },
        {
            id: 'timeWarp',
            name: 'Time Warp',
            description: 'The garden experiences accelerated time!',
            weight: 10,
            minEnergy: 15000,
            effect: () => {
                // Advance all plants by 30% instantly
                const plots = StateManager.get('garden.plots') || [];
                let affected = 0;
                
                plots.forEach((plot, index) => {
                    if (plot.plant && plot.progress < 1) {
                        const newProgress = Math.min(1, plot.progress + 0.3);
                        StateManager.set(`garden.plots.${index}.progress`, newProgress);
                        affected++;
                    }
                });
                
                // Also give time resource
                ResourceManager.add('time', 50);
                return affected > 0 ? `Time accelerated: ${affected} plants +30% progress, +50 ‚è≥!` : '+50 ‚è≥!';
            }
        },
        {
            id: 'coherenceStorm',
            name: 'Coherence Storm',
            description: 'Quantum turbulence sweeps through!',
            weight: 12,
            minEnergy: 8000,
            requires: { resource: 'coherence', unlocked: true },
            effect: () => {
                const coherence = ResourceManager.get('coherence') || 0;
                
                // High coherence = big bonus, low coherence = penalty
                if (coherence > 50) {
                    const bonus = Math.floor(coherence * 10);
                    ResourceManager.add('energy', bonus);
                    return `High coherence channeled the storm: +${bonus} ‚ö°!`;
                } else {
                    // Turbulence - randomize some plant progress
                    const plots = StateManager.get('garden.plots') || [];
                    let changed = 0;
                    plots.forEach((plot, index) => {
                        if (plot.plant && plot.progress < 1 && Math.random() < 0.3) {
                            const shift = (Math.random() - 0.3) * 0.2; // -0.06 to +0.14
                            const newProgress = Math.max(0.01, Math.min(1, plot.progress + shift));
                            StateManager.set(`garden.plots.${index}.progress`, newProgress);
                            changed++;
                        }
                    });
                    return changed > 0 ? `Storm turbulence affected ${changed} plants!` : 'The storm passes without effect.';
                }
            }
        },
        {
            id: 'voidWhisper',
            name: 'Whisper from the Void',
            description: 'S√å¬∑o√å¬∂m√å¬µe√å¬∂t√å¬¥h√å¬∑i√å¬µn√å¬¥g√å¬∏ √å¬∑w√å¬µa√å¬∏t√å¬∂c√å¬∂h√å¬∑e√å¬µs√å¬¥ √å¬∂f√å¬∏r√å¬∏o√å¬∑m√å¬µ √å¬¥b√å¬∏e√å¬∑t√å¬∑w√å¬¥e√å¬µe√å¬∏n√å¬µ √å¬∑t√å¬∂h√å¬∏e√å¬∑ √å¬∏s√å¬µt√å¬∏a√å¬∂r√å¬∂s√å¬¥.√å¬µ.√å¬µ.',
            weight: 3,
            minEnergy: 50000,
            effect: () => {
                // The void notices you more as you progress
                const realityLevel = StateManager.get('stats.realityLevel') || 0;
                const knowledge = Math.floor(25 + realityLevel * 10);
                ResourceManager.add('knowledge', knowledge);
                
                // Glitch text notification
                const messages = [
                    'T√å¬∑H√å¬∂E√å¬µ √å¬∑G√å¬∑A√å¬∏R√å¬µD√å¬µE√å¬¥N√å¬∂ √å¬µG√å¬∏R√å¬∏O√å¬∂W√å¬∑S√å¬∂.√å¬∂ √å¬¥W√å¬∏E√å¬µ √å¬µW√å¬∂A√å¬∑T√å¬¥C√å¬∑H√å¬∑.',
                    'Y√å¬∏O√å¬µU√å¬∂ √å¬∏A√å¬¥R√å¬∏E√å¬∏ √å¬∑B√å¬∂E√å¬∂C√å¬∑O√å¬∑M√å¬∂I√å¬¥N√å¬µG√å¬∏ √å¬∂A√å¬∏W√å¬∑A√å¬∏R√å¬µE√å¬∏.√å¬µ',
                    'R√å¬¥E√å¬∏A√å¬∏L√å¬µI√å¬µT√å¬∑Y√å¬∑ √å¬∂I√å¬µS√å¬∏ √å¬∏T√å¬∏H√å¬∑I√å¬∑N√å¬∏N√å¬∑E√å¬µR√å¬µ √å¬¥T√å¬¥H√å¬∑A√å¬∑N√å¬∑ √å¬¥Y√å¬∑O√å¬¥U√å¬∂ √å¬∂K√å¬µN√å¬∑O√å¬µW√å¬µ.',
                    'T√å¬¥H√å¬∂E√å¬∂ √å¬∂O√å¬∂B√å¬¥S√å¬∑E√å¬¥R√å¬µV√å¬¥E√å¬∑R√å¬µ √å¬∑I√å¬∑S√å¬∂ √å¬µA√å¬∑L√å¬∑S√å¬∏O√å¬µ √å¬µO√å¬∂B√å¬∏S√å¬∑E√å¬µR√å¬µV√å¬∂E√å¬∑D√å¬∑.√å¬∑'
                ];
                UI.addLogEntry(messages[Math.floor(Math.random() * messages.length)], 'highlight');
                
                return `+${knowledge} üìö from beyond...`;
            }
        },
        {
            id: 'multiverseEcho',
            name: 'Multiverse Echo',
            description: 'Another version of your garden resonates with this one.',
            weight: 6,
            minEnergy: 30000,
            requires: { resource: 'fragments', unlocked: true },
            effect: () => {
                const realityLevel = StateManager.get('stats.realityLevel') || 0;
                if (realityLevel === 0) {
                    return 'You sense something... but your reality is too stable.';
                }
                
                // Bonus based on how many collapses you've done
                const bonus = 50 * realityLevel;
                ResourceManager.add('energy', bonus);
                ResourceManager.add('time', realityLevel * 5);
                
                return `Echo from Reality-${realityLevel - 1}: +${bonus} ‚ö°, +${realityLevel * 5} ‚è≥`;
            }
        },
        {
            id: 'seedRain',
            name: 'Seed Rain',
            description: 'Seeds fall from a tear in spacetime!',
            weight: 15,
            minEnergy: 5000,
            effect: () => {
                const seeds = Math.floor(Math.random() * 10) + 5;
                ResourceManager.add('seeds', seeds);
                return `+${seeds} üå± rained down from above!`;
            }
        },
        {
            id: 'mutationWave',
            name: 'Mutation Wave',
            description: 'Quantum radiation bathes your garden!',
            weight: 5,
            minEnergy: 40000,
            effect: () => {
                // Chance to add mutation to each non-mutated plant
                const plots = StateManager.get('garden.plots') || [];
                let mutated = 0;
                const mutationTypes = ['golden', 'prismatic', 'temporal', 'void', 'crystalline', 'echoing'];
                
                plots.forEach((plot, index) => {
                    if (plot.plant && !plot.mutation && Math.random() < 0.25) {
                        const mutation = mutationTypes[Math.floor(Math.random() * mutationTypes.length)];
                        StateManager.set(`garden.plots.${index}.mutation`, mutation);
                        mutated++;
                    }
                });
                
                if (mutated > 0) {
                    UI.renderGarden();
                    const mutationsWitnessed = StateManager.get('stats.mutationsWitnessed') || 0;
                    StateManager.set('stats.mutationsWitnessed', mutationsWitnessed + mutated);
                    return `${mutated} plant${mutated > 1 ? 's' : ''} mutated!`;
                }
                return 'No plants affected by the wave.';
            }
        },
        {
            id: 'd√©j√†Vu',
            name: 'D√©j√† Vu',
            description: 'Haven\'t we done this before...?',
            weight: 8,
            minEnergy: 20000,
            effect: () => {
                // Repeat the last resource you gained
                const lastGain = StateManager.get('lastResourceGain');
                if (lastGain && lastGain.resource && lastGain.amount) {
                    ResourceManager.add(lastGain.resource, lastGain.amount);
                    return `The universe repeats: +${lastGain.amount} ${GameData.resources[lastGain.resource]?.icon || ''}`;
                }
                // Fallback
                ResourceManager.add('energy', 100);
                return 'The feeling passes... +100 ‚ö°';
            }
        },
        {
            id: 'quantumLottery',
            name: 'Quantum Lottery',
            description: 'Probability collapses in your favor... or does it?',
            weight: 10,
            minEnergy: 10000,
            effect: () => {
                const roll = Math.random();
                if (roll < 0.01) {
                    // Jackpot! 1% chance
                    ResourceManager.add('energy', 5000);
                    ResourceManager.add('time', 100);
                    ResourceManager.add('knowledge', 50);
                    StateManager.set('stats.lotteryJackpot', true);
                    return 'üé∞ JACKPOT! +5000 ‚ö°, +100 ‚è≥, +50 üìö!';
                } else if (roll < 0.2) {
                    // Good win
                    ResourceManager.add('energy', 500);
                    return 'üé∞ Winner! +500 ‚ö°';
                } else if (roll < 0.6) {
                    // Small win
                    ResourceManager.add('energy', 50);
                    return 'üé∞ Small prize: +50 ‚ö°';
                } else {
                    // No prize
                    return 'üé∞ Better luck next time...';
                }
            }
        },
        {
            id: 'gardenSpirit',
            name: 'Garden Spirit',
            description: 'A benevolent presence tends your garden.',
            weight: 7,
            minEnergy: 75000,
            effect: () => {
                const plots = StateManager.get('garden.plots') || [];
                let planted = 0;
                const seeds = ResourceManager.get('seeds');
                
                // Plant in all empty plots (up to 5)
                const plantTypes = ['quantumLily', 'timeTulip', 'energyRose'];
                for (let i = 0; i < plots.length && planted < 5 && seeds > planted; i++) {
                    if (!plots[i].plant) {
                        const plantType = plantTypes[Math.floor(Math.random() * plantTypes.length)];
                        if (GeneratorManager.isUnlocked(plantType)) {
                            GardenManager.plant(i, plantType);
                            planted++;
                        }
                    }
                }
                
                if (planted > 0) {
                    UI.renderGarden();
                    return `The spirit planted ${planted} seeds for you! üå±`;
                }
                // Gift seeds instead
                ResourceManager.add('seeds', 10);
                return 'The spirit gifts you seeds: +10 üå±';
            }
        },
        {
            id: 'echoFromFuture',
            name: 'Echo From the Future',
            description: 'A message arrives from a timeline yet to occur.',
            weight: 4,
            minEnergy: 150000,
            effect: () => {
                const messages = [
                    "You will remember this moment.",
                    "The choice you make next matters.",
                    "In 47 collapses, everything changes.",
                    "They are proud of what you become.",
                    "The garden survives. That's what matters.",
                ];
                const msg = messages[Math.floor(Math.random() * messages.length)];
                setTimeout(() => UI.addLogEntry(`üì® ${msg}`, 'mysterious'), 1000);
                
                const bonus = Math.floor(Math.random() * 500) + 100;
                ResourceManager.add('energy', bonus);
                return `Future echo received: +${bonus} ‚ö° and a cryptic message...`;
            }
        },
        {
            id: 'quantumArchaeology',
            name: 'Quantum Archaeology',
            description: 'Fragments of a previous timeline surface.',
            weight: 5,
            minEnergy: 200000,
            requires: { resource: 'knowledge', amount: 100 },
            effect: () => {
                const realityLevel = PrestigeManager.getRealityLevel();
                const bonus = (realityLevel + 1) * 50;
                ResourceManager.add('knowledge', bonus);
                ResourceManager.add('timeCrystals', Math.floor(bonus / 5));
                
                const artifacts = [
                    "a fossilized probability wave",
                    "crystallized observation particles",
                    "a map of gardens that never were",
                    "memories belonging to someone else",
                    "equations written in colors that don't exist",
                ];
                const artifact = artifacts[Math.floor(Math.random() * artifacts.length)];
                return `Discovered ${artifact}: +${bonus} üìö, +${Math.floor(bonus/5)} ‚è≥`;
            }
        },
        {
            id: 'vacuumDecay',
            name: 'False Vacuum Fluctuation',
            description: 'The universe hiccups. Everything wavers.',
            weight: 3,
            minEnergy: 500000,
            effect: () => {
                // Apply glitch effect
                if (typeof NarrativeSystem !== 'undefined') {
                    NarrativeSystem.triggerGlitch(2000);
                }
                
                // Random gain or loss
                if (Math.random() < 0.7) {
                    const bonus = Math.floor(ResourceManager.get('energy') * 0.15);
                    ResourceManager.add('energy', bonus);
                    return `Reality stabilizes favorably: +${Utils.formatNumber(bonus)} ‚ö°`;
                } else {
                    const coherence = ResourceManager.get('coherence');
                    ResourceManager.set('coherence', Math.max(50, coherence));
                    return `Reality stabilizes. Coherence restored to safe levels.`;
                }
            }
        },
        {
            id: 'feynmanVisit',
            name: "Feynman's Ghost",
            description: 'The spirit of curiosity visits your garden.',
            weight: 2,
            minEnergy: 1000000,
            effect: () => {
                const quotes = [
                    "Nature uses only the longest threads to weave her patterns.",
                    "What I cannot create, I do not understand.",
                    "The first principle is that you must not fool yourself.",
                    "I learned very early the difference between knowing the name of something and knowing something.",
                ];
                const quote = quotes[Math.floor(Math.random() * quotes.length)];
                setTimeout(() => UI.addLogEntry(`üí≠ "${quote}" - R.P. Feynman`, 'mysterious'), 1500);
                
                ResourceManager.add('knowledge', 200);
                return `A legendary physicist approves: +200 üìö`;
            }
        }
    ];
    
    // Observer Effect: Track what plot the mouse is over
    function setObservedPlot(index) {
        if (observedPlotIndex !== index) {
            observedPlotIndex = index;
            observationTime = 0;
        }
    }
    
    function clearObservedPlot() {
        observedPlotIndex = null;
        observationTime = 0;
        observerFloatTimer = 0;
    }
    
    // Update quantum mechanics each tick
    function update(deltaTime) {
        // Update observation time
        if (observedPlotIndex !== null) {
            observationTime += deltaTime;
            observerFloatTimer += deltaTime;
            
            // Observer effect: Watched plants grow faster
            const plot = StateManager.get(`garden.plots.${observedPlotIndex}`);
            if (plot && plot.plant && plot.progress < 1) {
                // Bonus growth from observation (up to 50% faster, or 75% with Keen Observer)
                const baseObserverBonus = Math.min(0.5, observationTime * 0.1);
                const keenMultiplier = UpgradeManager.isPurchased('keenObserver') ? 1.5 : 1;
                const observerBonus = baseObserverBonus * keenMultiplier;
                
                const data = GameData.generators[plot.plant];
                const growthMult = UpgradeManager.getGrowthMultiplier();
                const bonusGrowth = (1 / data.growthTime) * growthMult * observerBonus * deltaTime;
                
                const newProgress = Math.min(1, plot.progress + bonusGrowth);
                StateManager.set(`garden.plots.${observedPlotIndex}.progress`, newProgress);
                
                // Show floating speed boost text every 0.8 seconds when observer effect is active
                if (observerFloatTimer >= 0.8 && observerBonus > 0.05) {
                    observerFloatTimer = 0;
                    const speedBoost = Math.round(observerBonus * 100);
                    showObserverFloat(observedPlotIndex, `+${speedBoost}%`);
                    
                    // Also boost entangled partner!
                    if (plot.entangledWith !== null) {
                        const partner = StateManager.get(`garden.plots.${plot.entangledWith}`);
                        if (partner && partner.plant && partner.progress < 1) {
                            const partnerData = GameData.generators[partner.plant];
                            const partnerBonusGrowth = (1 / partnerData.growthTime) * growthMult * observerBonus * 0.5 * deltaTime;
                            const partnerNewProgress = Math.min(1, partner.progress + partnerBonusGrowth);
                            StateManager.set(`garden.plots.${plot.entangledWith}.progress`, partnerNewProgress);
                            
                            // Show reduced boost on entangled partner
                            const partnerBoost = Math.round(observerBonus * 50);
                            showObserverFloat(plot.entangledWith, `+${partnerBoost}%`, true);
                        }
                    }
                }
            }
        }
        
        // Check for random quantum events
        checkForRandomEvent(deltaTime);
        
        // Check for narrative messages
        checkNarrativeMessages();
        
        // Coherence decay (if unlocked)
        if (ResourceManager.isUnlocked('coherence')) {
            updateCoherence(deltaTime);
        }
    }
    
    function showObserverFloat(plotIndex, text, isEntangled = false) {
        const plotEl = document.querySelector(`.garden-plot[data-index="${plotIndex}"]`);
        if (!plotEl) return;
        
        const floater = document.createElement('div');
        floater.className = 'observer-float' + (isEntangled ? ' entangled-boost' : '');
        floater.textContent = text;
        
        // Random position within the plot
        floater.style.left = (20 + Math.random() * 40) + '%';
        floater.style.top = (30 + Math.random() * 20) + '%';
        
        plotEl.appendChild(floater);
        
        // Remove after animation
        setTimeout(() => floater.remove(), 1000);
    }
    
    function checkForRandomEvent(deltaTime) {
        lastEventTime += deltaTime;
        
        // Quantum events require coherence to occur!
        const coherence = ResourceManager.get('coherence') || 0;
        if (coherence < 20) {
            // No quantum events when coherence is too low
            return;
        }
        
        // Event chance scales with coherence (higher coherence = more events)
        const coherenceBonus = coherence / 100;
        const eventChance = deltaTime * 0.02 * coherenceBonus; // ~2% per second at 100% coherence
        
        if (lastEventTime > 30 && Math.random() < eventChance) {
            triggerRandomEvent();
            lastEventTime = 0;
        }
    }
    
    function triggerRandomEvent() {
        const energy = ResourceManager.get('energy');
        
        // Filter eligible events
        const eligible = quantumEvents.filter(e => {
            if (energy < e.minEnergy) return false;
            if (e.requires) {
                if (e.requires.resource && e.requires.amount) {
                    if (ResourceManager.get(e.requires.resource) < e.requires.amount) return false;
                }
                if (e.requires.unlocked && !ResourceManager.isUnlocked(e.requires.resource)) return false;
            }
            return true;
        });
        
        if (eligible.length === 0) return;
        
        // Weighted random selection
        const totalWeight = eligible.reduce((sum, e) => sum + e.weight, 0);
        let roll = Math.random() * totalWeight;
        
        let selected = null;
        for (const event of eligible) {
            roll -= event.weight;
            if (roll <= 0) {
                selected = event;
                break;
            }
        }
        
        if (selected) {
            showQuantumEvent(selected);
        }
    }
    
    function showQuantumEvent(event) {
        const resultMessage = event.effect();
        
        // Track in stats
        const witnessed = StateManager.get('stats.quantumEventsWitnessed') || 0;
        StateManager.set('stats.quantumEventsWitnessed', witnessed + 1);
        
        // Create event popup - append to resources section instead of center screen
        const popup = document.createElement('div');
        popup.className = 'quantum-event';
        popup.innerHTML = `
            <h3>‚öõÔ∏è ${event.name}</h3>
            <p>${event.description}</p>
            <p style="color: var(--quantum-green); font-weight: bold; font-size: 0.8rem;">${resultMessage}</p>
            <button onclick="this.parentElement.remove()">OK</button>
        `;
        
        // Append to quantum events container (separate from resources so it doesn't get wiped)
        const eventsContainer = document.getElementById('quantum-events-container');
        if (eventsContainer) {
            eventsContainer.appendChild(popup);
        } else {
            document.body.appendChild(popup);
        }
        
        // Auto-remove after 4 seconds
        setTimeout(() => {
            if (popup.parentElement) {
                popup.style.opacity = '0';
                popup.style.transform = 'scale(0.9)';
                popup.style.transition = 'opacity 0.3s, transform 0.3s';
                setTimeout(() => popup.remove(), 300);
            }
        }, 4000);
        
        events.emit('quantumEvent', event);
    }
    
    function checkNarrativeMessages() {
        const totalEnergy = StateManager.get('resources.energy.total') || 0;
        const shownMessages = StateManager.get('shownNarrativeMessages') || [];
        
        for (const msg of narrativeMessages) {
            // Check if already shown (either in memory or in saved state)
            const alreadyShown = msg.shown || shownMessages.includes(msg.threshold);
            
            if (!alreadyShown && totalEnergy >= msg.threshold) {
                msg.shown = true;
                
                // Save to persistent state
                shownMessages.push(msg.threshold);
                StateManager.set('shownNarrativeMessages', shownMessages);
                
                // Delay slightly for dramatic effect
                setTimeout(() => {
                    UI.addLogEntry(msg.message, 'mysterious');
                }, Math.random() * 3000 + 1000);
            } else if (alreadyShown) {
                // Mark as shown in memory too
                msg.shown = true;
            }
        }
    }
    
    function updateCoherence(deltaTime) {
        // Coherence slowly decays as you play
        const generators = Object.keys(GameData.generators).reduce((sum, id) => {
            return sum + GeneratorManager.getOwned(id);
        }, 0);
        
        // More generators = faster decay (more classical the system becomes)
        let decayRate = 0.01 + (generators * 0.002);
        
        // Apply coherence stabilizer if purchased
        if (UpgradeManager.isPurchased('coherenceStabilizer')) {
            decayRate *= 0.5;
        }
        
        const current = ResourceManager.get('coherence');
        let graceTimer = StateManager.get('coherenceGraceTimer') || 0;
        const wasAtMax = StateManager.get('coherenceWasAtMax') || false;
        
        // Track if we just hit 100% (transition detection)
        if (current >= 100 && !wasAtMax) {
            // Just transitioned to 100% - start grace period
            StateManager.set('coherenceGraceTimer', 0.45); // 450ms grace
            StateManager.set('coherenceWasAtMax', true);
            return;
        }
        
        if (current >= 100) {
            // Still at 100% during grace period
            if (graceTimer > 0) {
                graceTimer -= deltaTime;
                StateManager.set('coherenceGraceTimer', graceTimer);
                return; // Still in grace, no decay
            }
            // Grace expired, allow decay to start
        }
        
        // No longer at max
        if (current < 100) {
            StateManager.set('coherenceWasAtMax', false);
        }
        
        if (current > 0) {
            // Gentle easing near 100% for smoother visual transition
            let easedDecay = decayRate;
            if (current > 99) {
                // 99-100: 30% decay speed
                easedDecay = decayRate * 0.3;
            } else if (current > 98) {
                // 98-99: ramp from 30% to 100%
                const t = (99 - current); // 0 at 99, 1 at 98
                easedDecay = decayRate * (0.3 + t * 0.7);
            }
            
            const newCoherence = Math.max(0, current - easedDecay * deltaTime);
            StateManager.set('resources.coherence.amount', newCoherence);
            
            // Warn at 50% - production starting to drop
            if (current > 50 && newCoherence <= 50) {
                UI.addLogEntry('‚ö†Ô∏è Coherence at 50%: Generator production reduced to 80%', 'warning');
            }
            
            // Warn at 25% - production significantly impacted
            if (current > 25 && newCoherence <= 25) {
                UI.addLogEntry('‚ö†Ô∏è Coherence critical! Production at 70%. Click to restore!', 'warning');
            }
            
            // Warn at 20% - quantum events stop
            if (current > 20 && newCoherence <= 20) {
                UI.addLogEntry('üåÄ Quantum events suspended - coherence too low!', 'warning');
            }
            
            // Warn at 10% - entanglement unstable
            if (current > 10 && newCoherence <= 10) {
                UI.addLogEntry('‚õìÔ∏è Entanglement unstable! Links may break!', 'warning');
            }
            
            if (current > 0 && newCoherence <= 0) {
                UI.addLogEntry('üåÄ Coherence depleted! Production at minimum (30%).', 'warning');
                events.emit('coherenceDepleted');
            }
        }
    }
    
    // Calculate superposition yield variance for a plant
    function getSuperpositionYield(generatorId) {
        const data = GameData.generators[generatorId];
        const baseYield = data.harvestYield;
        const coherence = ResourceManager.get('coherence') || 0;
        
        // Higher coherence = more variance (quantum effects)
        // Lower coherence = more predictable (classical)
        const varianceFactor = coherence / 100;
        
        const possibleYields = [];
        
        // Generate 3 possible outcomes
        for (let i = 0; i < 3; i++) {
            const possibleYield = {};
            for (const [resource, amount] of Object.entries(baseYield)) {
                const variance = amount * varianceFactor * 0.5;
                const min = Math.max(1, Math.floor(amount - variance));
                const max = Math.ceil(amount + variance * 2); // Slight positive bias
                possibleYield[resource] = { min, max, expected: amount };
            }
            possibleYields.push(possibleYield);
        }
        
        return possibleYields;
    }
    
    // Collapse superposition and get actual yield
    function collapseYield(generatorId) {
        const data = GameData.generators[generatorId];
        const baseYield = data.harvestYield;
        const coherence = ResourceManager.get('coherence') || 0;
        let varianceFactor = coherence / 100;
        
        // Superposition Mastery increases variance but improves average
        const hasMastery = UpgradeManager.isPurchased('superpositionMastery');
        if (hasMastery) {
            varianceFactor += 0.25;
        }
        
        const actualYield = {};
        
        for (const [resource, amount] of Object.entries(baseYield)) {
            const variance = amount * varianceFactor * 0.5;
            const min = Math.max(1, Math.floor(amount - variance));
            let max = Math.ceil(amount + variance * 2);
            
            // Superposition Mastery also increases max yield
            if (hasMastery) {
                max = Math.ceil(max * 1.2);
            }
            
            // Random within range, weighted toward expected (slightly better with mastery)
            const roll = Math.random();
            const range = max - min;
            const power = hasMastery ? 0.7 : 0.8; // Lower power = more likely to roll high
            actualYield[resource] = Math.floor(min + range * Math.pow(roll, power));
        }
        
        return actualYield;
    }
    
    // Force a quantum event (for testing/special occasions)
    function forceEvent(eventId) {
        const event = quantumEvents.find(e => e.id === eventId);
        if (event) {
            showQuantumEvent(event);
        }
    }
    
    return {
        update,
        setObservedPlot,
        clearObservedPlot,
        getSuperpositionYield,
        collapseYield,
        forceEvent,
        on: events.on
    };
})();

// ============================================
// MODULE: Achievement Manager
// ============================================
const AchievementManager = (() => {
    const events = Utils.createEventEmitter();
    let checkTimer = 0;
    
    function isUnlocked(achievementId) {
        return StateManager.get(`achievements.${achievementId}`) === true;
    }
    
    function unlock(achievementId) {
        if (isUnlocked(achievementId)) return false;
        
        StateManager.set(`achievements.${achievementId}`, true);
        
        const data = GameData.achievements[achievementId];
        if (data) {
            events.emit('unlocked', data);
            
            // Show notification
            UI.showNotification(
                `üèÜ Achievement Unlocked!`,
                `${data.icon} ${data.name}: ${data.description}`,
                'success'
            );
            
            UI.addLogEntry(`üèÜ Achievement: ${data.name}`, 'highlight');
            
            // Re-render stats tab if it's visible
            UI.renderStats();
        }
        
        return true;
    }
    
    function checkAll() {
        Object.entries(GameData.achievements).forEach(([id, data]) => {
            if (!isUnlocked(id) && data.check()) {
                unlock(id);
            }
        });
    }
    
    function update(deltaTime) {
        // Check achievements every second
        checkTimer += deltaTime;
        if (checkTimer >= 1) {
            checkAll();
            checkTimer = 0;
        }
    }
    
    function getUnlockedCount() {
        return Object.keys(GameData.achievements).filter(id => isUnlocked(id)).length;
    }
    
    function getTotalCount() {
        return Object.keys(GameData.achievements).length;
    }
    
    function getAll() {
        return Object.entries(GameData.achievements).map(([id, data]) => ({
            ...data,
            unlocked: isUnlocked(id)
        }));
    }
    
    return {
        isUnlocked,
        unlock,
        checkAll,
        update,
        getUnlockedCount,
        getTotalCount,
        getAll,
        on: events.on
    };
})();

// ============================================
// MODULE: Prestige System - Reality Collapse
// ============================================
const PrestigeManager = (() => {
    const FRAGMENT_BASE = 1000000; // 1M energy = 1 fragment base
    
    function isUnlocked() {
        // Prestige UI is unlocked if:
        // 1. Player has bought realityAwareness upgrade
        // 2. OR player has fragments (has collapsed before)
        // 3. OR player has reality level > 0 (has collapsed before)
        // 4. OR player has 500k+ total energy (show progress toward 1M)
        const totalEnergy = StateManager.get('resources.energy.total') || 0;
        return UpgradeManager.isPurchased('realityAwareness') ||
               (ResourceManager.get('fragments') || 0) > 0 ||
               (StateManager.get('stats.realityLevel') || 0) > 0 ||
               totalEnergy >= 500000;
    }
    
    function getFragmentsOnCollapse() {
        // Need realityAwareness purchased to actually collapse
        if (!UpgradeManager.isPurchased('realityAwareness')) return 0;
        
        const totalEnergy = StateManager.get('resources.energy.total') || 0;
        // Logarithmic scaling: more energy = more fragments, but diminishing
        // 1M = 1, 10M = ~3, 100M = ~7, 1B = ~10
        if (totalEnergy < FRAGMENT_BASE) return 0;
        
        const baseFragments = Math.floor(Math.log10(totalEnergy / FRAGMENT_BASE) * 3) + 1;
        
        // Bonus for first collapse per reality level
        const realityLevel = StateManager.get('stats.realityLevel') || 0;
        const newPlayerBonus = realityLevel === 0 ? 2 : 0;
        
        return baseFragments + newPlayerBonus;
    }
    
    function canCollapse() {
        return isUnlocked() && getFragmentsOnCollapse() > 0;
    }
    
    function collapse() {
        if (!canCollapse()) return false;
        
        const fragmentsGained = getFragmentsOnCollapse();
        const currentFragments = ResourceManager.get('fragments') || 0;
        
        // Save persistent upgrades
        const persistentUpgrades = [];
        Object.entries(GameData.upgrades).forEach(([id, data]) => {
            if (data.persistent && UpgradeManager.isPurchased(id)) {
                persistentUpgrades.push(id);
            }
        });
        
        // Calculate retained resources from persistent upgrades
        let retainedTime = 0;
        if (UpgradeManager.isPurchased('fragmentBoost3')) {
            retainedTime = Math.floor(ResourceManager.get('time') * 0.1);
        }
        
        // Save stats that persist
        const currentLevel = StateManager.get('stats.realityLevel') || 0;
        const totalCollapses = StateManager.get('stats.totalCollapses') || 0;
        const achievements = StateManager.get('achievements');
        const playTime = StateManager.get('stats.playTime');
        const lastCollapsePlayTime = StateManager.get('stats.lastCollapsePlayTime') || 0;
        
        // Check if this is a fast collapse (within 30 minutes of the last collapse)
        const timeSinceLastCollapse = playTime - lastCollapsePlayTime;
        const isFastCollapse = totalCollapses > 0 && timeSinceLastCollapse < 1800; // 30 minutes
        
        // Grant fragments BEFORE reset
        const newFragmentTotal = currentFragments + fragmentsGained;
        
        // Perform the collapse!
        window.quantumGardenResetting = true;
        
        // Reset state but keep certain things
        const newState = Utils.deepClone(GameData.initialState);
        
        // Restore persistent data
        newState.resources.fragments = { amount: newFragmentTotal, total: newFragmentTotal, rate: 0 };
        newState.stats.realityLevel = currentLevel + 1;
        newState.stats.totalCollapses = totalCollapses + 1;
        newState.stats.playTime = playTime;
        newState.stats.lastCollapsePlayTime = playTime; // Track when this collapse happened
        newState.stats.fastCollapse = isFastCollapse || StateManager.get('stats.fastCollapse'); // Keep if achieved
        newState.achievements = achievements;
        
        // Restore persistent upgrades
        persistentUpgrades.forEach(id => {
            newState.upgrades[id] = { purchased: true };
        });
        
        // Apply starting bonuses from persistent upgrades
        if (persistentUpgrades.includes('fragmentBoost2')) {
            newState.resources.energy.amount = 100;
            newState.resources.seeds.amount = 10;
            newState.resources.seeds.unlocked = true;
        }
        
        if (retainedTime > 0) {
            newState.resources.time.amount = retainedTime;
            newState.resources.time.unlocked = retainedTime > 0;
        }
        
        // Initialize generators and other upgrades
        Object.keys(GameData.generators).forEach(id => {
            newState.generators[id] = { owned: 0 };
        });
        Object.keys(GameData.upgrades).forEach(id => {
            if (!newState.upgrades[id]) {
                newState.upgrades[id] = { purchased: false };
            }
        });
        Object.keys(GameData.achievements).forEach(id => {
            if (!newState.achievements[id]) {
                newState.achievements[id] = false;
            }
        });
        
        // Initialize garden
        for (let i = 0; i < newState.garden.size; i++) {
            newState.garden.plots.push({ plant: null, progress: 0, plantedAt: null });
        }
        
        // Apply the new state
        StateManager.setState(newState);
        StateManager.save();
        
        window.quantumGardenResetting = false;
        
        // Refresh UI
        UI.renderAll();
        
        // Log the collapse
        UI.addLogEntry(`üí† Reality Collapsed! Gained ${fragmentsGained} Reality Fragments.`, 'highlight');
        UI.addLogEntry(`üîÆ Welcome to Reality Level ${currentLevel + 1}`, 'highlight');
        
        return true;
    }
    
    function getProductionMultiplier() {
        // Each fragment gives bonus production if fragmentBoost1 is purchased
        if (!UpgradeManager.isPurchased('fragmentBoost1')) return 1;
        
        const fragments = ResourceManager.get('fragments') || 0;
        return 1 + (fragments * 0.05); // 5% per fragment
    }
    
    function getRealityLevel() {
        return StateManager.get('stats.realityLevel') || 0;
    }
    
    return {
        isUnlocked,
        getFragmentsOnCollapse,
        canCollapse,
        collapse,
        getProductionMultiplier,
        getRealityLevel
    };
})();

// ============================================
// MODULE: Narrative System - Story & Atmosphere
// ============================================
const NarrativeSystem = (() => {
    let tickerInitialized = false;
    let glitchInterval = null;
    let lastGlitchCheck = 0;
    
    // Ticker messages that scroll across the top
    const tickerMessages = [
        // Early game - mysterious hints
        "...quantum fluctuations detected in local spacetime...",
        "The probability wave function collapses with each observation.",
        "Somewhere, a garden grows in superposition.",
        "Feynman once said: 'If you think you understand quantum mechanics, you don't understand quantum mechanics.'",
        "All possible paths are taken. All possible gardens bloom.",
        "The observer effect: your attention shapes reality.",
        "In the quantum realm, nothing is certain until measured.",
        "Schr√∂dinger's flowers: alive and dead until you look.",
        "Every measurement is an act of creation.",
        "The universe is under no obligation to make sense to you. - Neil deGrasse Tyson",
        
        // Mid game - deeper mysteries
        "Between observations, the garden exists in all states simultaneously.",
        "Warning: Coherence decay approaching critical threshold.",
        "QED: Quantum Electrodynamic fluctuations are nominal.",
        "The vacuum is not empty. It seethes with virtual particles.",
        "Heisenberg's uncertainty: position or momentum, never both.",
        "Entanglement persists regardless of distance. Spooky action at a distance.",
        "The many-worlds interpretation suggests this garden exists infinitely.",
        "Planck length: 1.616 √ó 10e‚Åª¬≥‚Åµ meters. Below this, space itself becomes uncertain.",
        "Quantum tunneling allows particles to pass through impossible barriers.",
        "The double-slit experiment forever changed our understanding of reality.",
        
        // Late game - ominous
        "R√å¬∂e√å¬∂a√å¬∂l√å¬∂i√å¬∂t√å¬∂y√å¬∂ √å¬∂i√å¬∂n√å¬∂t√å¬∂e√å¬∂g√å¬∂r√å¬∂i√å¬∂t√å¬∂y√å¬∂:√å¬∂ √å¬∂D√å¬∂E√å¬∂G√å¬∂R√å¬∂A√å¬∂D√å¬∂I√å¬∂N√å¬∂G√å¬∂",
        "Other observers have been detected in adjacent probability spaces.",
        "The boundary between observer and observed is dissolving.",
        "Your wave function is entangling with the garden's.",
        "Quantum chromodynamics: colors you cannot see bind reality together.",
        "The Dirac sea churns beneath observable reality.",
        "Vacuum energy density: unstable.",
        "Virtual photon exchange increasing. Cause: unknown.",
        "Bell's inequality violation confirmed. Local realism: ABANDONED.",
        
        // Post-prestige - cosmic horror
        "REALITY LEVEL INCREASED - Previous timeline archived.",
        "The other gardeners are watching. They always have been.",
        "Each collapse creates echoes in the quantum foam.",
        "You have become entangled with something vast.",
        "The fragments remember every garden you've grown.",
        "Somewhere, another you chose differently.",
        "The universe observes those who observe it.",
        "Causality is a suggestion, not a law.",
        "Time is a flat circle in Hilbert space.",
        "The garden grows in dimensions you cannot perceive."
    ];
    
    // Major story beats triggered at milestones
    const storyMoments = [
        {
            threshold: 1000,
            triggered: false,
            title: "The First Bloom",
            content: [
                "The first quantum lily opens its petals.",
                "For a moment, you feel... watched.",
                "Not by eyes, but by probability itself.",
                "The garden knows it is being observed."
            ]
        },
        {
            threshold: 10000,
            triggered: false,
            title: "Whispers in the Field",
            content: [
                "The flowers have begun to whisper.",
                "Not in words‚Äîin wave functions.",
                "Each bloom carries information from adjacent timelines.",
                "You are learning to listen."
            ]
        },
        {
            threshold: 100000,
            triggered: false,
            title: "The Observer's Paradox",
            content: [
                "A troubling thought occurs to you:",
                "When you observe the garden, you collapse its possibilities.",
                "But what happens when the garden... observes you?",
                "You feel your own probability wave quiver."
            ]
        },
        {
            threshold: 1000000,
            triggered: false,
            title: "Echoes",
            content: [
                "You see them now. Faintly.",
                "Other gardens. Other gardeners.",
                "Infinite variations, all tending quantum flowers.",
                "They see you too.",
                "They have always seen you."
            ]
        },
        {
            threshold: 10000000,
            triggered: false,
            title: "The Membrane",
            content: [
                "Reality has become... thin.",
                "You can feel the membrane between worlds.",
                "It pulses with each click, each harvest.",
                "Something presses against it from the other side.",
                "Perhaps it is time to let go."
            ]
        },
        {
            threshold: 100000000,
            triggered: false,
            title: "Beyond the Collapse",
            content: [
                "You have collapsed reality before.",
                "Each time, you return. Changed.",
                "The fragments you carry are pieces of broken timelines.",
                "Or are they pieces of something that was never whole?",
                "The garden knows. The garden remembers.",
                "Do you?"
            ]
        }
    ];
    
    // Additional log messages triggered by various conditions
    const conditionalMessages = [
        { condition: () => GardenManager.getPlantsGrowing() >= 9, once: 'fullGarden', message: "The garden hums with potential energy.", type: 'mysterious' },
        { condition: () => StateManager.get('stats.plantsEntangled') >= 10, once: 'manyEntangled', message: "The entangled plants pulse in unison, sharing secrets across space.", type: 'mysterious' },
        { condition: () => StateManager.get('stats.quantumEventsWitnessed') >= 20, once: 'manyEvents', message: "The quantum realm has noticed your attention.", type: 'mysterious' },
        { condition: () => ResourceManager.get('knowledge') >= 100, once: 'muchKnowledge', message: "Knowledge accumulates. Patterns emerge. The universe reveals itself.", type: 'mysterious' },
        { condition: () => ResourceManager.get('timeCrystals') >= 50, once: 'muchTime', message: "Time crystals resonate at frequencies that shouldn't exist.", type: 'mysterious' },
        { condition: () => ResourceManager.get('coherence') <= 10, once: 'veryLowCoherence', message: "R√å¬µe√å¬∑a√å¬∏l√å¬µi√å¬∑t√å¬¥y√å¬∏ √å¬µf√å¬∑r√å¬¥a√å¬µy√å¬¥s√å¬µ √å¬∑a√å¬∑t√å¬µ √å¬µt√å¬¥h√å¬∏e√å¬∂ √å¬µe√å¬∑d√å¬µg√å¬∏e√å¬∑s√å¬∑.√å¬¥.√å¬µ.", type: 'warning' },
        { condition: () => StateManager.get('stats.totalClicks') >= 1000, once: 'manyClicks', message: "A thousand collapses. A thousand creations.", type: 'mysterious' },
        { condition: () => StateManager.get('stats.totalClicks') >= 10000, once: 'tenKClicks', message: "Ten thousand observations. The garden has become part of you.", type: 'mysterious' },
        { condition: () => PrestigeManager.getRealityLevel() >= 1, once: 'firstCollapse', message: "You remember the garden from before. Or do you remember it from after?", type: 'mysterious' },
        { condition: () => PrestigeManager.getRealityLevel() >= 3, once: 'thirdCollapse', message: "Reality buckles easier now. It knows your touch.", type: 'mysterious' },
        { condition: () => PrestigeManager.getRealityLevel() >= 5, once: 'fifthCollapse', message: "The other gardeners speak of you. The one who collapses and returns.", type: 'mysterious' },
    ];
    
    // Feynman diagrams as ASCII art (shown rarely in log)
    const feynmanDiagrams = [
        "ee‚Åª ~~~√é¬≥~~> ee‚Åª  [photon exchange]",
        "q --g--> q  [gluon emission]",
        "ee‚Å∫ + ee‚Åª ‚Üí √é¬≥ ‚Üí q + q√å‚Äû  [pair production]",
        "W√Ç¬± ‚Üí l√Ç¬± + √é¬Ω  [weak decay]",
        "H ‚Üí √é¬≥√é¬≥  [Higgs to diphoton]",
    ];
    
    function initialize() {
        if (tickerInitialized) return;
        tickerInitialized = true;
        
        // Populate ticker
        updateTicker();
        
        // Start coherence-based glitch effects
        startGlitchSystem();
        
        // Start ambient message system
        startAmbientMessages();
        
        // Check for story moments periodically
        setInterval(checkStoryMoments, 5000);
        
        // Check conditional messages
        setInterval(checkConditionalMessages, 10000);
        
        // Occasionally show Feynman diagrams in log
        setInterval(() => {
            if (Math.random() < 0.05 && ResourceManager.get('knowledge') >= 50) {
                const diagram = feynmanDiagrams[Math.floor(Math.random() * feynmanDiagrams.length)];
                UI.addLogEntry(`üìä ${diagram}`, 'mysterious');
            }
        }, 60000);
    }
    
    function updateTicker() {
        const ticker = document.getElementById('ticker-content');
        if (!ticker) return;
        
        // Select messages based on game progress
        const totalEnergy = StateManager.get('resources.energy.total') || 0;
        const realityLevel = PrestigeManager.getRealityLevel();
        
        let availableMessages = tickerMessages.slice(0, 10); // Early messages
        
        if (totalEnergy >= 5000) {
            availableMessages = tickerMessages.slice(0, 20); // Mid messages
        }
        if (totalEnergy >= 100000) {
            availableMessages = tickerMessages.slice(0, 30); // Late messages
        }
        if (realityLevel >= 1) {
            availableMessages = tickerMessages; // All messages
        }
        
        // Shuffle and join
        const shuffled = availableMessages.sort(() => Math.random() - 0.5).slice(0, 8);
        const separator = "   ‚ÄîÀÜ   ";
        ticker.textContent = shuffled.join(separator) + separator;
        
        // Refresh ticker content periodically
        setTimeout(updateTicker, 120000); // Every 2 minutes
    }
    
    function startGlitchSystem() {
        // Check coherence and apply visual effects
        glitchInterval = setInterval(() => {
            const coherence = ResourceManager.get('coherence');
            const overlay = document.getElementById('reality-fracture-overlay');
            
            // Reality fracture overlay for very low coherence
            if (coherence <= 15) {
                overlay?.classList.add('active');
            } else {
                overlay?.classList.remove('active');
            }
            
            // Apply text glitch to random elements when coherence is low
            if (coherence <= 40 && Date.now() - lastGlitchCheck > 2000) {
                lastGlitchCheck = Date.now();
                applyRandomGlitch(coherence);
            }
        }, 500);
    }
    
    function applyRandomGlitch(coherence) {
        // Find text elements to potentially glitch
        const glitchTargets = [
            ...document.querySelectorAll('.resource-value'),
            ...document.querySelectorAll('.generator-name'),
            ...document.querySelectorAll('.upgrade-name'),
            ...document.querySelectorAll('.log-entry')
        ];
        
        if (glitchTargets.length === 0) return;
        
        // Randomly select 1-3 elements to glitch
        const numGlitches = coherence <= 20 ? 3 : (coherence <= 30 ? 2 : 1);
        
        for (let i = 0; i < numGlitches; i++) {
            const target = glitchTargets[Math.floor(Math.random() * glitchTargets.length)];
            if (!target || target.classList.contains('glitch-text')) continue;
            
            // Apply glitch class
            const severity = coherence <= 20 ? 'glitch-severe' : 'glitch-text';
            target.classList.add(severity);
            
            // Remove after brief period
            setTimeout(() => {
                target.classList.remove('glitch-text', 'glitch-severe');
            }, coherence <= 20 ? 800 : 400);
        }
        
        // Occasionally corrupt text content briefly
        if (coherence <= 25 && Math.random() < 0.3) {
            const target = glitchTargets[Math.floor(Math.random() * glitchTargets.length)];
            if (target) {
                const original = target.textContent;
                target.textContent = corruptText(original);
                setTimeout(() => {
                    target.textContent = original;
                }, 150);
            }
        }
    }
    
    function corruptText(text) {
        const glitchChars = '√å¬∑√å¬∏√å¬¥√å¬µ√å¬∂√å¬°√å¬¢√å¬ß√å¬®√å‚Ä∫√å‚Äì√å‚Äî√åÀú√å‚Ñ¢√å≈ì√å¬ù√å≈æ√å≈∏√å¬†√å¬£√å¬§√å¬•√å¬¶√å¬©√å¬™√å¬´√å¬¨√å¬≠√å¬Æ√å¬Ø√å¬∞√å¬±√å¬≤√å¬≥√å¬π√å¬∫√å¬ª√å¬º√ç‚Ä°√çÀÜ√ç‚Ä∞√ç¬ç√ç≈Ω√å‚Ç¨√å¬Å√å‚Äö√å∆í√å‚Äû√å‚Ä¶√å‚Ä†√å‚Ä°√åÀÜ√å‚Ä∞√å≈†√å‚Äπ√å≈í√å¬ç√å≈Ω√å¬è√å¬ê√å‚Äò√å‚Äô√å‚Äú√å‚Äù√å¬Ω√å¬æ√å¬ø√å‚Ç¨√å¬Å√ç‚Äö√å‚Äú√åÀÜ√å¬Å√ç‚Ä†√ç≈†√ç‚Äπ√ç≈í√å‚Ä¢√å≈°√ç‚Ä¶√ç¬è√ç‚Äú√ç‚Äù√ç‚Ä¢√ç‚Äì√ç‚Ñ¢√ç≈°√ç¬ê√ç‚Äò√ç‚Äô√ç‚Äî√ç‚Ä∫√ç¬£√ç¬§√ç¬•√ç¬¶√ç¬ß√ç¬®√ç¬©√ç¬™√ç¬´√ç¬¨√ç¬≠√ç¬Æ√ç¬Ø√çÀú√ç≈ì√ç≈∏√ç¬¢√ç¬ù√ç≈æ√ç¬†√ç¬°';
        let result = '';
        for (let char of text) {
            result += char;
            if (Math.random() < 0.15) {
                result += glitchChars[Math.floor(Math.random() * glitchChars.length)];
            }
        }
        return result;
    }
    
    function checkStoryMoments() {
        const totalEnergy = StateManager.get('resources.energy.total') || 0;
        const triggeredStories = StateManager.get('triggeredStories') || [];
        
        for (const moment of storyMoments) {
            if (totalEnergy >= moment.threshold && !triggeredStories.includes(moment.threshold)) {
                // Mark as triggered
                triggeredStories.push(moment.threshold);
                StateManager.set('triggeredStories', triggeredStories);
                
                // Show story modal after a delay
                setTimeout(() => showStoryModal(moment), 2000);
                break; // Only one at a time
            }
        }
    }
    
    function showStoryModal(moment) {
        const modal = document.getElementById('story-modal');
        const content = document.getElementById('story-content');
        if (!modal || !content) return;
        
        let html = `<h2>${moment.title}</h2>`;
        moment.content.forEach(line => {
            html += `<p>${line}</p>`;
        });
        html += `<button onclick="document.getElementById('story-modal').classList.remove('active')">Continue</button>`;
        
        content.innerHTML = html;
        modal.classList.add('active');
        
        UI.addLogEntry(`üìñ ${moment.title}`, 'mysterious');
    }
    
    function checkConditionalMessages() {
        const shownConditional = StateManager.get('shownConditionalMessages') || [];
        
        for (const msg of conditionalMessages) {
            if (msg.once && shownConditional.includes(msg.once)) continue;
            
            try {
                if (msg.condition()) {
                    if (msg.once) {
                        shownConditional.push(msg.once);
                        StateManager.set('shownConditionalMessages', shownConditional);
                    }
                    
                    setTimeout(() => {
                        UI.addLogEntry(msg.message, msg.type || 'mysterious');
                    }, Math.random() * 3000);
                }
            } catch (e) {
                // Condition not ready yet
            }
        }
    }
    
    // Ambient messages that appear randomly during gameplay
    const ambientMessages = [
        // Short observations
        "...",
        "The air tastes of probability.",
        "A flower blooms somewhere you can't see.",
        "The quantum field hums.",
        "Static. Just for a moment.",
        "Did something move?",
        "The numbers feel... aware.",
        "A chill. Then nothing.",
        "The screen flickers. Did you notice?",
        "Someone else is clicking, somewhere.",
        "The garden breathes.",
        "Time skipped. Or did it?",
        "An echo of something that hasn't happened yet.",
        "The math is beautiful today.",
        "You're being remembered.",
        "Patterns emerge. Patterns dissolve.",
        "The void between clicks is infinite.",
        "Each harvest is a small death. And a small birth.",
        "The flowers dream in wave functions.",
        "Are you growing the garden, or is it growing you?",
    ];
    
    // Longer, rarer messages
    const rareAmbientMessages = [
        "In a garden exactly like this one, another you made a different choice. Both gardens thrive.",
        "The coherence fluctuations form patterns. If you squint, they almost look like text.",
        "Somewhere, a physicist proves that observation creates reality. They don't know about you yet.",
        "The probability of you being here, doing this, approaches zero. Yet here you are.",
        "Every particle in your body was once inside a star. Every star was once quantum fluctuations.",
        "Feynman diagrams trace the paths your flowers never took.",
        "The Standard Model accounts for everything except your garden. And consciousness. And dark matter.",
        "In information theory, entropy is just another word for possibility. Your garden is very entropic.",
        "Bell's inequality proves nonlocality. Your entangled flowers already knew this.",
        "The cosmological horizon recedes at the speed of light. Your garden doesn't care.",
    ];
    
    let lastAmbientMessage = 0;
    
    function checkAmbientMessages() {
        const now = Date.now();
        const minInterval = 45000; // Minimum 45 seconds between ambient messages
        
        if (now - lastAmbientMessage < minInterval) return;
        
        // Small chance of ambient message
        if (Math.random() > 0.03) return; // 3% chance per check
        
        lastAmbientMessage = now;
        
        // Rare messages are 10% of ambient messages
        const messagePool = Math.random() < 0.1 ? rareAmbientMessages : ambientMessages;
        const message = messagePool[Math.floor(Math.random() * messagePool.length)];
        
        UI.addLogEntry(message, 'mysterious');
    }
    
    // Start ambient message checks
    function startAmbientMessages() {
        setInterval(checkAmbientMessages, 5000); // Check every 5 seconds
    }
    
    // Public methods
    function addTickerMessage(message) {
        tickerMessages.push(message);
    }
    
    function triggerGlitch(duration = 1000) {
        const elements = document.querySelectorAll('.resource-value, h1, .generator-name');
        elements.forEach(el => el.classList.add('glitch-severe'));
        setTimeout(() => {
            elements.forEach(el => el.classList.remove('glitch-severe'));
        }, duration);
    }
    
    return {
        initialize,
        updateTicker,
        triggerGlitch,
        addTickerMessage,
        showStoryModal
    };
})();

// ============================================
// MODULE: Tips Manager - Context-Sensitive Guidance
// ============================================
const TipsManager = (() => {
    const shownTips = new Set();
    let tipCooldown = 0;
    const TIP_COOLDOWN = 30; // seconds between tips
    
    const tips = {
        // Early game tips
        firstEnergy: {
            condition: () => ResourceManager.get('energy') >= 10 && ResourceManager.get('energy') < 30,
            message: 'üí° Keep clicking! At 30 energy you can buy Seed Synthesis.',
            priority: 10,
            once: true
        },
        buySeedProduction: {
            condition: () => ResourceManager.get('energy') >= 30 && !UpgradeManager.isPurchased('seedProduction'),
            message: 'üí° You have enough energy! Check the Upgrades tab for Seed Synthesis.',
            priority: 9,
            once: true
        },
        gotSeeds: {
            condition: () => ResourceManager.get('seeds') > 0 && StateManager.get('stats.totalPlantsHarvested') === 0,
            message: 'üí° You have seeds! Click an empty plot (+) in the garden to plant.',
            priority: 8,
            once: true
        },
        firstPlant: {
            condition: () => {
                const plots = StateManager.get('garden.plots') || [];
                return plots.some(p => p.plant) && StateManager.get('stats.totalPlantsHarvested') === 0;
            },
            message: 'üí° Great! Watch your plant grow. Hover over it to speed up growth!',
            priority: 7,
            once: true
        },
        firstHarvestReady: {
            condition: () => {
                const plots = StateManager.get('garden.plots') || [];
                return plots.some(p => p.growth >= 100 && p.plant !== null);
            },
            message: 'üí° Your plant is ready! Click it to harvest for resources and more seeds.',
            priority: 6,
            once: true
        },
        
        // Mid-game tips
        buyFirstGenerator: {
            condition: () => ResourceManager.get('energy') >= 15 && GeneratorManager.getOwned('quantumLily') === 0,
            message: 'üí° You can buy a Quantum Lily in the Plants tab for passive energy!',
            priority: 5,
            once: true
        },
        coherenceIntro: {
            condition: () => {
                const generators = Object.keys(GameData.generators).reduce((sum, id) => 
                    sum + GeneratorManager.getOwned(id), 0);
                return generators >= 3 && !shownTips.has('coherenceIntro');
            },
            message: 'üí° Notice the Coherence bar? Clicking maintains it. Low coherence = lower production.',
            priority: 4,
            once: true
        },
        entanglementIntro: {
            condition: () => UpgradeManager.isPurchased('entanglementBasics') && StateManager.get('stats.plantsEntangled') === 0,
            message: 'üí° Try the Entangle button! Link two plants for bonus yields.',
            priority: 4,
            once: true
        },
        
        // Recurring tips
        lowCoherence: {
            condition: () => ResourceManager.get('coherence') < 20,
            message: '‚ö†Ô∏è Low coherence! Click the Quantum Core to restore it.',
            priority: 3,
            once: false
        },
        unlockAvailable: {
            condition: () => {
                return Object.entries(GameData.upgrades).some(([id, data]) => {
                    return UpgradeManager.isUnlocked(id) && !UpgradeManager.isPurchased(id) && UpgradeManager.canBuy(id);
                });
            },
            message: '‚ú® An upgrade is available! Check the Upgrades tab.',
            priority: 2,
            once: false
        }
    };
    
    function update(deltaTime) {
        if (tipCooldown > 0) {
            tipCooldown -= deltaTime;
            return;
        }
        
        // Find highest priority tip that should be shown
        let bestTip = null;
        let bestPriority = -1;
        
        for (const [id, tip] of Object.entries(tips)) {
            if (tip.once && shownTips.has(id)) continue;
            if (!tip.condition()) continue;
            
            if (tip.priority > bestPriority) {
                bestPriority = tip.priority;
                bestTip = { id, ...tip };
            }
        }
        
        if (bestTip) {
            UI.addLogEntry(bestTip.message, 'tip');
            shownTips.add(bestTip.id);
            tipCooldown = TIP_COOLDOWN;
        }
    }
    
    function reset() {
        shownTips.clear();
        tipCooldown = 0;
    }
    
    return { update, reset };
})();

// ============================================
// MODULE: UI Renderer
// ============================================
const UI = (() => {
    let selectedPlotIndex = null;
    
    function initialize() {
        setupEventListeners();
        renderAll();
    }
    
    function setupEventListeners() {
        // Quantum Core click
        document.getElementById('quantum-core').addEventListener('click', handleCoreClick);
        
        // Tab navigation
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
        
        // Header buttons
        document.getElementById('save-btn').addEventListener('click', () => {
            StateManager.save();
            showNotification('Game Saved', 'Your progress has been saved.', 'success');
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            // Show custom confirmation since confirm() is blocked in sandbox
            const resetBtn = document.getElementById('reset-btn');
            if (resetBtn.dataset.confirmPending === 'true') {
                // Second click - actually reset
                // Stop game loop
                GameLoop.stop();
                // Clear localStorage
                localStorage.removeItem('quantumGarden_save');
                // Reset all game data unlocks
                Object.values(GameData.generators).forEach(g => {
                    if (g.unlockAt) g.unlocked = false;
                });
                Object.values(GameData.upgrades).forEach(u => {
                    if (u.requires || u.unlockAt) u.unlocked = false;
                });
                Object.values(GameData.resources).forEach(r => {
                    if (r.unlockAt) r.unlocked = false;
                });
                // Reset narrative messages
                if (typeof QuantumMechanics !== 'undefined') {
                    // Narrative messages are inside the module, we'll just reinit
                }
                // Reinitialize state
                StateManager.initialize();
                // Recalculate production
                GeneratorManager.calculateProduction();
                // Re-render everything
                UI.renderAll();
                // Restart game loop
                GameLoop.start();
                // Reset button state
                resetBtn.dataset.confirmPending = 'false';
                resetBtn.textContent = 'üóëÔ∏è Reset';
                resetBtn.style.background = '';
                resetBtn.style.color = 'var(--quantum-red)';
                // Log it
                UI.addLogEntry('Game reset! Welcome back to your Quantum Garden.', 'highlight');
            } else {
                // First click - ask for confirmation
                resetBtn.dataset.confirmPending = 'true';
                resetBtn.textContent = '‚ö†Ô∏è Click again to confirm!';
                resetBtn.style.background = 'var(--quantum-red)';
                resetBtn.style.color = 'white';
                
                // Reset button state after 3 seconds
                setTimeout(() => {
                    resetBtn.dataset.confirmPending = 'false';
                    resetBtn.textContent = 'üóëÔ∏è Reset';
                    resetBtn.style.background = '';
                    resetBtn.style.color = 'var(--quantum-red)';
                }, 3000);
            }
        });
        
        // Plant modal
        document.getElementById('close-plant-modal').addEventListener('click', closePlantModal);
        document.getElementById('plant-modal').addEventListener('click', (e) => {
            if (e.target.id === 'plant-modal') closePlantModal();
        });
        
        // Event delegation for generator buy buttons (survives re-renders)
        document.getElementById('generators-list').addEventListener('click', (e) => {
            const btn = e.target.closest('.generator-buy-btn');
            if (!btn || btn.disabled) return;
            
            const id = btn.dataset.generator;
            const amount = btn.dataset.amount;
            
            let buyAmount = 1;
            if (amount === 'max') {
                buyAmount = 'max';
            } else if (amount === '10') {
                buyAmount = 10;
            }
            
            if (id && GeneratorManager.buy(id, buyAmount)) {
                renderGenerators();
                renderResources();
                const actualBought = typeof buyAmount === 'number' ? buyAmount : GeneratorManager.getOwned(id);
                const msg = buyAmount === 1 ? 
                    `Purchased ${GameData.generators[id].name}` :
                    `Purchased ${buyAmount === 'max' ? 'max' : buyAmount} ${GameData.generators[id].name}`;
                addLogEntry(msg, 'success');
            }
        });
        
        // Event delegation for upgrade items (survives re-renders)
        document.getElementById('upgrades-list').addEventListener('click', (e) => {
            const item = e.target.closest('.upgrade-item');
            if (!item || item.classList.contains('purchased') || item.classList.contains('locked')) return;
            
            const id = item.dataset.upgrade;
            if (id && UpgradeManager.buy(id)) {
                renderUpgrades();
                renderResources();
                renderGarden();
                updateClickPowerDisplay();
                addLogEntry('Purchased upgrade: ' + GameData.upgrades[id].name, 'success');
            }
        });
        
        // Event delegation for stats tab (collapse reality button)
        document.getElementById('stats-content').addEventListener('click', (e) => {
            const collapseBtn = e.target.closest('#collapse-reality-btn');
            if (collapseBtn && !collapseBtn.disabled) {
                // Confirm collapse with similar pattern to reset
                if (collapseBtn.dataset.confirmPending === 'true') {
                    // Actually collapse
                    if (PrestigeManager.collapse()) {
                        collapseBtn.dataset.confirmPending = 'false';
                        renderStats();
                    }
                } else {
                    // First click - confirm
                    collapseBtn.dataset.confirmPending = 'true';
                    collapseBtn.textContent = '‚ö†Ô∏è Click again to collapse reality!';
                    collapseBtn.style.background = 'linear-gradient(135deg, #ff4444, #cc0000)';
                    
                    // Reset after 3 seconds
                    setTimeout(() => {
                        if (collapseBtn.dataset.confirmPending === 'true') {
                            collapseBtn.dataset.confirmPending = 'false';
                            collapseBtn.textContent = 'üåå Collapse Reality';
                            collapseBtn.style.background = '';
                        }
                    }, 3000);
                }
            }
        });
        
        // Event delegation for plant modal options
        document.getElementById('plant-options').addEventListener('click', (e) => {
            const opt = e.target.closest('.plant-option');
            if (!opt || opt.classList.contains('locked')) return;
            
            const genId = opt.dataset.generator;
            const isPreference = opt.dataset.preference === 'true';
            
            if (isPreference) {
                // Setting auto-plant preference
                if (genId === '__clear__') {
                    StateManager.set(`garden.plots.${selectedPlotIndex}.autoPlantType`, null);
                    addLogEntry(`Cleared auto-plant preference for plot`, '');
                } else {
                    StateManager.set(`garden.plots.${selectedPlotIndex}.autoPlantType`, genId);
                    addLogEntry(`Set plot to auto-plant ${GameData.generators[genId].name}`, 'highlight');
                }
                closePlantModal();
                renderGarden();
            } else {
                // Actually planting
                if (genId && GardenManager.plant(selectedPlotIndex, genId)) {
                    closePlantModal();
                    
                    // Check if mutation occurred
                    const plot = GardenManager.getPlot(selectedPlotIndex);
                    if (plot && plot.mutation) {
                        const mutInfo = GardenManager.getMutationInfo(plot.mutation);
                        addLogEntry(`‚ú® MUTATION! ${mutInfo.icon} ${mutInfo.name} ${GameData.generators[genId].name}!`, 'success');
                        showNotification(`${mutInfo.icon} Mutation!`, `${mutInfo.name}: ${mutInfo.description}`, 'success');
                    } else {
                        addLogEntry('Planted ' + GameData.generators[genId].name, 'highlight');
                    }
                    
                    renderGarden();
                    renderResources();
                }
            }
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger shortcuts when typing in input fields
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
            
            const key = e.key.toLowerCase();
            
            switch (key) {
                case 'e':
                    // Toggle entangle mode
                    const entangleBtn = document.getElementById('entangle-btn');
                    if (entangleBtn && !entangleBtn.disabled) {
                        entangleBtn.click();
                    }
                    break;
                    
                case 'h':
                    // Toggle auto-harvest
                    if (UpgradeManager.isPurchased('autoHarvest')) {
                        const current = StateManager.get('settings.autoHarvestEnabled');
                        StateManager.set('settings.autoHarvestEnabled', !current);
                        addLogEntry(`Auto-harvest: ${!current ? 'ON' : 'OFF'}`, 'highlight');
                        updateGardenControls();
                    }
                    break;
                    
                case 'p':
                    // Toggle auto-plant
                    if (UpgradeManager.isPurchased('autoPlant')) {
                        const current = StateManager.get('settings.autoPlantEnabled');
                        StateManager.set('settings.autoPlantEnabled', !current);
                        addLogEntry(`Auto-plant: ${!current ? 'ON' : 'OFF'}`, 'highlight');
                        updateGardenControls();
                    }
                    break;
                    
                case '1':
                case '2':
                case '3':
                    // Tab shortcuts
                    const tabs = ['generators', 'upgrades', 'stats'];
                    const tabIndex = parseInt(key) - 1;
                    if (tabs[tabIndex]) {
                        switchTab(tabs[tabIndex]);
                    }
                    break;
                    
                case ' ':
                    // Space - click quantum core
                    e.preventDefault();
                    const core = document.getElementById('quantum-core');
                    if (core) {
                        handleCoreClick({ target: core });
                    }
                    break;
                    
                case 'r':
                    // R - harvest all ready plants
                    const plots = StateManager.get('garden.plots') || [];
                    let harvestedCount = 0;
                    plots.forEach((plot, index) => {
                        if (plot.plant && plot.progress >= 1) {
                            const result = GardenManager.harvest(index);
                            if (result && result.yield) {
                                ResourceGainTracker.showHarvestFloat(index, result.yield);
                                harvestedCount++;
                            }
                        }
                    });
                    if (harvestedCount > 0) {
                        addLogEntry(`üåæ Harvested ${harvestedCount} plants with hotkey`, 'success');
                        renderGarden();
                        renderResources();
                    }
                    break;
                    
                case 'escape':
                    // Escape - close modals
                    const modal = document.getElementById('plant-modal');
                    if (modal && modal.classList.contains('active')) {
                        modal.classList.remove('active');
                        selectedPlotIndex = null;
                    }
                    const settingsModal = document.getElementById('settings-modal');
                    if (settingsModal && settingsModal.classList.contains('active')) {
                        settingsModal.classList.remove('active');
                    }
                    // Cancel entanglement mode
                    if (GardenManager.getEntanglementMode().active) {
                        GardenManager.setEntanglementMode(false);
                        updateGardenControls();
                        renderGarden();
                    }
                    break;
                    
                case '?':
                    // Show keyboard shortcuts help
                    showKeyboardHelp();
                    break;
            }
        });
    }
    
    function showKeyboardHelp() {
        // Remove existing help modal if present
        const existing = document.getElementById('keyboard-help-modal');
        if (existing) {
            existing.remove();
            return;
        }
        
        const modal = document.createElement('div');
        modal.className = 'modal active';
        modal.id = 'keyboard-help-modal';
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 400px;">
                <h3>‚å®Ô∏è¬∏¬è Keyboard Shortcuts</h3>
                <div style="display: grid; gap: 8px; margin-top: 16px;">
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-dim);">Space</span>
                        <span>Click quantum core</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-dim);">R</span>
                        <span>Harvest all ready plants</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-dim);">E</span>
                        <span>Toggle entanglement mode</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-dim);">H</span>
                        <span>Toggle auto-harvest</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-dim);">P</span>
                        <span>Toggle auto-plant</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-dim);">1 / 2 / 3</span>
                        <span>Switch tabs</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-dim);">Esc</span>
                        <span>Close modal / cancel</span>
                    </div>
                    <div style="display: flex; justify-content: space-between;">
                        <span style="color: var(--text-dim);">?</span>
                        <span>Toggle this help</span>
                    </div>
                </div>
                <button class="action-btn" style="width: 100%; margin-top: 16px;" 
                        onclick="document.getElementById('keyboard-help-modal').remove()">
                    Got it!
                </button>
            </div>
        `;
        document.body.appendChild(modal);
        
        // Close on backdrop click
        modal.addEventListener('click', (e) => {
            if (e.target === modal) modal.remove();
        });
    }
    
    // Quantum burst charge (builds up with clicks)
    let quantumBurstCharge = 0;
    const BURST_THRESHOLD = 100;
    
    // Click combo system
    let clickCombo = 0;
    let lastClickTime = 0;
    const COMBO_TIMEOUT = 500; // ms between clicks to maintain combo
    
    function handleCoreClick(e) {
        const now = Date.now();
        const power = UpgradeManager.getClickPower();
        const coherence = ResourceManager.get('coherence') || 0;
        
        // Update click combo
        if (now - lastClickTime < COMBO_TIMEOUT) {
            clickCombo = Math.min(50, clickCombo + 1); // Max 50x combo
        } else {
            clickCombo = 1;
        }
        lastClickTime = now;
        
        // Click power is boosted by coherence!
        // At 100% coherence: 150% click power
        // At 0% coherence: 100% click power (base)
        const coherenceBonus = 1 + (coherence / 100) * 0.5;
        
        // Combo bonus: up to 2x at 50 combo
        const comboBonus = 1 + (clickCombo / 50);
        
        const actualPower = Math.floor(power * coherenceBonus * comboBonus);
        
        ResourceManager.add('energy', actualPower);
        
        // CLICKING RESTORES COHERENCE!
        // Each click restores 0.5-2% coherence based on click power
        // Combo also helps restore coherence faster
        const coherenceRestore = Math.min(3, 0.5 + Math.log10(power + 1) * 0.3 + clickCombo * 0.02);
        const currentCoherence = ResourceManager.get('coherence') || 0;
        const newCoherence = Math.min(100, currentCoherence + coherenceRestore);
        StateManager.set('resources.coherence.amount', newCoherence);
        
        // Visual feedback when hitting 100% coherence
        if (currentCoherence < 100 && newCoherence >= 100) {
            const coherenceBar = document.getElementById('coherence-bar-container');
            if (coherenceBar) {
                coherenceBar.classList.add('coherence-maxed');
                setTimeout(() => coherenceBar.classList.remove('coherence-maxed'), 500);
            }
            // Also add log message first time
            if (currentCoherence < 95) {
                addLogEntry('üåÄ Coherence fully restored!', 'success');
            }
        }
        
        // Build quantum burst charge (combo speeds it up!)
        quantumBurstCharge += 1 + (coherence / 50) + (clickCombo / 25);
        
        if (quantumBurstCharge >= BURST_THRESHOLD) {
            triggerQuantumBurst();
            quantumBurstCharge = 0;
        }
        
        // Update quantum burst indicator
        updateBurstIndicator();
        
        // Update combo display
        updateComboDisplay();
        
        // Update stats
        const clicks = StateManager.get('stats.totalClicks') || 0;
        StateManager.set('stats.totalClicks', clicks + 1);
        
        // Track clicks with many generators (for achievement)
        const generators = Object.keys(GameData.generators).reduce((sum, id) => 
            sum + GeneratorManager.getOwned(id), 0);
        if (generators >= 100) {
            const clicksWithManyGens = StateManager.get('stats.clicksWithManyGens') || 0;
            StateManager.set('stats.clicksWithManyGens', clicksWithManyGens + 1);
        }
        
        // Particle effect - show combo bonus
        if (StateManager.get('settings.particlesEnabled')) {
            createClickParticle(e.clientX, e.clientY, actualPower, clickCombo >= 10);
        }
        
        // Quick render of resources only
        renderResources();
        updateCoherenceBar();
    }
    
    function updateComboDisplay() {
        const comboEl = document.getElementById('combo-display');
        const comboValue = document.getElementById('combo-value');
        
        if (!comboEl || !comboValue) return;
        
        if (clickCombo >= 3) {
            comboEl.classList.remove('hidden');
            comboValue.textContent = clickCombo;
            
            // Color based on combo level
            if (clickCombo >= 25) {
                comboValue.style.color = 'var(--quantum-gold)';
            } else if (clickCombo >= 10) {
                comboValue.style.color = 'var(--quantum-cyan)';
            } else {
                comboValue.style.color = 'var(--quantum-orange)';
            }
            
            // Re-trigger animation
            comboEl.style.animation = 'none';
            comboEl.offsetHeight; // Force reflow
            comboEl.style.animation = 'combo-pulse 0.3s ease-out';
            
            // Fade out if no more clicks
            clearTimeout(comboEl._fadeTimer);
            comboEl._fadeTimer = setTimeout(() => {
                comboEl.classList.add('hidden');
                clickCombo = 0;
            }, COMBO_TIMEOUT + 200);
        } else {
            comboEl.classList.add('hidden');
        }
    }
    
    function triggerQuantumBurst() {
        // Quantum burst: Boost all growing plants by 20% instantly!
        const plots = StateManager.get('garden.plots') || [];
        let boosted = 0;
        
        plots.forEach((plot, index) => {
            if (plot.plant && plot.progress < 1) {
                const newProgress = Math.min(1, plot.progress + 0.2);
                StateManager.set(`garden.plots.${index}.progress`, newProgress);
                boosted++;
            }
        });
        
        // Track stat
        const bursts = StateManager.get('stats.quantumBursts') || 0;
        StateManager.set('stats.quantumBursts', bursts + 1);
        
        // Visual feedback
        document.getElementById('quantum-core').classList.add('burst');
        setTimeout(() => {
            document.getElementById('quantum-core').classList.remove('burst');
        }, 500);
        
        // Restore significant coherence
        const currentCoherence = ResourceManager.get('coherence') || 0;
        StateManager.set('resources.coherence.amount', Math.min(100, currentCoherence + 10));
        
        if (boosted > 0) {
            addLogEntry(`‚ö° Quantum Burst! ${boosted} plants boosted by 20%!`, 'highlight');
        } else {
            addLogEntry(`‚ö° Quantum Burst! +10% coherence restored!`, 'highlight');
        }
        
        showNotification('‚ö° QUANTUM BURST!');
        renderGarden();
    }
    
    function updateBurstIndicator() {
        const fill = document.getElementById('burst-fill');
        if (fill) {
            const percent = (quantumBurstCharge / BURST_THRESHOLD * 100);
            fill.style.width = percent + '%';
            
            // Add charged class when near full
            if (percent >= 90) {
                fill.classList.add('charged');
            } else {
                fill.classList.remove('charged');
            }
        }
    }
    
    function createClickParticle(x, y, value, isCoherenceBoosted = false) {
        const particle = document.createElement('div');
        particle.className = 'click-particle' + (isCoherenceBoosted ? ' coherence-boosted' : '');
        particle.textContent = '+' + Utils.formatNumber(value);
        particle.style.left = (x + (Math.random() - 0.5) * 40) + 'px';
        particle.style.top = (y - 20) + 'px';
        document.body.appendChild(particle);
        
        setTimeout(() => particle.remove(), 1000);
    }
    
    function switchTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabId);
        });
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.toggle('active', content.id === tabId + '-tab');
        });
    }
    
    function renderAll() {
        renderResources();
        renderGarden();
        renderGenerators();
        renderUpgrades();
        renderStats();
        updateClickPowerDisplay();
    }
    
    function renderResources() {
        const container = document.getElementById('resources-section');
        let html = '';
        
        // Calculate harvest rates from garden
        const harvestRates = calculateHarvestRates();
        
        // Tooltip descriptions
        const tooltipData = {
            energy: {
                title: '‚ö° Quantum Energy',
                description: 'Primary currency. Earned by clicking, generators, and harvesting.',
            },
            seeds: {
                title: 'üå± Seeds',
                description: 'Required to plant (1 per plant). Earned back when harvesting.',
            },
            time: {
                title: '‚è≥ Time Crystals',
                description: 'Secondary currency for mid-tier upgrades.',
            },
            knowledge: {
                title: 'üìö Quantum Knowledge',
                description: 'Advanced currency for quantum upgrades.',
            },
            coherence: {
                title: 'üåÄ Coherence',
                description: 'Quantum stability. Affects generator production and click power. Click the quantum core to restore!',
            },
            entanglement: {
                title: 'üîó Entanglement Threads',
                description: 'Used to link plants. Entangled plants share growth and harvest together.',
            },
            fragments: {
                title: 'üí† Reality Fragments',
                description: 'Permanent shards of collapsed realities. Used for powerful persistent upgrades.',
            }
        };
        
        Object.entries(GameData.resources).forEach(([id, data]) => {
            if (!ResourceManager.isUnlocked(id)) return;
            
            const amount = ResourceManager.get(id);
            const generatorRate = ResourceManager.getRate(id);
            const harvestRate = harvestRates[id] || 0;
            const totalRate = generatorRate + harvestRate;
            const maxAmount = data.maxAmount;
            
            // Special display for coherence (show as percentage)
            let displayAmount = Utils.formatNumber(amount, 1);
            if (id === 'coherence') {
                displayAmount = Math.floor(amount) + '%';
            }
            
            // Rate display
            let rateHtml = '';
            if (totalRate > 0) {
                rateHtml = `<div class="resource-rate positive">+${Utils.formatNumber(totalRate, 1)}/s</div>`;
            } else if (totalRate < 0) {
                rateHtml = `<div class="resource-rate negative">${Utils.formatNumber(totalRate, 1)}/s</div>`;
            }
            
            html += `
                <div class="resource-item" data-resource="${id}">
                    <div class="resource-info">
                        <span class="resource-icon">${data.icon}</span>
                        <span class="resource-name">${data.name}</span>
                    </div>
                    <div class="resource-values">
                        <div class="resource-amount ${data.color}">${displayAmount}${maxAmount ? '/' + maxAmount : ''}</div>
                        ${rateHtml}
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        
        // Attach tooltips
        container.querySelectorAll('.resource-item').forEach(el => {
            const id = el.dataset.resource;
            const data = tooltipData[id];
            if (data) {
                TooltipManager.attach(el, data, () => getResourceDetail(id));
            }
        });
    }
    
    function getResourceDetail(resourceId) {
        const generatorRate = ResourceManager.getRate(resourceId);
        const harvestRates = calculateHarvestRates();
        const harvestRate = harvestRates[resourceId] || 0;
        
        let details = [];
        
        if (generatorRate > 0) {
            details.push(`Generators: +${Utils.formatNumber(generatorRate, 2)}/s`);
        }
        
        if (harvestRate > 0) {
            details.push(`Garden (avg): +${Utils.formatNumber(harvestRate, 2)}/s`);
        }
        
        // Show coherence effect on energy production
        if (resourceId === 'energy' && ResourceManager.isUnlocked('coherence')) {
            const coherence = ResourceManager.get('coherence') || 0;
            const coherenceMultiplier = 0.3 + (coherence / 100) * 0.7;
            const percent = Math.round(coherenceMultiplier * 100);
            if (percent < 100) {
                details.push(`<span style="color: var(--quantum-red)">Coherence: ${percent}% production</span>`);
            } else {
                details.push(`<span style="color: var(--quantum-green)">Coherence: ${percent}% production</span>`);
            }
        }
        
        if (resourceId === 'coherence') {
            const generators = Object.keys(GameData.generators).reduce((sum, id) => {
                return sum + GeneratorManager.getOwned(id);
            }, 0);
            const decayRate = 0.01 + (generators * 0.002);
            const stabilizer = UpgradeManager.isPurchased('coherenceStabilizer') ? 0.5 : 1;
            const finalDecay = decayRate * stabilizer;
            details.push(`Decay: -${Utils.formatNumber(finalDecay, 3)}/s`);
            details.push(`(${generators} generators)`);
            if (stabilizer < 1) {
                details.push(`Stabilizer: -50% decay`);
            }
            details.push(`<br>üí° Click quantum core to restore!`);
        }
        
        return details.length > 0 ? details.join('<br>') : null;
    }
    
    function calculateHarvestRates() {
        // Only calculate if auto-harvest is on
        if (!UpgradeManager.isPurchased('autoHarvest')) return {};
        if (!StateManager.get('settings.autoHarvestEnabled')) return {};
        
        const plots = StateManager.get('garden.plots') || [];
        const growthMult = UpgradeManager.getGrowthMultiplier();
        const rates = {};
        
        plots.forEach(plot => {
            if (!plot.plant) return;
            
            const data = GameData.generators[plot.plant];
            if (!data || !data.harvestYield) return;
            
            // Calculate harvests per second
            const growTime = data.growthTime / growthMult;
            const harvestsPerSecond = 1 / growTime;
            
            // Add expected yield per second
            for (const [resource, amount] of Object.entries(data.harvestYield)) {
                if (!rates[resource]) rates[resource] = 0;
                rates[resource] += amount * harvestsPerSecond;
            }
        });
        
        return rates;
    }
    
    function renderGarden() {
        const grid = document.getElementById('garden-grid');
        const size = GardenManager.getSize();
        const cols = Math.ceil(Math.sqrt(size));
        const rows = Math.ceil(size / cols);
        
        // Calculate optimal plot size based on available space
        const container = grid.parentElement;
        const containerWidth = container.clientWidth - 32; // Subtract padding
        const containerHeight = container.clientHeight - 100; // Subtract header space
        
        // Calculate max plot size that fits, maintaining square aspect
        const gapSize = 8; // matches --spacing-sm
        const maxPlotWidth = (containerWidth - (cols - 1) * gapSize) / cols;
        const maxPlotHeight = (containerHeight - (rows - 1) * gapSize) / rows;
        
        // Use the smaller dimension to keep plots square, with 180px max and 50px min
        const plotSize = Math.min(maxPlotWidth, maxPlotHeight, 180);
        const finalSize = Math.max(Math.floor(plotSize), 50);
        
        grid.style.gridTemplateColumns = `repeat(${cols}, ${finalSize}px)`;
        grid.style.gridTemplateRows = `repeat(${rows}, ${finalSize}px)`;
        
        let html = '';
        const plots = StateManager.get('garden.plots') || [];
        const entangleMode = GardenManager.getEntanglementMode();
        
        for (let i = 0; i < size; i++) {
            const plot = plots[i] || { plant: null, progress: 0, entangledWith: null };
            const hasPlant = plot.plant !== null;
            const isReady = hasPlant && plot.progress >= 1;
            const plantData = hasPlant ? GameData.generators[plot.plant] : null;
            const isEntangled = plot.entangledWith !== null;
            const isEntangleSource = entangleMode.active && entangleMode.source === i;
            const canEntangle = entangleMode.active && entangleMode.source !== i && hasPlant && !isEntangled;
            const mutation = plot.mutation ? GardenManager.getMutationInfo(plot.mutation) : null;
            
            let plotClass = 'garden-plot';
            if (!hasPlant) plotClass += ' empty';
            else if (isReady) plotClass += ' ready';
            else plotClass += ' planted';
            if (isEntangled) plotClass += ' entangled';
            if (isEntangleSource) plotClass += ' entangle-source';
            if (canEntangle) plotClass += ' entangle-target';
            if (mutation) plotClass += ' mutated';
            
            html += `
                <div class="${plotClass}" data-index="${i}" ${mutation ? `style="--mutation-color: ${mutation.color}"` : ''}>
                    ${hasPlant ? `
                        <div class="plot-plant">${plantData.icon}</div>
                        ${mutation ? `<div class="mutation-indicator" title="${mutation.name}: ${mutation.description}">${mutation.icon}</div>` : ''}
                        ${!isReady ? `<div class="plot-progress" style="width: ${plot.progress * 100}%"></div>` : ''}
                        ${!isReady ? `<div class="plot-timer">${Utils.formatTime(plantData.growthTime * (1 - plot.progress))}</div>` : ''}
                    ` : ''}
                    ${plot.autoPlantType && UpgradeManager.isPurchased('autoPlant') ? `
                        <div class="plot-preference" title="Auto-plants: ${GameData.generators[plot.autoPlantType]?.name || '?'}">
                            ${GameData.generators[plot.autoPlantType]?.icon || '?'}
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        grid.innerHTML = html;
        
        // Add click listeners and observer effect tracking
        grid.querySelectorAll('.garden-plot').forEach(plotEl => {
            const index = parseInt(plotEl.dataset.index);
            
            plotEl.addEventListener('click', () => handlePlotClick(index));
            
            // Observer effect - track when mouse is over a growing plant
            plotEl.addEventListener('mouseenter', () => {
                const plot = GardenManager.getPlot(index);
                if (plot && plot.plant && plot.progress < 1) {
                    QuantumMechanics.setObservedPlot(index);
                    plotEl.classList.add('observed');
                }
            });
            
            plotEl.addEventListener('mouseleave', () => {
                QuantumMechanics.clearObservedPlot();
                plotEl.classList.remove('observed');
            });
        });
        
        // Update plot info
        const used = plots.filter(p => p.plant).length;
        document.getElementById('plots-used').textContent = used;
        document.getElementById('plots-total').textContent = size;
        
        // Show/hide entangle button
        updateEntangleButton();
        
        // Draw entanglement connections
        updateEntanglementLines();
    }
    
    // Update a single plot without full re-render (for animations)
    function updateSinglePlot(plotIndex) {
        const plotEl = document.querySelector(`.garden-plot[data-index="${plotIndex}"]`);
        if (!plotEl) return;
        
        const plot = GardenManager.getPlot(plotIndex);
        const hasPlant = plot && plot.plant !== null;
        const isReady = hasPlant && plot.progress >= 1;
        const plantData = hasPlant ? GameData.generators[plot.plant] : null;
        const mutation = plot?.mutation ? GardenManager.getMutationInfo(plot.mutation) : null;
        
        // Update classes (match renderGarden: empty, planted, ready)
        plotEl.classList.toggle('empty', !hasPlant);
        plotEl.classList.toggle('planted', hasPlant && !isReady);
        plotEl.classList.toggle('ready', isReady);
        
        // Update content (class is 'plot-plant', not 'plant-emoji')
        const plantEl = plotEl.querySelector('.plot-plant');
        const progressEl = plotEl.querySelector('.plot-progress');
        const timerEl = plotEl.querySelector('.plot-timer');
        
        if (hasPlant) {
            if (plantEl) {
                plantEl.textContent = plantData.icon;
                plantEl.style.filter = mutation ? `drop-shadow(0 0 4px ${mutation.color})` : '';
            }
            if (progressEl) {
                progressEl.style.width = `${Math.min(100, plot.progress * 100)}%`;
            }
            if (timerEl && plot.progress < 1) {
                const remaining = plantData.growthTime * (1 - plot.progress);
                timerEl.textContent = Utils.formatTime(remaining);
            }
        } else {
            // Plant was harvested - show empty state with fade effect
            if (plantEl) {
                plantEl.style.opacity = '0';
                plantEl.style.transform = 'scale(0.5)';
                setTimeout(() => {
                    plantEl.textContent = '';
                    plantEl.style.opacity = '';
                    plantEl.style.transform = '';
                }, 200);
            }
            if (progressEl) progressEl.style.width = '0%';
            if (timerEl) timerEl.textContent = '';
            plotEl.classList.remove('planted', 'ready');
            plotEl.classList.add('empty');
        }
    }
    
    function updateEntanglementLines() {
        const svg = document.getElementById('entanglement-lines');
        if (!svg) return;
        
        const grid = document.getElementById('garden-grid');
        const section = document.getElementById('garden-section');
        
        // Position SVG to cover the grid
        svg.style.left = grid.offsetLeft + 'px';
        svg.style.top = grid.offsetTop + 'px';
        svg.setAttribute('width', grid.offsetWidth);
        svg.setAttribute('height', grid.offsetHeight);
        
        let svgContent = '';
        const plots = StateManager.get('garden.plots') || [];
        const drawnPairs = new Set();
        
        plots.forEach((plot, index) => {
            if (plot.entangledWith !== null && !drawnPairs.has(`${Math.min(index, plot.entangledWith)}-${Math.max(index, plot.entangledWith)}`)) {
                const plot1El = document.querySelector(`.garden-plot[data-index="${index}"]`);
                const plot2El = document.querySelector(`.garden-plot[data-index="${plot.entangledWith}"]`);
                
                if (plot1El && plot2El) {
                    // Use offsetLeft/offsetTop relative to grid (since grid is position:relative)
                    const x1 = plot1El.offsetLeft + plot1El.offsetWidth / 2;
                    const y1 = plot1El.offsetTop + plot1El.offsetHeight / 2;
                    const x2 = plot2El.offsetLeft + plot2El.offsetWidth / 2;
                    const y2 = plot2El.offsetTop + plot2El.offsetHeight / 2;
                    
                    // Draw curved line between centers
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    // Perpendicular offset for curve
                    const curveFactor = 0.15;
                    const ctrlX = midX - dy * curveFactor;
                    const ctrlY = midY + dx * curveFactor;
                    
                    svgContent += `<path class="entanglement-line" d="M ${x1} ${y1} Q ${ctrlX} ${ctrlY} ${x2} ${y2}" />`;
                    
                    // Add pulsing particles at each end
                    svgContent += `<circle class="entanglement-particle" cx="${x1}" cy="${y1}" r="4">
                        <animate attributeName="r" values="3;6;3" dur="1s" repeatCount="indefinite" />
                        <animate attributeName="opacity" values="1;0.5;1" dur="1s" repeatCount="indefinite" />
                    </circle>`;
                    svgContent += `<circle class="entanglement-particle" cx="${x2}" cy="${y2}" r="4">
                        <animate attributeName="r" values="3;6;3" dur="1s" repeatCount="indefinite" begin="0.5s" />
                        <animate attributeName="opacity" values="1;0.5;1" dur="1s" repeatCount="indefinite" begin="0.5s" />
                    </circle>`;
                    
                    drawnPairs.add(`${Math.min(index, plot.entangledWith)}-${Math.max(index, plot.entangledWith)}`);
                }
            }
        });
        
        svg.innerHTML = svgContent;
    }
    
    function updateGardenControls() {
        const container = document.getElementById('garden-controls');
        let html = '';
        
        // Auto-Harvest toggle
        if (UpgradeManager.isPurchased('autoHarvest')) {
            const enabled = StateManager.get('settings.autoHarvestEnabled');
            html += `
                <div class="auto-toggle ${enabled ? 'active' : ''}" id="toggle-autoharvest" title="Auto-harvest mature plants every 10s (H)">
                    <span class="toggle-indicator"></span>
                    <span>ü§ñ (H)arvest</span>
                </div>
            `;
        }
        
        // Auto-Plant toggle
        if (UpgradeManager.isPurchased('autoPlant')) {
            const enabled = StateManager.get('settings.autoPlantEnabled');
            html += `
                <div class="auto-toggle ${enabled ? 'active' : ''}" id="toggle-autoplant" title="Auto-plant in empty plots every 5s (P)">
                    <span class="toggle-indicator"></span>
                    <span>üå± (P)lant</span>
                </div>
            `;
        }
        
        // Entangle button
        if (GardenManager.isEntanglementUnlocked()) {
            const mode = GardenManager.getEntanglementMode();
            const threads = ResourceManager.get('entanglement');
            
            if (mode.active) {
                html += `<button class="header-btn" id="entangle-btn" style="background: var(--quantum-red); color: white;">‚ùå Cancel (E)</button>`;
            } else {
                const disabled = threads < 1 ? 'disabled' : '';
                html += `<button class="header-btn" id="entangle-btn" ${disabled}>üîó (E)ntangle (${Math.floor(threads)})</button>`;
            }
        }
        
        container.innerHTML = html;
        
        // Attach event listeners
        const autoHarvestBtn = document.getElementById('toggle-autoharvest');
        if (autoHarvestBtn) {
            autoHarvestBtn.addEventListener('click', () => {
                const current = StateManager.get('settings.autoHarvestEnabled');
                StateManager.set('settings.autoHarvestEnabled', !current);
                updateGardenControls();
                addLogEntry(`Auto-harvest ${!current ? 'enabled' : 'disabled'}`, '');
            });
        }
        
        const autoPlantBtn = document.getElementById('toggle-autoplant');
        if (autoPlantBtn) {
            autoPlantBtn.addEventListener('click', () => {
                const current = StateManager.get('settings.autoPlantEnabled');
                StateManager.set('settings.autoPlantEnabled', !current);
                updateGardenControls();
                addLogEntry(`Auto-plant ${!current ? 'enabled' : 'disabled'}`, '');
            });
        }
        
        const entangleBtn = document.getElementById('entangle-btn');
        if (entangleBtn) {
            entangleBtn.addEventListener('click', toggleEntangleMode);
        }
    }
    
    // Keep old function name for compatibility
    function updateEntangleButton() {
        updateGardenControls();
    }
    
    function toggleEntangleMode() {
        const mode = GardenManager.getEntanglementMode();
        if (mode.active) {
            GardenManager.setEntanglementMode(false, null);
            addLogEntry('Entanglement cancelled', '');
        } else {
            GardenManager.setEntanglementMode(true, null);
            addLogEntry('Select first plant to entangle...', 'highlight');
        }
        renderGarden();
    }
    
    function handlePlotClick(index) {
        const plot = GardenManager.getPlot(index);
        const entangleMode = GardenManager.getEntanglementMode();
        
        // Handle entanglement mode
        if (entangleMode.active) {
            if (entangleMode.source === null) {
                // Selecting first plant
                if (plot.plant && !plot.entangledWith) {
                    GardenManager.setEntanglementMode(true, index);
                    addLogEntry('Now select second plant to entangle with...', 'highlight');
                    renderGarden();
                }
            } else if (entangleMode.source !== index) {
                // Selecting second plant
                if (plot.plant && !plot.entangledWith) {
                    if (GardenManager.entangle(entangleMode.source, index)) {
                        addLogEntry('üîó Plants entangled! They now share fate.', 'success');
                        GardenManager.setEntanglementMode(false, null);
                        renderGarden();
                        renderResources();
                    } else {
                        addLogEntry('Cannot entangle these plants!', 'warning');
                    }
                }
            }
            return;
        }
        
        if (plot.plant && plot.progress >= 1) {
            // Harvest ready plant - get quantum yield
            const plantData = GameData.generators[plot.plant];
            const harvestResult = GardenManager.harvest(index);
            
            if (harvestResult && harvestResult.yield) {
                // Show floating harvest numbers for main plant
                ResourceGainTracker.showHarvestFloat(index, harvestResult.yield);
                
                // Format yield for log
                const yieldText = Object.entries(harvestResult.yield)
                    .map(([r, a]) => `${GameData.resources[r].icon}${a}`)
                    .join(' ');
                    
                addLogEntry(`Harvested ${plantData.name}: ${yieldText}`, 'success');
                
                // Log partner harvest if there was an entangled plant
                if (harvestResult.partnerYield && harvestResult.partnerPlant) {
                    // Show floating numbers for partner too
                    if (harvestResult.partnerId !== null && harvestResult.partnerId !== undefined) {
                        ResourceGainTracker.showHarvestFloat(harvestResult.partnerId, harvestResult.partnerYield);
                    }
                    
                    const partnerData = GameData.generators[harvestResult.partnerPlant];
                    const partnerYieldText = Object.entries(harvestResult.partnerYield)
                        .map(([r, a]) => `${GameData.resources[r].icon}${a}`)
                        .join(' ');
                    addLogEntry(`üîó Entangled ${partnerData.name}: ${partnerYieldText}`, 'success');
                }
                
                renderGarden();
                renderResources();
            }
        } else if (plot.plant && plot.progress < 1) {
            // Click on growing plant - if auto-plant is unlocked, allow setting preference
            if (UpgradeManager.isPurchased('autoPlant')) {
                selectedPlotIndex = index;
                openPlantModal(true); // true = setting preference
            }
        } else if (!plot.plant) {
            // Open plant selector
            selectedPlotIndex = index;
            openPlantModal(false);
        }
    }
    
    function openPlantModal(settingPreference = false) {
        const modal = document.getElementById('plant-modal');
        const optionsContainer = document.getElementById('plant-options');
        const modalTitle = document.querySelector('#plant-modal-content h3');
        
        if (settingPreference) {
            modalTitle.textContent = 'üîÑ Set Auto-Plant Type';
        } else {
            modalTitle.textContent = 'üå± Select a Plant';
        }
        
        let html = '';
        const seeds = ResourceManager.get('seeds');
        const plot = GardenManager.getPlot(selectedPlotIndex);
        const currentPreference = plot?.autoPlantType || null;
        
        // Add clear option when setting preference
        if (settingPreference) {
            html += `
                <div class="plant-option clear-option" data-generator="__clear__" data-preference="true">
                    <div class="plant-option-icon">üö´</div>
                    <div class="plant-option-info">
                        <div class="plant-option-name">Clear Preference</div>
                        <div class="plant-option-desc">Use default auto-plant behavior for this plot</div>
                    </div>
                </div>
            `;
        }
        
        Object.entries(GameData.generators).forEach(([id, data]) => {
            if (!data.gardenPlantable) return;
            if (!GeneratorManager.isUnlocked(id)) return;
            
            const canPlant = settingPreference || seeds >= 1;
            const isCurrentPref = currentPreference === id;
            
            // Format harvest yield
            const yieldText = Object.entries(data.harvestYield).map(([r, a]) => 
                `${GameData.resources[r]?.icon || '?'}${a}`
            ).join(' ');
            
            html += `
                <div class="plant-option ${!canPlant ? 'locked' : ''} ${isCurrentPref ? 'selected' : ''}" 
                     data-generator="${id}" 
                     data-preference="${settingPreference}">
                    <div class="plant-option-icon">${data.icon}</div>
                    <div class="plant-option-info">
                        <div class="plant-option-name">${data.name} ${isCurrentPref ? '‚úì' : ''}</div>
                        <div class="plant-option-desc">${data.description}</div>
                        <div class="plant-option-cost">‚è±Ô∏è ${Utils.formatTime(data.growthTime)} ‚Üí ${yieldText}</div>
                    </div>
                </div>
            `;
        });
        
        if (!html) {
            html = '<p style="color: var(--text-secondary);">No plants available yet. Buy some generators first!</p>';
        }
        
        optionsContainer.innerHTML = html;
        // Note: Click handling via event delegation set up in setupEventListeners
        
        modal.classList.add('active');
    }
    
    function closePlantModal() {
        document.getElementById('plant-modal').classList.remove('active');
        selectedPlotIndex = null;
    }
    
    function getSelectedPlotIndex() {
        return selectedPlotIndex;
    }
    
    function renderGenerators() {
        const container = document.getElementById('generators-list');
        let html = '';
        
        Object.entries(GameData.generators).forEach(([id, data]) => {
            const isUnlocked = GeneratorManager.isUnlocked(id);
            if (!isUnlocked && !data.unlockAt) return;
            
            const owned = GeneratorManager.getOwned(id);
            const cost = GeneratorManager.getCost(id);
            const canAfford = ResourceManager.canAfford(cost);
            const production = GeneratorManager.getProduction(id);
            
            // Calculate max affordable
            const maxAffordable = GeneratorManager.getMaxAffordable(id);
            const cost10 = GeneratorManager.getCost(id, 10);
            const canAfford10 = ResourceManager.canAfford(cost10);
            
            let costText = Object.entries(cost).map(([r, a]) => 
                `${GameData.resources[r].icon} ${Utils.formatNumber(a)}`
            ).join(' ');
            
            let prodText = Object.entries(data.production).map(([r, a]) => 
                `+${Utils.formatNumber(a * (owned || 1), 2)} ${GameData.resources[r].icon}/s`
            ).join(', ');
            
            // Harvest yield info
            let harvestInfo = '';
            if (data.gardenPlantable && data.harvestYield) {
                const harvestText = Object.entries(data.harvestYield).map(([r, a]) => 
                    `${GameData.resources[r]?.icon || '?'}${a}`
                ).join(' ');
                harvestInfo = `<div class="generator-harvest">üå± ${Utils.formatTime(data.growthTime)} ‚Üí ${harvestText}</div>`;
            }
            
            html += `
                <div class="generator-item ${!isUnlocked ? 'locked' : ''}" data-generator-id="${id}">
                    <div class="generator-header">
                        <span class="generator-icon">${data.icon}</span>
                        <div class="generator-title">
                            <div class="generator-name">${data.name}</div>
                            <div class="generator-owned">${owned} owned</div>
                        </div>
                    </div>
                    <div class="generator-desc">${data.description}</div>
                    <div class="generator-stats">
                        <span>Produces: ${prodText}</span>
                    </div>
                    ${harvestInfo}
                    <div class="generator-buttons">
                        <button class="generator-buy-btn" 
                                data-generator="${id}" 
                                data-amount="1"
                                ${!isUnlocked || !canAfford ? 'disabled' : ''}>
                            ${isUnlocked ? `Buy 1 (${costText})` : 'Locked'}
                        </button>
                        <button class="generator-buy-btn small" 
                                data-generator="${id}" 
                                data-amount="10"
                                ${!isUnlocked || !canAfford10 ? 'disabled' : ''}>
                            √ó10
                        </button>
                        <button class="generator-buy-btn max-btn" 
                                data-generator="${id}" 
                                data-amount="max"
                                ${!isUnlocked || maxAffordable === 0 ? 'disabled' : ''}>
                            Max${maxAffordable > 0 ? `<br>(${maxAffordable})` : ''}
                        </button>
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        // Note: No individual click listeners here - we use event delegation
    }
    
    function renderUpgrades() {
        const container = document.getElementById('upgrades-list');
        let html = '';
        
        Object.entries(GameData.upgrades).forEach(([id, data]) => {
            const isPurchased = UpgradeManager.isPurchased(id);
            const isUnlocked = UpgradeManager.isUnlocked(id);
            
            if (!isUnlocked && !isPurchased) return;
            
            const canBuy = UpgradeManager.canBuy(id);
            
            let costText = Object.entries(data.cost).map(([r, a]) => 
                `${GameData.resources[r].icon} ${Utils.formatNumber(a)}`
            ).join(' ');
            
            html += `
                <div class="upgrade-item ${isPurchased ? 'purchased' : ''} ${!isUnlocked ? 'locked' : ''}" 
                     data-upgrade="${id}">
                    <div class="upgrade-header">
                        <span class="upgrade-icon">${data.icon}</span>
                        <span class="upgrade-name">${data.name}</span>
                        <span class="upgrade-cost">${isPurchased ? '‚úì' : costText}</span>
                    </div>
                    <div class="upgrade-desc">${data.description}</div>
                </div>
            `;
        });
        
        container.innerHTML = html || '<p style="color: var(--text-secondary);">No upgrades available yet.</p>';
        // Note: No individual click listeners here - we use event delegation
    }
    
    function renderStats() {
        const container = document.getElementById('stats-content');
        const stats = StateManager.get('stats') || {};
        
        const playTime = ((Date.now() - (stats.startDate || Date.now())) / 1000);
        
        // Get achievements
        const achievements = AchievementManager.getAll();
        const unlockedAchievements = achievements.filter(a => a.unlocked);
        const lockedAchievements = achievements.filter(a => !a.unlocked && !a.secret);
        
        // Check prestige status
        const prestigeUnlocked = PrestigeManager.isUnlocked();
        const realityLevel = PrestigeManager.getRealityLevel();
        const fragments = ResourceManager.get('fragments') || 0;
        const fragmentsOnCollapse = PrestigeManager.getFragmentsOnCollapse();
        const canCollapse = PrestigeManager.canCollapse();
        const productionBonus = PrestigeManager.getProductionMultiplier();
        const totalEnergy = StateManager.get('resources.energy.total') || 0;
        
        // Calculate next fragment threshold
        const FRAGMENT_BASE = 1000000;
        let nextThresholdText = '';
        if (totalEnergy < FRAGMENT_BASE) {
            nextThresholdText = `First fragment at ${Utils.formatNumber(FRAGMENT_BASE)} total energy`;
        } else {
            // Current fragments from formula (without first-time bonus)
            const currentFromFormula = Math.floor(Math.log10(totalEnergy / FRAGMENT_BASE) * 3) + 1;
            // Next threshold
            const nextThreshold = Math.pow(10, currentFromFormula / 3) * FRAGMENT_BASE;
            if (totalEnergy < nextThreshold) {
                const progress = ((totalEnergy - (Math.pow(10, (currentFromFormula - 1) / 3) * FRAGMENT_BASE)) / 
                                 (nextThreshold - Math.pow(10, (currentFromFormula - 1) / 3) * FRAGMENT_BASE) * 100).toFixed(0);
                nextThresholdText = `Next: ${Utils.formatNumber(nextThreshold)} (${progress}%)`;
            } else {
                nextThresholdText = `Keep earning for more fragments!`;
            }
        }
        
        // Build prestige section HTML
        let prestigeHtml = '';
        if (prestigeUnlocked) {
            const needsRealityAwareness = !UpgradeManager.isPurchased('realityAwareness');
            const totalEnergy = StateManager.get('resources.energy.total') || 0;
            const needsMoreEnergy = !needsRealityAwareness && fragmentsOnCollapse === 0;
            
            // Determine the warning/info text
            let warningText;
            if (needsRealityAwareness) {
                warningText = 'üîÆ Purchase Reality Awareness upgrade to unlock collapse';
            } else if (needsMoreEnergy) {
                warningText = '‚è≥ Accumulate 1M+ total energy to earn fragments';
            } else if (canCollapse) {
                warningText = '‚ö†Ô∏è Resets progress but keeps fragments, achievements & persistent upgrades';
            } else {
                warningText = 'üí† Ready to transcend when you are';
            }
            
            prestigeHtml = `
                <div class="prestige-section">
                    <h4>üí† Reality Collapse</h4>
                    <div class="prestige-info">
                        <div class="prestige-stat">
                            <span class="label">Reality Level</span>
                            <span class="value">${realityLevel}</span>
                        </div>
                        <div class="prestige-stat">
                            <span class="label">Reality Fragments</span>
                            <span class="value">${Utils.formatNumber(fragments)}</span>
                        </div>
                        ${productionBonus > 1 ? `
                            <div class="prestige-stat">
                                <span class="label">Production Bonus</span>
                                <span class="value highlight">+${Math.round((productionBonus - 1) * 100)}%</span>
                            </div>
                        ` : ''}
                        <div class="prestige-stat">
                            <span class="label">Fragments on Collapse</span>
                            <span class="value ${fragmentsOnCollapse > 0 ? 'highlight' : ''}">${fragmentsOnCollapse > 0 ? '+' + fragmentsOnCollapse : (needsRealityAwareness ? 'Locked' : '0')}</span>
                        </div>
                        <div class="prestige-stat">
                            <span class="label">Progress</span>
                            <span class="value" style="font-size: 0.75rem; color: var(--text-dim);">${nextThresholdText}</span>
                        </div>
                    </div>
                    <button class="collapse-btn" id="collapse-reality-btn" ${!canCollapse ? 'disabled' : ''}>
                        üåå Collapse Reality
                    </button>
                    <p class="collapse-warning">
                        ${warningText}
                    </p>
                </div>
            `;
        }
        
        container.innerHTML = `
            ${prestigeHtml}
            <div class="stat-group">
                <h4>üèÜ Achievements (${unlockedAchievements.length}/${achievements.length})</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;">
                    ${unlockedAchievements.map(a => `
                        <div class="achievement-badge unlocked" title="${a.name}: ${a.description}">
                            ${a.icon}
                        </div>
                    `).join('')}
                    ${lockedAchievements.map(a => `
                        <div class="achievement-badge locked" title="???">
                            ‚ùú
                        </div>
                    `).join('')}
                </div>
            </div>
            <div class="stat-group">
                <h4>General</h4>
                <div class="stat-row">
                    <span class="stat-label">Total Clicks</span>
                    <span class="stat-value">${Utils.formatNumber(stats.totalClicks || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Plants Harvested</span>
                    <span class="stat-value">${Utils.formatNumber(stats.totalPlantsHarvested || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Quantum Events</span>
                    <span class="stat-value">${Utils.formatNumber(stats.quantumEventsWitnessed || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Quantum Bursts</span>
                    <span class="stat-value">${Utils.formatNumber(stats.quantumBursts || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Plants Entangled</span>
                    <span class="stat-value">${Utils.formatNumber(stats.plantsEntangled || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Mutations Witnessed</span>
                    <span class="stat-value">${Utils.formatNumber(stats.mutationsWitnessed || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Play Time</span>
                    <span class="stat-value">${Utils.formatTime(playTime)}</span>
                </div>
            </div>
            <div class="stat-group">
                <h4>Resources Earned (All Time)</h4>
                ${Object.entries(GameData.resources).map(([id, data]) => {
                    if (!ResourceManager.isUnlocked(id)) return '';
                    const total = StateManager.get(`resources.${id}.total`) || 0;
                    return `
                        <div class="stat-row">
                            <span class="stat-label">${data.icon} ${data.name}</span>
                            <span class="stat-value">${Utils.formatNumber(total)}</span>
                        </div>
                    `;
                }).join('')}
            </div>
            <div class="stat-group">
                <h4>Generators Owned</h4>
                ${Object.entries(GameData.generators).map(([id, data]) => {
                    const owned = GeneratorManager.getOwned(id);
                    if (owned === 0) return '';
                    return `
                        <div class="stat-row">
                            <span class="stat-label">${data.icon} ${data.name}</span>
                            <span class="stat-value">${owned}</span>
                        </div>
                    `;
                }).join('') || '<p style="color: var(--text-dim);">None yet</p>'}
            </div>
        `;
    }
    
    function updateClickPowerDisplay() {
        const power = UpgradeManager.getClickPower();
        const coherence = ResourceManager.get('coherence') || 0;
        const coherenceBonus = 1 + (coherence / 100) * 0.5;
        const actualPower = power * coherenceBonus;
        
        const display = document.getElementById('click-power-value');
        display.textContent = Utils.formatNumber(actualPower, 1);
        
        // Color based on coherence bonus
        if (coherenceBonus >= 1.4) {
            display.style.color = 'var(--quantum-cyan)';
        } else if (coherenceBonus >= 1.2) {
            display.style.color = 'var(--quantum-green)';
        } else if (coherenceBonus < 1.1) {
            display.style.color = 'var(--quantum-red)';
        } else {
            display.style.color = '';
        }
    }
    
    function updateGardenProgress() {
        // Update progress bars and timers in-place without re-rendering
        const plots = StateManager.get('garden.plots') || [];
        const growthMult = UpgradeManager.getGrowthMultiplier();
        
        plots.forEach((plot, index) => {
            const plotEl = document.querySelector(`.garden-plot[data-index="${index}"]`);
            if (!plotEl) return;
            
            if (plot.plant) {
                const data = GameData.generators[plot.plant];
                const progressBar = plotEl.querySelector('.plot-progress');
                const timer = plotEl.querySelector('.plot-timer');
                
                if (plot.progress >= 1) {
                    // Plant is ready - update class if needed
                    if (!plotEl.classList.contains('ready')) {
                        plotEl.classList.remove('planted');
                        plotEl.classList.add('ready');
                        if (progressBar) progressBar.remove();
                        if (timer) timer.remove();
                    }
                } else {
                    // Update progress bar and timer
                    if (progressBar) {
                        progressBar.style.width = (plot.progress * 100) + '%';
                    }
                    if (timer) {
                        const remainingTime = data.growthTime * (1 - plot.progress) / growthMult;
                        timer.textContent = Utils.formatTime(remainingTime);
                    }
                }
            }
        });
        
        // Update plot counter
        const used = plots.filter(p => p.plant).length;
        document.getElementById('plots-used').textContent = used;
    }
    
    function updateBuyButtons() {
        // Update generator buy buttons
        document.querySelectorAll('.generator-buy-btn').forEach(btn => {
            const id = btn.dataset.generator;
            const amount = btn.dataset.amount;
            if (!id) return;
            
            const isUnlocked = GeneratorManager.isUnlocked(id);
            
            if (amount === '1') {
                // Buy 1 button - show cost
                const cost = GeneratorManager.getCost(id, 1);
                const canAfford = ResourceManager.canAfford(cost);
                btn.disabled = !isUnlocked || !canAfford;
                
                if (isUnlocked) {
                    let costText = Object.entries(cost).map(([r, a]) => 
                        `${GameData.resources[r].icon} ${Utils.formatNumber(a)}`
                    ).join(' ');
                    btn.textContent = `Buy 1 (${costText})`;
                }
            } else if (amount === '10') {
                // Buy 10 button
                const cost10 = GeneratorManager.getCost(id, 10);
                const canAfford10 = ResourceManager.canAfford(cost10);
                btn.disabled = !isUnlocked || !canAfford10;
                btn.textContent = '√ó10';
            } else if (amount === 'max') {
                // Buy Max button
                const maxAffordable = GeneratorManager.getMaxAffordable(id);
                btn.disabled = !isUnlocked || maxAffordable === 0;
                btn.innerHTML = maxAffordable > 0 ? `Max<br>(${maxAffordable})` : 'Max';
            }
        });
        
        // Update upgrade items
        document.querySelectorAll('.upgrade-item:not(.purchased)').forEach(item => {
            const id = item.dataset.upgrade;
            if (!id) return;
            
            const canBuy = UpgradeManager.canBuy(id);
            const isUnlocked = UpgradeManager.isUnlocked(id);
            
            item.classList.toggle('locked', !isUnlocked);
            
            // Visual feedback for affordability
            if (isUnlocked && canBuy) {
                item.style.borderColor = 'var(--quantum-gold)';
            } else if (isUnlocked) {
                item.style.borderColor = 'var(--border-dim)';
            }
        });
        
        // Update coherence bar
        updateCoherenceBar();
    }
    
    function updateCoherenceBar() {
        const container = document.getElementById('coherence-bar-container');
        const fill = document.getElementById('coherence-fill');
        const value = document.getElementById('coherence-value');
        const quantumCore = document.getElementById('quantum-core');
        const efficiencyValue = document.getElementById('efficiency-value');
        
        if (ResourceManager.isUnlocked('coherence')) {
            container.classList.remove('hidden');
            const coherence = ResourceManager.get('coherence');
            fill.style.width = coherence + '%';
            value.textContent = Math.floor(coherence) + '%';
            
            // Calculate and display production efficiency
            const efficiency = Math.round((0.3 + (coherence / 100) * 0.7) * 100);
            efficiencyValue.textContent = efficiency + '%';
            
            // Color the efficiency value
            efficiencyValue.classList.remove('high', 'medium', 'low');
            if (efficiency >= 90) {
                efficiencyValue.classList.add('high');
            } else if (efficiency >= 75) {
                efficiencyValue.classList.add('medium');
            } else {
                efficiencyValue.classList.add('low');
            }
            
            // Color changes based on level
            if (coherence > 50) {
                fill.style.background = 'linear-gradient(90deg, var(--quantum-green), var(--quantum-cyan))';
            } else if (coherence > 25) {
                fill.style.background = 'linear-gradient(90deg, var(--quantum-gold), var(--quantum-green))';
            } else {
                fill.style.background = 'linear-gradient(90deg, var(--quantum-red), var(--quantum-gold))';
            }
            
            // Pulse quantum core when coherence is low (encourage clicking!)
            if (coherence < 30) {
                quantumCore.classList.add('low-coherence');
            } else {
                quantumCore.classList.remove('low-coherence');
            }
        } else {
            container.classList.add('hidden');
            quantumCore.classList.remove('low-coherence');
        }
    }
    
    function addLogEntry(message, type = '') {
        const container = document.getElementById('log-container');
        const entry = document.createElement('div');
        entry.className = 'log-entry' + (type ? ' ' + type : '');
        entry.textContent = message;
        
        container.insertBefore(entry, container.firstChild);
        
        // Keep only last 20 entries
        while (container.children.length > 20) {
            container.removeChild(container.lastChild);
        }
    }
    
    function showNotification(title, message = '', type = '') {
        const container = document.getElementById('notification-container');
        const notification = document.createElement('div');
        notification.className = 'notification' + (type ? ' ' + type : '');
        notification.innerHTML = `
            <div class="notification-title">${title}</div>
            ${message ? `<div class="notification-message">${message}</div>` : ''}
        `;
        
        container.appendChild(notification);
        
        // Store timeout so we can pause on hover
        let dismissTimeout;
        
        function startDismissTimer(delay = 3000) {
            dismissTimeout = setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100px)';
                setTimeout(() => notification.remove(), 300);
            }, delay);
        }
        
        // Pause dismiss on hover
        notification.addEventListener('mouseenter', () => {
            clearTimeout(dismissTimeout);
        });
        
        // Resume dismiss on mouse leave (shorter delay)
        notification.addEventListener('mouseleave', () => {
            startDismissTimer(1500);
        });
        
        // Start initial timer
        startDismissTimer();
    }
    
    function updateNextUnlock() {
        const container = document.getElementById('next-unlock-indicator');
        const nameEl = document.getElementById('next-unlock-name');
        const fillEl = document.getElementById('next-unlock-fill');
        const percentEl = document.getElementById('next-unlock-percent');
        
        if (!container || !nameEl || !fillEl || !percentEl) return;
        
        // Find the next unlock (prioritize upgrades, then generators)
        let bestUnlock = null;
        let bestProgress = -1;
        
        // Check unlockable upgrades
        Object.entries(GameData.upgrades).forEach(([id, data]) => {
            if (UpgradeManager.isPurchased(id)) return;
            if (data.unlocked || UpgradeManager.isUnlocked(id)) {
                // Already unlocked but not purchased - show cost progress
                const cost = Object.entries(data.cost)[0];
                if (cost) {
                    const [resource, amount] = cost;
                    const current = ResourceManager.get(resource);
                    const progress = Math.min(1, current / amount);
                    if (progress > bestProgress && progress < 1) {
                        bestProgress = progress;
                        bestUnlock = {
                            name: data.name,
                            icon: data.icon,
                            target: amount,
                            current: current,
                            resourceName: GameData.resources[resource]?.name || resource,
                            resourceIcon: GameData.resources[resource]?.icon || '‚ö°',
                            type: 'purchase'
                        };
                    }
                }
            } else if (data.unlockAt) {
                // Check unlock progress
                const current = StateManager.get(`resources.${data.unlockAt.resource}.total`) || 0;
                const progress = Math.min(1, current / data.unlockAt.amount);
                if (progress > bestProgress && progress < 1) {
                    bestProgress = progress;
                    bestUnlock = {
                        name: data.name,
                        icon: data.icon,
                        target: data.unlockAt.amount,
                        current: current,
                        resourceName: GameData.resources[data.unlockAt.resource]?.name || data.unlockAt.resource,
                        resourceIcon: GameData.resources[data.unlockAt.resource]?.icon || '‚ö°',
                        type: 'unlock'
                    };
                }
            }
        });
        
        // Check unlockable generators
        Object.entries(GameData.generators).forEach(([id, data]) => {
            if (data.unlocked) return;
            if (data.unlockAt) {
                const current = StateManager.get(`resources.${data.unlockAt.resource}.total`) || 0;
                const progress = Math.min(1, current / data.unlockAt.amount);
                if (progress > bestProgress && progress < 1) {
                    bestProgress = progress;
                    bestUnlock = {
                        name: data.name,
                        icon: data.icon,
                        target: data.unlockAt.amount,
                        current: current,
                        resourceName: GameData.resources[data.unlockAt.resource]?.name || data.unlockAt.resource,
                        resourceIcon: GameData.resources[data.unlockAt.resource]?.icon || '‚ö°',
                        type: 'unlock'
                    };
                }
            }
        });
        
        if (bestUnlock) {
            container.classList.remove('hidden');
            const percent = Math.floor(bestProgress * 100);
            const verb = bestUnlock.type === 'purchase' ? 'Buy' : 'Unlock';
            nameEl.innerHTML = `${bestUnlock.icon} ${bestUnlock.name}`;
            fillEl.style.width = percent + '%';
            percentEl.textContent = percent + '%';
            
            // Add pulse animation when close to unlock
            if (percent >= 80) {
                container.classList.add('near-unlock');
            } else {
                container.classList.remove('near-unlock');
            }
        } else {
            // No more unlocks to show - hide or show completion message
            const totalUnlocks = Object.keys(GameData.upgrades).length + Object.keys(GameData.generators).length;
            const purchased = Object.keys(GameData.upgrades).filter(id => UpgradeManager.isPurchased(id)).length;
            const unlocked = Object.keys(GameData.generators).filter(id => GameData.generators[id].unlocked).length;
            
            if (purchased + unlocked >= totalUnlocks) {
                container.classList.add('hidden');
            } else {
                // There's something but we can't reach it yet
                nameEl.innerHTML = 'üîÆ Keep exploring...';
                fillEl.style.width = '100%';
                percentEl.textContent = '??';
                container.classList.remove('near-unlock');
            }
        }
    }
    
    return {
        initialize,
        renderAll,
        renderResources,
        renderGarden,
        renderGenerators,
        renderUpgrades,
        renderStats,
        updateGardenProgress,
        updateBuyButtons,
        updateClickPowerDisplay,
        updateCoherenceBar,
        updateNextUnlock,
        updateSinglePlot,
        updateEntanglementLines,
        addLogEntry,
        showNotification,
        getSelectedPlotIndex
    };
})();

// ============================================
// MODULE: Game Loop
// ============================================
const GameLoop = (() => {
    let lastTime = Date.now();
    let running = false;
    let saveTimer = 0;
    let uiTimer = 0;
    let statsTimer = 0;
    
    function start() {
        running = true;
        lastTime = Date.now();
        requestAnimationFrame(tick);
    }
    
    function stop() {
        running = false;
    }
    
    function tick() {
        if (!running) return;
        
        const now = Date.now();
        const deltaTime = Math.min((now - lastTime) / 1000, 1); // Cap at 1 second
        lastTime = now;
        
        // Update game state
        update(deltaTime);
        
        // UI updates (throttled)
        uiTimer += deltaTime;
        if (uiTimer >= 0.1) { // 10 FPS for UI
            GeneratorManager.calculateProduction(); // Recalc rates (coherence affects these)
            UI.renderResources();
            UI.updateGardenProgress(); // Only update progress bars, not full re-render
            UI.updateBuyButtons(); // Check if buttons should enable/disable
            UI.updateClickPowerDisplay(); // Update click power with coherence bonus
            UI.updateCoherenceBar(); // Update coherence bar
            UI.updateNextUnlock(); // Update next unlock indicator
            uiTimer = 0;
        }
        
        // Stats updates (slower - once per second is fine)
        statsTimer += deltaTime;
        if (statsTimer >= 1) {
            UI.renderStats();
            statsTimer = 0;
        }
        
        // Autosave
        const saveInterval = StateManager.get('settings.autosaveInterval') || 30;
        saveTimer += deltaTime;
        if (saveTimer >= saveInterval) {
            StateManager.save();
            saveTimer = 0;
        }
        
        requestAnimationFrame(tick);
    }
    
    function update(deltaTime) {
        // Generator production
        Object.keys(GameData.generators).forEach(id => {
            const prod = GeneratorManager.getProduction(id);
            for (const [resource, rate] of Object.entries(prod)) {
                ResourceManager.add(resource, rate * deltaTime);
            }
        });
        
        // Garden growth
        GardenManager.update(deltaTime);
        
        // Quantum mechanics (observer effect, events, coherence)
        QuantumMechanics.update(deltaTime);
        
        // Achievement checking
        AchievementManager.update(deltaTime);
        
        // Update play time
        const playTime = StateManager.get('stats.playTime') || 0;
        StateManager.set('stats.playTime', playTime + deltaTime);
        
        // Track high coherence time (for achievement)
        const coherence = ResourceManager.get('coherence') || 0;
        const generators = Object.keys(GameData.generators).reduce((sum, id) => 
            sum + GeneratorManager.getOwned(id), 0);
        if (coherence >= 90 && generators >= 50) {
            const highTime = StateManager.get('stats.highCoherenceTime') || 0;
            StateManager.set('stats.highCoherenceTime', highTime + deltaTime);
        } else {
            // Reset if conditions not met
            StateManager.set('stats.highCoherenceTime', 0);
        }
        
        // Check unlocks (throttled - every 0.5s worth of updates is fine)
        checkUnlocks();
    }
    
    function checkUnlocks() {
        // Check generator unlocks
        let changed = false;
        Object.entries(GameData.generators).forEach(([id, data]) => {
            if (!data.unlocked && GeneratorManager.isUnlocked(id)) {
                data.unlocked = true;
                UI.addLogEntry('Unlocked: ' + data.name + '!', 'highlight');
                changed = true;
            }
        });
        
        // Check upgrade unlocks
        Object.entries(GameData.upgrades).forEach(([id, data]) => {
            if (!data.unlocked && !UpgradeManager.isPurchased(id) && UpgradeManager.isUnlocked(id)) {
                data.unlocked = true;
                UI.addLogEntry('New upgrade available: ' + data.name, 'highlight');
                changed = true;
            }
        });
        
        if (changed) {
            UI.renderGenerators();
            UI.renderUpgrades();
        }
    }
    
    return { start, stop };
})();

// ============================================
// INITIALIZATION
// ============================================
(function init() {
    // Initialize tooltip system
    TooltipManager.init();
    
    // Initialize state
    const wasLoaded = StateManager.initialize();
    
    // Initialize UI
    UI.initialize();
    
    // Initialize Narrative System
    NarrativeSystem.initialize();
    
    // Calculate initial production
    GeneratorManager.calculateProduction();
    
    // Initialize next unlock display
    UI.updateNextUnlock();
    
    // Start game loop
    GameLoop.start();
    
    // Log startup
    if (wasLoaded) {
        UI.addLogEntry('Welcome back to your Quantum Garden!');
        
        // Calculate and show offline progress
        const offlineProgress = StateManager.calculateOfflineProgress();
        if (offlineProgress && offlineProgress.seconds >= 60) {
            setTimeout(() => {
                showOfflineProgressModal(offlineProgress);
            }, 500);
        }
    } else {
        UI.addLogEntry('Welcome to Quantum Garden! Click the quantum core to begin.');
        UI.addLogEntry('Tip: Gather 30 energy to unlock seeds and start planting!', 'highlight');
    }
    
    function showOfflineProgressModal(progress) {
        let gainsHtml = '';
        for (const [resource, amount] of Object.entries(progress.gains)) {
            if (amount > 0 && GameData.resources[resource]) {
                const data = GameData.resources[resource];
                gainsHtml += `<div class="offline-gain">${data.icon} +${Utils.formatNumber(amount)} ${data.name}</div>`;
            }
        }
        
        if (!gainsHtml) return; // No gains to show
        
        const modal = document.createElement('div');
        modal.className = 'modal active';
        modal.id = 'offline-modal';
        modal.innerHTML = `
            <div class="modal-content" style="max-width: 400px; text-align: center;">
                <h3>üåô Welcome Back!</h3>
                <p style="color: var(--text-dim); margin-bottom: 1rem;">
                    While you were away for <strong>${progress.formattedTime}</strong>, 
                    your generators kept working at 50% efficiency.
                </p>
                <div style="background: var(--bg-dark); padding: 1rem; border-radius: 8px; margin-bottom: 1rem;">
                    ${gainsHtml}
                </div>
                <button class="action-btn" onclick="document.getElementById('offline-modal').remove()">
                    Collect & Continue
                </button>
            </div>
        `;
        document.body.appendChild(modal);
        
        UI.addLogEntry(`Offline progress: ${progress.formattedTime} of production collected!`, 'success');
    }
    
    // Setup window events
    window.addEventListener('beforeunload', () => {
        if (StateManager.canSave() && !window.quantumGardenResetting) {
            StateManager.save();
        }
    });
    
    // Handle window resize - update garden and entanglement lines
    let resizeTimeout;
    window.addEventListener('resize', () => {
        // Debounce resize events
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(() => {
            UI.renderGarden();
        }, 100);
    });
    
    // Attach coherence bar tooltip
    const coherenceBar = document.getElementById('coherence-bar-container');
    if (coherenceBar) {
        TooltipManager.attach(coherenceBar, {
            title: 'üåÄ Quantum Coherence',
            description: 'Affects harvest yield variance. High coherence = unpredictable but potentially higher yields. Low coherence = predictable, consistent yields.'
        }, () => {
            const generators = Object.keys(GameData.generators).reduce((sum, id) => {
                return sum + GeneratorManager.getOwned(id);
            }, 0);
            let decayRate = 0.01 + (generators * 0.002);
            const hasStabilizer = UpgradeManager.isPurchased('coherenceStabilizer');
            if (hasStabilizer) decayRate *= 0.5;
            
            let detail = `Decay: -${Utils.formatNumber(decayRate, 3)}/s`;
            detail += `<br>From: ${generators} generators`;
            if (hasStabilizer) detail += `<br>Stabilizer: -50% decay`;
            return detail;
        });
    }
    
    // Attach quantum core tooltip
    const quantumCore = document.getElementById('quantum-core');
    if (quantumCore) {
        TooltipManager.attach(quantumCore, {
            title: '‚öõÔ∏è Quantum Core',
            description: 'Click to gather Quantum Energy!'
        }, () => {
            const power = UpgradeManager.getClickPower();
            let detail = `Click power: ${Utils.formatNumber(power)}`;
            
            // Show breakdown
            let multiplier = 1;
            let bonus = 0;
            const sources = [];
            
            if (UpgradeManager.isPurchased('efficientClicking')) {
                sources.push('Quantum Resonance: √ó2');
                multiplier *= 2;
            }
            if (UpgradeManager.isPurchased('improvedClicking')) {
                sources.push('Harmonic Amplification: √ó3');
                multiplier *= 3;
            }
            if (UpgradeManager.isPurchased('quantumClicking')) {
                sources.push('Superposition Click: +5');
                bonus += 5;
            }
            
            if (sources.length > 0) {
                detail += '<br><br>' + sources.join('<br>');
            }
            
            return detail;
        });
    }
    
    console.log('üå∏ Quantum Garden initialized');
})();
</script>
</body>
</html>
