<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Quantum Garden</title>
    <style>
/* ============================================
   CSS RESET & BASE STYLES
   ============================================ */
*, *::before, *::after {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

:root {
    /* Color Palette - Quantum Theme */
    --bg-dark: #0a0a12;
    --bg-panel: #12121f;
    --bg-card: #1a1a2e;
    --bg-card-hover: #242438;
    --border-dim: #2a2a4a;
    --border-bright: #4a4a8a;
    
    /* Accent Colors */
    --quantum-blue: #4fc3f7;
    --quantum-purple: #b388ff;
    --quantum-green: #69f0ae;
    --quantum-gold: #ffd54f;
    --quantum-red: #ff5252;
    --quantum-pink: #f48fb1;
    --quantum-cyan: #18ffff;
    --quantum-orange: #ffab40;
    
    /* Text Colors */
    --text-primary: #e0e0e0;
    --text-secondary: #9e9e9e;
    --text-dim: #616161;
    
    /* Spacing */
    --spacing-xs: 4px;
    --spacing-sm: 8px;
    --spacing-md: 16px;
    --spacing-lg: 24px;
    --spacing-xl: 32px;
    
    /* Border Radius */
    --radius-sm: 4px;
    --radius-md: 8px;
    --radius-lg: 12px;
    
    /* Transitions */
    --transition-fast: 0.15s ease;
    --transition-normal: 0.3s ease;
}

html, body {
    height: 100%;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg-dark);
    color: var(--text-primary);
    overflow: hidden;
    user-select: none;
    -webkit-user-select: none;
    -webkit-tap-highlight-color: transparent;
}

/* Scrollbar Styling */
::-webkit-scrollbar {
    width: 8px;
    height: 8px;
}

::-webkit-scrollbar-track {
    background: var(--bg-dark);
}

::-webkit-scrollbar-thumb {
    background: var(--border-dim);
    border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
    background: var(--border-bright);
}

/* ============================================
   LAYOUT
   ============================================ */
#game-container {
    display: flex;
    flex-direction: column;
    height: 100vh;
    max-height: 100vh;
    overflow: hidden;
}

#header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-sm) var(--spacing-md);
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border-dim);
    flex-shrink: 0;
}

#header h1 {
    font-size: 1.25rem;
    font-weight: 600;
    background: linear-gradient(135deg, var(--quantum-blue), var(--quantum-purple));
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

#header-controls {
    display: flex;
    gap: var(--spacing-sm);
}

.header-btn {
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    color: var(--text-secondary);
    padding: var(--spacing-xs) var(--spacing-sm);
    border-radius: var(--radius-sm);
    cursor: pointer;
    font-size: 0.75rem;
    transition: var(--transition-fast);
}

.header-btn:hover {
    background: var(--bg-card-hover);
    border-color: var(--border-bright);
    color: var(--text-primary);
}

#main-content {
    display: flex;
    flex: 1;
    overflow: hidden;
}

/* Left Panel - Resources & Core Interaction */
#left-panel {
    width: 280px;
    min-width: 280px;
    display: flex;
    flex-direction: column;
    background: var(--bg-panel);
    border-right: 1px solid var(--border-dim);
    overflow-y: auto;
}

/* Center Panel - Garden */
#center-panel {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    padding: var(--spacing-md);
}

/* Right Panel - Upgrades & Info */
#right-panel {
    width: 320px;
    min-width: 320px;
    display: flex;
    flex-direction: column;
    background: var(--bg-panel);
    border-left: 1px solid var(--border-dim);
    overflow-y: auto;
}

/* Tab Navigation */
.tab-nav {
    display: flex;
    background: var(--bg-dark);
    border-bottom: 1px solid var(--border-dim);
    flex-shrink: 0;
}

.tab-btn {
    flex: 1;
    padding: var(--spacing-sm) var(--spacing-md);
    background: transparent;
    border: none;
    color: var(--text-secondary);
    font-size: 0.8rem;
    cursor: pointer;
    transition: var(--transition-fast);
    border-bottom: 2px solid transparent;
}

.tab-btn:hover {
    background: var(--bg-card);
    color: var(--text-primary);
}

.tab-btn.active {
    color: var(--quantum-blue);
    border-bottom-color: var(--quantum-blue);
    background: var(--bg-panel);
}

.tab-content {
    display: none;
    flex: 1;
    overflow-y: auto;
    padding: var(--spacing-md);
}

.tab-content.active {
    display: block;
}

/* ============================================
   RESOURCES DISPLAY
   ============================================ */
#resources-section {
    padding: var(--spacing-md);
}

.resource-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-xs);
    background: var(--bg-card);
    border-radius: var(--radius-sm);
    border: 1px solid var(--border-dim);
    cursor: help;
    position: relative;
}

.resource-rate.negative {
    color: var(--quantum-red);
}

/* Global tooltip styles - using a single tooltip element to prevent jitter */
#tooltip {
    position: fixed;
    background: var(--bg-dark);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-sm);
    padding: 10px 14px;
    font-size: 0.75rem;
    color: var(--text-secondary);
    max-width: 280px;
    z-index: 1000;
    pointer-events: none;
    box-shadow: 0 4px 16px rgba(0,0,0,0.4);
    opacity: 0;
    transition: opacity 0.15s ease;
    line-height: 1.4;
}

#tooltip.visible {
    opacity: 1;
}

#tooltip .tooltip-title {
    color: var(--text-primary);
    font-weight: 600;
    margin-bottom: 4px;
}

#tooltip .tooltip-detail {
    color: var(--quantum-cyan);
    font-size: 0.7rem;
    margin-top: 6px;
    padding-top: 6px;
    border-top: 1px solid var(--border-dim);
}

.resource-info {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
}

.resource-icon {
    font-size: 1.2rem;
    width: 28px;
    text-align: center;
}

.resource-name {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.resource-values {
    text-align: right;
}

.resource-amount {
    font-size: 1rem;
    font-weight: 600;
    font-variant-numeric: tabular-nums;
}

.resource-rate {
    font-size: 0.7rem;
    color: var(--text-dim);
}

.resource-rate.positive {
    color: var(--quantum-green);
}

/* ============================================
   QUANTUM CORE (Main Click Area)
   ============================================ */
#quantum-core-section {
    padding: var(--spacing-md);
    display: flex;
    flex-direction: column;
    align-items: center;
}

#quantum-core {
    width: 140px;
    height: 140px;
    border-radius: 50%;
    background: radial-gradient(circle at 30% 30%, var(--quantum-blue), var(--quantum-purple));
    border: 3px solid var(--quantum-blue);
    cursor: pointer;
    position: relative;
    transition: transform 0.1s ease, box-shadow 0.3s ease;
    box-shadow: 
        0 0 20px rgba(79, 195, 247, 0.3),
        0 0 40px rgba(179, 136, 255, 0.2),
        inset 0 0 30px rgba(255, 255, 255, 0.1);
}

#quantum-core:hover {
    transform: scale(1.05);
    box-shadow: 
        0 0 30px rgba(79, 195, 247, 0.5),
        0 0 60px rgba(179, 136, 255, 0.3),
        inset 0 0 30px rgba(255, 255, 255, 0.15);
}

#quantum-core:active {
    transform: scale(0.95);
}

/* Core pulses when coherence is low - encouraging clicks */
#quantum-core.low-coherence {
    animation: coherence-pulse 1.5s ease-in-out infinite;
    border-color: var(--quantum-red);
}

@keyframes coherence-pulse {
    0%, 100% {
        box-shadow: 0 0 20px rgba(255, 99, 99, 0.5), 0 0 40px rgba(255, 99, 99, 0.3);
    }
    50% {
        box-shadow: 0 0 40px rgba(255, 99, 99, 0.7), 0 0 80px rgba(255, 99, 99, 0.5);
    }
}

/* Quantum burst flash effect */
#quantum-core.burst {
    animation: quantum-burst 0.5s ease-out !important;
}

@keyframes quantum-burst {
    0% {
        transform: scale(1);
    }
    50% {
        transform: scale(1.3);
        box-shadow: 0 0 80px var(--quantum-cyan), 0 0 150px var(--quantum-cyan), 0 0 200px white;
    }
    100% {
        transform: scale(1);
    }
}

/* Burst indicator bar */
#burst-indicator {
    margin: var(--spacing-sm) var(--spacing-md);
    text-align: center;
}

.burst-bar {
    height: 6px;
    background: var(--bg-card);
    border-radius: 3px;
    overflow: hidden;
    border: 1px solid var(--border-dim);
}

.burst-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--quantum-cyan), var(--quantum-purple));
    transition: width 0.1s ease-out;
    box-shadow: 0 0 10px var(--quantum-cyan);
}

.burst-label {
    font-size: 0.65rem;
    color: var(--text-dim);
    margin-top: 2px;
    text-transform: uppercase;
    letter-spacing: 1px;
}

/* Coherence-boosted click particles */
.click-particle.coherence-boosted {
    color: var(--quantum-cyan) !important;
    text-shadow: 0 0 10px var(--quantum-cyan), 0 0 20px var(--quantum-cyan) !important;
}

#quantum-core::before {
    content: '';
    position: absolute;
    top: 10%;
    left: 10%;
    width: 80%;
    height: 80%;
    border-radius: 50%;
    background: radial-gradient(circle at 40% 40%, rgba(255,255,255,0.3), transparent 60%);
    pointer-events: none;
}

#core-power-display {
    margin-top: var(--spacing-md);
    text-align: center;
}

#core-power-display .label {
    font-size: 0.75rem;
    color: var(--text-dim);
    text-transform: uppercase;
    letter-spacing: 1px;
}

#core-power-display .value {
    font-size: 1.5rem;
    font-weight: 700;
    color: var(--quantum-blue);
}

/* Click Particles */
.click-particle {
    position: fixed;
    pointer-events: none;
    font-weight: bold;
    font-size: 1rem;
    color: var(--quantum-gold);
    text-shadow: 0 0 10px var(--quantum-gold);
    animation: floatUp 1s ease-out forwards;
    z-index: 1000;
}

@keyframes floatUp {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-60px) scale(0.5);
    }
}

/* ============================================
   GARDEN GRID
   ============================================ */
#garden-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--spacing-md);
    flex-wrap: wrap;
    gap: var(--spacing-sm);
}

#garden-header h2 {
    font-size: 1.1rem;
    color: var(--text-primary);
}

#garden-controls {
    display: flex;
    gap: var(--spacing-sm);
    align-items: center;
}

.auto-toggle {
    display: flex;
    align-items: center;
    gap: 4px;
    padding: 4px 8px;
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-sm);
    font-size: 0.7rem;
    color: var(--text-secondary);
    cursor: pointer;
    transition: var(--transition-fast);
}

.auto-toggle:hover {
    border-color: var(--border-bright);
}

.auto-toggle.active {
    background: var(--quantum-green);
    border-color: var(--quantum-green);
    color: var(--bg-dark);
}

.auto-toggle .toggle-indicator {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--text-dim);
}

.auto-toggle.active .toggle-indicator {
    background: var(--bg-dark);
}

#garden-info {
    font-size: 0.8rem;
    color: var(--text-secondary);
}

#garden-grid {
    display: grid;
    gap: var(--spacing-xs);
    flex: 1;
    align-content: start;
    position: relative;
}

.garden-plot {
    aspect-ratio: 1;
    background: var(--bg-card);
    border: 2px solid var(--border-dim);
    border-radius: var(--radius-md);
    cursor: pointer;
    position: relative;
    transition: var(--transition-fast);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    overflow: hidden;
}

.garden-plot:hover {
    border-color: var(--border-bright);
    background: var(--bg-card-hover);
}

.garden-plot.empty::after {
    content: '+';
    font-size: 1.5rem;
    color: var(--text-dim);
    opacity: 0;
    transition: var(--transition-fast);
}

.garden-plot.empty:hover::after {
    opacity: 1;
}

.garden-plot.planted {
    border-color: var(--quantum-green);
}

.garden-plot.ready {
    border-color: var(--quantum-gold);
    animation: pulse-glow 2s ease-in-out infinite;
}

@keyframes pulse-glow {
    0%, 100% { box-shadow: 0 0 5px var(--quantum-gold); }
    50% { box-shadow: 0 0 20px var(--quantum-gold); }
}

.plot-plant {
    font-size: 1.8rem;
    line-height: 1;
}

.plot-progress {
    position: absolute;
    bottom: 0;
    left: 0;
    height: 4px;
    background: var(--quantum-green);
    transition: width 0.5s linear;
}

.plot-timer {
    position: absolute;
    top: 2px;
    right: 4px;
    font-size: 0.65rem;
    color: var(--text-dim);
}

/* ============================================
   PLANT SELECTOR MODAL
   ============================================ */
#plant-modal {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 100;
    align-items: center;
    justify-content: center;
}

#plant-modal.active {
    display: flex;
}

#plant-modal-content {
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-lg);
    padding: var(--spacing-lg);
    max-width: 400px;
    width: 90%;
    max-height: 80vh;
    overflow-y: auto;
}

#plant-modal h3 {
    margin-bottom: var(--spacing-md);
    color: var(--quantum-blue);
}

.plant-option {
    display: flex;
    align-items: center;
    gap: var(--spacing-md);
    padding: var(--spacing-md);
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-md);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: var(--transition-fast);
}

.plant-option:hover:not(.locked) {
    border-color: var(--quantum-green);
    background: var(--bg-card-hover);
}

.plant-option.locked {
    opacity: 0.5;
    cursor: not-allowed;
}

.plant-option.selected {
    border-color: var(--quantum-green);
    background: rgba(105, 240, 174, 0.1);
}

.plant-option.clear-option {
    border-color: var(--quantum-red);
    opacity: 0.8;
}

.plant-option.clear-option:hover {
    opacity: 1;
    background: rgba(255, 99, 99, 0.1);
}

.plot-preference {
    position: absolute;
    bottom: 2px;
    left: 2px;
    font-size: 0.6rem;
    opacity: 0.6;
    background: var(--bg-dark);
    padding: 1px 3px;
    border-radius: 2px;
}

/* Enhanced observer effect - magnifying lens */
.garden-plot.observed .plot-plant {
    transform: scale(1.3);
    filter: brightness(1.2) drop-shadow(0 0 8px var(--quantum-cyan));
    transition: transform 0.2s ease, filter 0.2s ease;
}

/* Floating time reduction text */
.observer-float {
    position: absolute;
    color: var(--quantum-cyan);
    font-size: 0.7rem;
    font-weight: bold;
    pointer-events: none;
    animation: observer-float-up 1s ease-out forwards;
    text-shadow: 0 0 4px var(--quantum-cyan);
    z-index: 20;
}

@keyframes observer-float-up {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-30px) scale(0.8);
    }
}

.observer-float.entangled-boost {
    color: var(--quantum-orange);
    text-shadow: 0 0 4px var(--quantum-orange);
    font-size: 0.6rem;
}

/* Harvest floating numbers */
.harvest-float {
    position: absolute;
    color: var(--quantum-green);
    font-size: 0.8rem;
    font-weight: bold;
    pointer-events: none;
    animation: harvest-float-up 1.2s ease-out forwards;
    text-shadow: 0 0 6px var(--quantum-green), 0 2px 4px rgba(0,0,0,0.5);
    z-index: 25;
    white-space: nowrap;
}

@keyframes harvest-float-up {
    0% {
        opacity: 1;
        transform: translateY(0) scale(1.2);
    }
    20% {
        transform: translateY(-10px) scale(1);
    }
    100% {
        opacity: 0;
        transform: translateY(-50px) scale(0.8);
    }
}

/* Resource gain indicators on left panel */
.resource-gain {
    position: absolute;
    right: -5px;
    top: 50%;
    transform: translateY(-50%);
    color: var(--quantum-green);
    font-size: 0.75rem;
    font-weight: bold;
    text-shadow: 0 0 4px var(--quantum-green);
    animation: gain-pulse 0.3s ease-out;
    pointer-events: none;
}

@keyframes gain-pulse {
    0% {
        transform: translateY(-50%) scale(1.5);
        opacity: 0;
    }
    50% {
        opacity: 1;
    }
    100% {
        transform: translateY(-50%) scale(1);
        opacity: 1;
    }
}

.resource-gain.fading {
    animation: gain-fade 0.5s ease-out forwards;
}

@keyframes gain-fade {
    0% {
        opacity: 1;
    }
    100% {
        opacity: 0;
        transform: translateY(-50%) translateX(10px);
    }
}

.plant-option-icon {
    font-size: 2rem;
}

.plant-option-info {
    flex: 1;
}

.plant-option-name {
    font-weight: 600;
    margin-bottom: 2px;
}

.plant-option-desc {
    font-size: 0.75rem;
    color: var(--text-secondary);
}

.plant-option-cost {
    font-size: 0.8rem;
    color: var(--quantum-gold);
}

#close-plant-modal {
    margin-top: var(--spacing-md);
    width: 100%;
    padding: var(--spacing-sm);
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    color: var(--text-primary);
    border-radius: var(--radius-sm);
    cursor: pointer;
}

/* ============================================
   GENERATORS (Plants/Buildings)
   ============================================ */
.generator-item {
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    transition: var(--transition-fast);
}

.generator-item:hover:not(.locked) {
    border-color: var(--border-bright);
}

.generator-item.locked {
    opacity: 0.4;
}

.generator-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-sm);
}

.generator-icon {
    font-size: 1.5rem;
}

.generator-title {
    flex: 1;
}

.generator-name {
    font-weight: 600;
    font-size: 0.9rem;
}

.generator-owned {
    font-size: 0.75rem;
    color: var(--text-dim);
}

.generator-desc {
    font-size: 0.75rem;
    color: var(--text-secondary);
    margin-bottom: var(--spacing-sm);
}

.generator-stats {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    color: var(--text-dim);
    margin-bottom: var(--spacing-sm);
}

.generator-harvest {
    font-size: 0.7rem;
    color: var(--quantum-green);
    margin-bottom: var(--spacing-sm);
    padding: 4px 8px;
    background: rgba(105, 240, 174, 0.1);
    border-radius: var(--radius-sm);
}

.generator-buy-btn {
    width: 100%;
    padding: var(--spacing-sm);
    background: linear-gradient(135deg, var(--quantum-purple), var(--quantum-blue));
    border: none;
    border-radius: var(--radius-sm);
    color: white;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-fast);
}

.generator-buy-btn:hover:not(:disabled) {
    filter: brightness(1.2);
    transform: translateY(-1px);
}

.generator-buy-btn:disabled {
    background: var(--bg-card);
    color: var(--text-dim);
    cursor: not-allowed;
}

/* ============================================
   UPGRADES
   ============================================ */
.upgrade-item {
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    margin-bottom: var(--spacing-sm);
    cursor: pointer;
    transition: var(--transition-fast);
}

.upgrade-item:hover:not(.purchased):not(.locked) {
    border-color: var(--quantum-gold);
}

.upgrade-item.purchased {
    opacity: 0.5;
    border-color: var(--quantum-green);
}

.upgrade-item.locked {
    opacity: 0.3;
}

.upgrade-header {
    display: flex;
    align-items: center;
    gap: var(--spacing-sm);
    margin-bottom: var(--spacing-xs);
}

.upgrade-icon {
    font-size: 1.2rem;
}

.upgrade-name {
    flex: 1;
    font-weight: 600;
    font-size: 0.85rem;
}

.upgrade-cost {
    font-size: 0.8rem;
    color: var(--quantum-gold);
}

.upgrade-desc {
    font-size: 0.75rem;
    color: var(--text-secondary);
}

/* ============================================
   LOG / MESSAGES
   ============================================ */
#log-section {
    padding: var(--spacing-md);
    border-top: 1px solid var(--border-dim);
    max-height: 150px;
    overflow-y: auto;
}

#log-section h4 {
    font-size: 0.8rem;
    color: var(--text-dim);
    margin-bottom: var(--spacing-sm);
    text-transform: uppercase;
    letter-spacing: 1px;
}

.log-entry {
    font-size: 0.75rem;
    color: var(--text-secondary);
    padding: var(--spacing-xs) 0;
    border-bottom: 1px solid var(--border-dim);
    opacity: 0;
    animation: fadeIn 0.3s ease forwards;
}

.log-entry:last-child {
    border-bottom: none;
}

.log-entry.highlight {
    color: var(--quantum-gold);
}

.log-entry.success {
    color: var(--quantum-green);
}

.log-entry.warning {
    color: var(--quantum-red);
}

.log-entry.mysterious {
    color: var(--quantum-purple);
    font-style: italic;
    text-shadow: 0 0 10px var(--quantum-purple);
}

@keyframes fadeIn {
    to { opacity: 1; }
}

/* ============================================
   STATISTICS TAB
   ============================================ */
.stat-group {
    margin-bottom: var(--spacing-lg);
}

.stat-group h4 {
    font-size: 0.85rem;
    color: var(--quantum-blue);
    margin-bottom: var(--spacing-sm);
    padding-bottom: var(--spacing-xs);
    border-bottom: 1px solid var(--border-dim);
}

.stat-row {
    display: flex;
    justify-content: space-between;
    padding: var(--spacing-xs) 0;
    font-size: 0.8rem;
}

.stat-label {
    color: var(--text-secondary);
}

.stat-value {
    color: var(--text-primary);
    font-weight: 500;
}

/* Achievement badges */
.achievement-badge {
    width: 36px;
    height: 36px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    font-size: 1.2rem;
    cursor: help;
    transition: var(--transition-fast);
}

.achievement-badge.unlocked {
    background: linear-gradient(135deg, var(--quantum-gold), var(--quantum-orange));
    box-shadow: 0 0 10px rgba(255, 213, 79, 0.5);
}

.achievement-badge.unlocked:hover {
    transform: scale(1.1);
    box-shadow: 0 0 20px rgba(255, 213, 79, 0.8);
}

.achievement-badge.locked {
    background: var(--bg-dark);
    border: 1px solid var(--border-dim);
    opacity: 0.5;
}

/* ============================================
   SETTINGS TAB
   ============================================ */
.settings-group {
    margin-bottom: var(--spacing-lg);
}

.settings-group h4 {
    font-size: 0.85rem;
    color: var(--quantum-purple);
    margin-bottom: var(--spacing-sm);
}

.setting-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: var(--spacing-sm);
    background: var(--bg-card);
    border-radius: var(--radius-sm);
    margin-bottom: var(--spacing-xs);
}

.setting-label {
    font-size: 0.85rem;
}

.setting-toggle {
    width: 48px;
    height: 24px;
    background: var(--bg-dark);
    border: 1px solid var(--border-dim);
    border-radius: 12px;
    cursor: pointer;
    position: relative;
    transition: var(--transition-fast);
}

.setting-toggle.active {
    background: var(--quantum-green);
    border-color: var(--quantum-green);
}

.setting-toggle::after {
    content: '';
    position: absolute;
    width: 18px;
    height: 18px;
    background: white;
    border-radius: 50%;
    top: 2px;
    left: 2px;
    transition: var(--transition-fast);
}

.setting-toggle.active::after {
    left: 26px;
}

.settings-btn {
    width: 100%;
    padding: var(--spacing-sm);
    margin-bottom: var(--spacing-xs);
    background: var(--bg-card);
    border: 1px solid var(--border-dim);
    border-radius: var(--radius-sm);
    color: var(--text-primary);
    cursor: pointer;
    transition: var(--transition-fast);
}

.settings-btn:hover {
    border-color: var(--border-bright);
    background: var(--bg-card-hover);
}

.settings-btn.danger {
    border-color: var(--quantum-red);
    color: var(--quantum-red);
}

.settings-btn.danger:hover {
    background: var(--quantum-red);
    color: white;
}

/* ============================================
   NOTIFICATIONS / TOASTS
   ============================================ */
#notification-container {
    position: fixed;
    top: var(--spacing-lg);
    right: var(--spacing-lg);
    z-index: 200;
    display: flex;
    flex-direction: column;
    gap: var(--spacing-sm);
    pointer-events: none;
}

.notification {
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-md);
    padding: var(--spacing-md);
    min-width: 250px;
    animation: slideIn 0.3s ease;
    pointer-events: auto;
}

.notification.success {
    border-color: var(--quantum-green);
}

.notification.warning {
    border-color: var(--quantum-gold);
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translateX(100px);
    }
    to {
        opacity: 1;
        transform: translateX(0);
    }
}

.notification-title {
    font-weight: 600;
    margin-bottom: var(--spacing-xs);
}

.notification-message {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

/* ============================================
   RESPONSIVE DESIGN
   ============================================ */
@media (max-width: 1024px) {
    #left-panel {
        width: 240px;
        min-width: 240px;
    }
    #right-panel {
        width: 280px;
        min-width: 280px;
    }
}

@media (max-width: 768px) {
    #main-content {
        flex-direction: column;
    }
    
    #left-panel, #right-panel {
        width: 100%;
        min-width: 100%;
        max-height: 40vh;
    }
    
    #center-panel {
        order: -1;
        flex: none;
        height: 50vh;
    }
    
    #quantum-core {
        width: 100px;
        height: 100px;
    }
}

/* ============================================
   UTILITY CLASSES
   ============================================ */
.hidden {
    display: none !important;
}

.text-energy { color: var(--quantum-blue); }
.text-seeds { color: var(--quantum-green); }
.text-time { color: var(--quantum-purple); }
.text-knowledge { color: var(--quantum-gold); }
.text-reality { color: var(--quantum-pink); }
.text-coherence { color: var(--quantum-cyan); }
.text-entanglement { color: var(--quantum-orange); }
.text-fragments { color: var(--quantum-pink); }

/* ============================================
   QUANTUM EFFECTS
   ============================================ */

/* Superposition shimmer */
@keyframes superposition {
    0%, 100% { opacity: 1; filter: hue-rotate(0deg); }
    25% { opacity: 0.8; filter: hue-rotate(20deg); }
    50% { opacity: 1; filter: hue-rotate(-20deg); }
    75% { opacity: 0.9; filter: hue-rotate(10deg); }
}

.quantum-state {
    animation: superposition 2s ease-in-out infinite;
}

/* Entanglement glow */
.entangled {
    box-shadow: 0 0 15px var(--quantum-orange), 0 0 30px rgba(255, 171, 64, 0.3);
}

.entangled::before {
    content: 'üîó';
    position: absolute;
    top: 2px;
    left: 4px;
    font-size: 0.7rem;
    z-index: 10;
}

.entangle-source {
    border-color: var(--quantum-orange) !important;
    box-shadow: 0 0 20px var(--quantum-orange);
    animation: entangle-pulse 0.5s ease-in-out infinite;
}

.entangle-target {
    border-color: var(--quantum-cyan) !important;
    cursor: crosshair !important;
}

.entangle-target:hover {
    box-shadow: 0 0 20px var(--quantum-cyan);
}

@keyframes entangle-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.02); }
}

/* Entanglement SVG overlay */
.entanglement-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 15;
}

.entanglement-line {
    stroke: var(--quantum-orange);
    stroke-width: 2;
    fill: none;
    stroke-dasharray: 8 4;
    animation: entangle-flow 1s linear infinite;
    filter: drop-shadow(0 0 4px var(--quantum-orange));
}

@keyframes entangle-flow {
    0% { stroke-dashoffset: 0; }
    100% { stroke-dashoffset: -24; }
}

/* Entanglement particle effect (pulsing dots along line) */
.entanglement-particle {
    fill: var(--quantum-orange);
    filter: drop-shadow(0 0 6px var(--quantum-orange));
}

#garden-section {
    position: relative;
}

/* Observer effect - plant being watched */
.observed {
    border-color: var(--quantum-cyan) !important;
    box-shadow: 0 0 20px var(--quantum-cyan);
}

.observed .plot-plant {
    animation: observed-pulse 0.5s ease-in-out infinite;
}

@keyframes observed-pulse {
    0%, 100% { transform: scale(1); }
    50% { transform: scale(1.1); }
}

/* Quantum tunneling flash */
@keyframes tunnel-flash {
    0% { background: transparent; }
    50% { background: rgba(79, 195, 247, 0.3); }
    100% { background: transparent; }
}

.tunneling {
    animation: tunnel-flash 0.3s ease-out;
}

/* Reality destabilizing */
@keyframes reality-shake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-2px) rotate(-0.5deg); }
    75% { transform: translateX(2px) rotate(0.5deg); }
}

.reality-unstable {
    animation: reality-shake 0.1s ease-in-out infinite;
}

/* Coherence bar */
#coherence-bar-container {
    margin: var(--spacing-md);
    padding: var(--spacing-sm);
    background: var(--bg-card);
    border-radius: var(--radius-md);
    border: 1px solid var(--border-dim);
    cursor: help;
    position: relative;
}

#coherence-bar-container:hover {
    border-color: var(--border-bright);
}

#coherence-bar-container.hidden {
    display: none;
}

.coherence-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.75rem;
    margin-bottom: var(--spacing-xs);
}

.coherence-bar {
    height: 8px;
    background: var(--bg-dark);
    border-radius: 4px;
    overflow: hidden;
}

.coherence-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--quantum-red), var(--quantum-cyan));
    transition: width 0.3s ease;
}

/* Event notification */
.quantum-event {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: var(--bg-panel);
    border: 2px solid var(--quantum-purple);
    border-radius: var(--radius-lg);
    padding: var(--spacing-xl);
    max-width: 400px;
    z-index: 300;
    text-align: center;
    animation: event-appear 0.3s ease-out;
    box-shadow: 0 0 50px rgba(179, 136, 255, 0.5);
}

@keyframes event-appear {
    from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}

.quantum-event h3 {
    color: var(--quantum-purple);
    margin-bottom: var(--spacing-md);
    font-size: 1.2rem;
}

.quantum-event p {
    color: var(--text-secondary);
    margin-bottom: var(--spacing-lg);
    line-height: 1.5;
}

.quantum-event button {
    padding: var(--spacing-sm) var(--spacing-lg);
    background: linear-gradient(135deg, var(--quantum-purple), var(--quantum-blue));
    border: none;
    border-radius: var(--radius-sm);
    color: white;
    font-weight: 600;
    cursor: pointer;
}

/* Probability tooltip */
.probability-tooltip {
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-panel);
    border: 1px solid var(--border-bright);
    border-radius: var(--radius-sm);
    padding: var(--spacing-sm);
    font-size: 0.7rem;
    white-space: nowrap;
    z-index: 50;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
}

.garden-plot:hover .probability-tooltip {
    opacity: 1;
}

/* Glitch text effect for mysterious messages */
.glitch {
    position: relative;
}

.glitch::before,
.glitch::after {
    content: attr(data-text);
    position: absolute;
    left: 0;
    top: 0;
    opacity: 0.8;
}

.glitch::before {
    animation: glitch-1 0.3s infinite;
    color: var(--quantum-cyan);
    clip-path: polygon(0 0, 100% 0, 100% 45%, 0 45%);
}

.glitch::after {
    animation: glitch-2 0.3s infinite;
    color: var(--quantum-pink);
    clip-path: polygon(0 55%, 100% 55%, 100% 100%, 0 100%);
}

@keyframes glitch-1 {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(-2px); }
    40% { transform: translateX(2px); }
}

@keyframes glitch-2 {
    0%, 100% { transform: translateX(0); }
    20% { transform: translateX(2px); }
    40% { transform: translateX(-2px); }
}
    </style>
</head>
<body>
    <div id="game-container">
        <!-- Header -->
        <header id="header">
            <h1>‚öõÔ∏è Quantum Garden</h1>
            <div id="header-controls">
                <button class="header-btn" id="save-btn">üíæ Save</button>
                <button class="header-btn" id="reset-btn" style="color: var(--quantum-red);">üóëÔ∏è Reset</button>
                <button class="header-btn" id="settings-btn">‚öôÔ∏è</button>
            </div>
        </header>

        <!-- Main Content -->
        <main id="main-content">
            <!-- Left Panel: Resources & Core -->
            <aside id="left-panel">
                <section id="resources-section">
                    <!-- Resources rendered by JS -->
                </section>
                
                <div id="coherence-bar-container" class="hidden">
                    <div class="coherence-label">
                        <span>üåÄ Coherence</span>
                        <span id="coherence-value">100%</span>
                    </div>
                    <div class="coherence-bar">
                        <div class="coherence-fill" id="coherence-fill" style="width: 100%"></div>
                    </div>
                </div>
                
                <section id="quantum-core-section">
                    <div id="quantum-core"></div>
                    <div id="core-power-display">
                        <div class="label">Click Power</div>
                        <div class="value" id="click-power-value">1</div>
                    </div>
                </section>
                
                <section id="log-section">
                    <h4>üìú Log</h4>
                    <div id="log-container"></div>
                </section>
            </aside>

            <!-- Center Panel: Garden -->
            <section id="center-panel">
                <div id="garden-header">
                    <h2>üå± Quantum Garden</h2>
                    <div id="garden-controls">
                        <!-- Auto toggles and entangle button rendered by JS -->
                    </div>
                    <span id="garden-info">Plots: <span id="plots-used">0</span>/<span id="plots-total">9</span></span>
                </div>
                <div id="garden-grid">
                    <!-- Garden plots rendered by JS -->
                </div>
                <svg id="entanglement-lines" class="entanglement-overlay"></svg>
            </section>

            <!-- Right Panel: Tabs -->
            <aside id="right-panel">
                <nav class="tab-nav">
                    <button class="tab-btn active" data-tab="generators">Plants</button>
                    <button class="tab-btn" data-tab="upgrades">Upgrades</button>
                    <button class="tab-btn" data-tab="stats">Stats</button>
                </nav>
                
                <div id="generators-tab" class="tab-content active">
                    <div id="generators-list"></div>
                </div>
                
                <div id="upgrades-tab" class="tab-content">
                    <div id="upgrades-list"></div>
                </div>
                
                <div id="stats-tab" class="tab-content">
                    <div id="stats-content"></div>
                </div>
            </aside>
        </main>
    </div>

    <!-- Plant Selection Modal -->
    <div id="plant-modal">
        <div id="plant-modal-content">
            <h3>üå± Select a Plant</h3>
            <div id="plant-options"></div>
            <button id="close-plant-modal">Cancel</button>
        </div>
    </div>

    <!-- Notification Container -->
    <div id="notification-container"></div>
    
    <!-- Global Tooltip -->
    <div id="tooltip"></div>

<script>
// ============================================
// QUANTUM GARDEN - CORE GAME ENGINE
// ============================================
// Modular architecture for maintainability
// Each system is self-contained and communicates via events

'use strict';

// ============================================
// MODULE: Utility Functions
// ============================================
const Utils = {
    // Format large numbers nicely
    formatNumber(num, decimals = 0) {
        if (num === undefined || num === null || isNaN(num)) return '0';
        
        const suffixes = ['', 'K', 'M', 'B', 'T', 'Qa', 'Qi', 'Sx', 'Sp', 'Oc', 'No', 'Dc'];
        
        if (num < 1000) {
            return decimals > 0 ? num.toFixed(decimals) : Math.floor(num).toString();
        }
        
        let tier = Math.floor(Math.log10(Math.abs(num)) / 3);
        if (tier >= suffixes.length) tier = suffixes.length - 1;
        
        const scaled = num / Math.pow(1000, tier);
        const precision = scaled >= 100 ? 0 : scaled >= 10 ? 1 : 2;
        
        return scaled.toFixed(precision) + suffixes[tier];
    },
    
    // Format time (seconds to human readable)
    formatTime(seconds) {
        if (seconds < 60) return Math.ceil(seconds) + 's';
        if (seconds < 3600) return Math.floor(seconds / 60) + 'm ' + (seconds % 60).toFixed(0) + 's';
        const hours = Math.floor(seconds / 3600);
        const mins = Math.floor((seconds % 3600) / 60);
        return hours + 'h ' + mins + 'm';
    },
    
    // Deep clone an object
    deepClone(obj) {
        return JSON.parse(JSON.stringify(obj));
    },
    
    // Simple event emitter
    createEventEmitter() {
        const listeners = {};
        return {
            on(event, callback) {
                if (!listeners[event]) listeners[event] = [];
                listeners[event].push(callback);
            },
            off(event, callback) {
                if (!listeners[event]) return;
                listeners[event] = listeners[event].filter(cb => cb !== callback);
            },
            emit(event, data) {
                if (!listeners[event]) return;
                listeners[event].forEach(callback => callback(data));
            }
        };
    },
    
    // Generate unique ID
    uid() {
        return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
};

// ============================================
// MODULE: Tooltip Manager
// ============================================
const TooltipManager = (() => {
    let tooltipEl = null;
    let currentTarget = null;
    
    function init() {
        tooltipEl = document.getElementById('tooltip');
    }
    
    function show(target, content, detail = null) {
        if (!tooltipEl) return;
        
        currentTarget = target;
        
        let html = '';
        if (typeof content === 'object') {
            html = `<div class="tooltip-title">${content.title || ''}</div>`;
            html += `<div>${content.description || ''}</div>`;
            if (content.detail) {
                html += `<div class="tooltip-detail">${content.detail}</div>`;
            }
        } else {
            html = content;
            if (detail) {
                html += `<div class="tooltip-detail">${detail}</div>`;
            }
        }
        
        tooltipEl.innerHTML = html;
        tooltipEl.classList.add('visible');
        
        // Position to the right of the target element
        positionTooltip(target);
    }
    
    function hide() {
        if (tooltipEl) {
            tooltipEl.classList.remove('visible');
        }
        currentTarget = null;
    }
    
    function positionTooltip(target) {
        if (!tooltipEl || !target) return;
        
        const padding = 10;
        const rect = target.getBoundingClientRect();
        
        // First render to get tooltip dimensions
        tooltipEl.style.left = '-9999px';
        tooltipEl.style.top = '-9999px';
        const tooltipRect = tooltipEl.getBoundingClientRect();
        
        // Default: position to the right of target, vertically centered
        let left = rect.right + padding;
        let top = rect.top + (rect.height / 2) - (tooltipRect.height / 2);
        
        // If tooltip would go off right edge, position to the left instead
        if (left + tooltipRect.width > window.innerWidth - padding) {
            left = rect.left - tooltipRect.width - padding;
        }
        
        // Keep tooltip on screen vertically
        if (top + tooltipRect.height > window.innerHeight - padding) {
            top = window.innerHeight - tooltipRect.height - padding;
        }
        if (top < padding) {
            top = padding;
        }
        
        tooltipEl.style.left = left + 'px';
        tooltipEl.style.top = top + 'px';
    }
    
    // Helper to attach tooltip to elements
    function attach(element, content, detailFn = null) {
        element.addEventListener('mouseenter', () => {
            const detail = detailFn ? detailFn() : null;
            show(element, content, detail);
        });
        element.addEventListener('mouseleave', hide);
    }
    
    return { init, show, hide, attach };
})();

// ============================================
// MODULE: Resource Gain Tracker (floating +X on left panel)
// ============================================
const ResourceGainTracker = (() => {
    const pendingGains = {}; // { resourceId: { amount: X, timer: Y, element: Z } }
    const DISPLAY_TIME = 3000; // 3 seconds before fade
    
    function addGain(resourceId, amount) {
        if (!pendingGains[resourceId]) {
            pendingGains[resourceId] = { amount: 0, timer: null, element: null };
        }
        
        const gain = pendingGains[resourceId];
        gain.amount += amount;
        
        // Clear existing fade timer
        if (gain.timer) {
            clearTimeout(gain.timer);
        }
        
        // Update or create the display element
        updateDisplay(resourceId);
        
        // Set new fade timer
        gain.timer = setTimeout(() => fadeOut(resourceId), DISPLAY_TIME);
    }
    
    function updateDisplay(resourceId) {
        const gain = pendingGains[resourceId];
        const resourceItem = document.querySelector(`.resource-item[data-resource="${resourceId}"]`);
        
        if (!resourceItem) return;
        
        // Create element if needed
        if (!gain.element) {
            gain.element = document.createElement('div');
            gain.element.className = 'resource-gain';
            resourceItem.appendChild(gain.element);
        }
        
        // Remove fading class if re-triggered
        gain.element.classList.remove('fading');
        
        // Update text
        const sign = gain.amount >= 0 ? '+' : '';
        gain.element.textContent = sign + Utils.formatNumber(gain.amount, 0);
        
        // Re-trigger animation
        gain.element.style.animation = 'none';
        gain.element.offsetHeight; // Force reflow
        gain.element.style.animation = '';
    }
    
    function fadeOut(resourceId) {
        const gain = pendingGains[resourceId];
        if (!gain || !gain.element) return;
        
        gain.element.classList.add('fading');
        
        // Remove after fade animation
        setTimeout(() => {
            if (gain.element && gain.element.parentNode) {
                gain.element.remove();
            }
            gain.element = null;
            gain.amount = 0;
            gain.timer = null;
        }, 500);
    }
    
    // Show floating harvest numbers at a position
    function showHarvestFloat(plotIndex, yields) {
        const plotEl = document.querySelector(`.garden-plot[data-index="${plotIndex}"]`);
        if (!plotEl) return;
        
        let yOffset = 0;
        
        Object.entries(yields).forEach(([resourceId, amount], i) => {
            const data = GameData.resources[resourceId];
            if (!data) return;
            
            const floater = document.createElement('div');
            floater.className = 'harvest-float';
            floater.textContent = `${data.icon}+${Utils.formatNumber(amount, 0)}`;
            floater.style.left = '50%';
            floater.style.top = (40 + yOffset) + '%';
            floater.style.transform = 'translateX(-50%)';
            floater.style.animationDelay = (i * 0.1) + 's';
            
            plotEl.appendChild(floater);
            
            yOffset += 15;
            
            // Also add to left panel tracker
            addGain(resourceId, amount);
            
            // Remove after animation
            setTimeout(() => floater.remove(), 1200 + i * 100);
        });
    }
    
    return { addGain, showHarvestFloat };
})();

// ============================================
// MODULE: Game Data Definitions
// ============================================
const GameData = {
    resources: {
        energy: {
            id: 'energy',
            name: 'Quantum Energy',
            icon: '‚ö°',
            color: 'text-energy',
            baseAmount: 0,
            unlocked: true,
            description: 'The fundamental force of the quantum garden'
        },
        seeds: {
            id: 'seeds',
            name: 'Seeds',
            icon: 'üå±',
            color: 'text-seeds',
            baseAmount: 0,
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 50 },
            description: 'Required to plant in your garden'
        },
        time: {
            id: 'time',
            name: 'Time Crystals',
            icon: '‚è≥',
            color: 'text-time',
            baseAmount: 0,
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 500 },
            description: 'Crystallized moments of temporal energy'
        },
        knowledge: {
            id: 'knowledge',
            name: 'Quantum Knowledge',
            icon: 'üìö',
            color: 'text-knowledge',
            baseAmount: 0,
            unlocked: false,
            unlockAt: { resource: 'time', amount: 100 },
            description: 'Understanding of quantum phenomena'
        },
        coherence: {
            id: 'coherence',
            name: 'Coherence',
            icon: 'üåÄ',
            color: 'text-coherence',
            baseAmount: 100,
            maxAmount: 100,
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 50 },
            description: 'The stability of your quantum state. Depletes as reality becomes classical.'
        },
        entanglement: {
            id: 'entanglement',
            name: 'Entanglement Threads',
            icon: 'üîó',
            color: 'text-entanglement',
            baseAmount: 0,
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 100 },
            description: 'Quantum links between plants. Harvest carefully.'
        },
        fragments: {
            id: 'fragments',
            name: 'Reality Fragments',
            icon: 'üí†',
            color: 'text-fragments',
            baseAmount: 0,
            unlocked: false,
            isPermanent: true, // Survives reality collapse
            description: 'Shards of collapsed realities. Persist across all timelines.'
        }
    },
    
    generators: {
        quantumLily: {
            id: 'quantumLily',
            name: 'Quantum Lily',
            icon: 'üå∏',
            description: 'A delicate flower that absorbs ambient quantum fluctuations',
            baseCost: { energy: 15 },
            costMultiplier: 1.15,
            production: { energy: 0.5 },
            unlocked: true,
            gardenPlantable: true,
            growthTime: 10, // seconds
            harvestYield: { energy: 5, seeds: 1 }
        },
        timeTulip: {
            id: 'timeTulip',
            name: 'Time Tulip',
            icon: 'üå∑',
            description: 'Petals that shimmer with temporal energy',
            baseCost: { energy: 100, seeds: 5 },
            costMultiplier: 1.18,
            production: { energy: 2, time: 0.1 },
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 75 },
            gardenPlantable: true,
            growthTime: 30,
            harvestYield: { energy: 20, time: 3, seeds: 2 }
        },
        energyRose: {
            id: 'energyRose',
            name: 'Energy Rose',
            icon: 'üåπ',
            description: 'Radiates concentrated quantum energy',
            baseCost: { energy: 500, seeds: 15 },
            costMultiplier: 1.2,
            production: { energy: 10 },
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 400 },
            gardenPlantable: true,
            growthTime: 60,
            harvestYield: { energy: 100, seeds: 3 }
        },
        dimensionDaisy: {
            id: 'dimensionDaisy',
            name: 'Dimension Daisy',
            icon: 'üåº',
            description: 'Blooms across multiple realities simultaneously',
            baseCost: { energy: 2000, time: 50 },
            costMultiplier: 1.22,
            production: { energy: 25, knowledge: 0.1 },
            unlocked: false,
            unlockAt: { resource: 'time', amount: 30 },
            gardenPlantable: true,
            growthTime: 120,
            harvestYield: { energy: 200, knowledge: 10, entanglement: 1, seeds: 5 }
        },
        voidViolet: {
            id: 'voidViolet',
            name: 'Void Violet',
            icon: 'üíú',
            description: 'Draws power from the space between spaces. Produces entanglement threads.',
            baseCost: { energy: 10000, knowledge: 25 },
            costMultiplier: 1.25,
            production: { energy: 100, time: 1, entanglement: 0.05 },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 20 },
            gardenPlantable: true,
            growthTime: 300,
            harvestYield: { energy: 1000, time: 50, entanglement: 2, seeds: 10 }
        }
    },
    
    upgrades: {
        // Click Power Upgrades
        efficientClicking: {
            id: 'efficientClicking',
            name: 'Quantum Resonance',
            icon: '‚ú®',
            description: 'Double your click power',
            cost: { energy: 50 },
            effect: { clickPowerMultiplier: 2 },
            unlocked: true,
            purchased: false
        },
        improvedClicking: {
            id: 'improvedClicking',
            name: 'Harmonic Amplification',
            icon: 'üîä',
            description: 'Triple your click power',
            cost: { energy: 500 },
            effect: { clickPowerMultiplier: 3 },
            requires: ['efficientClicking'],
            unlocked: false,
            purchased: false
        },
        quantumClicking: {
            id: 'quantumClicking',
            name: 'Quantum Superposition Click',
            icon: '‚öõÔ∏è',
            description: 'Your clicks exist in multiple states. +5 base click power.',
            cost: { energy: 2000, time: 20 },
            effect: { clickPowerBonus: 5 },
            requires: ['improvedClicking'],
            unlocked: false,
            purchased: false
        },
        
        // Seed & Garden Upgrades
        seedProduction: {
            id: 'seedProduction',
            name: 'Seed Synthesis',
            icon: 'üå±',
            description: 'Unlock seeds and gain 5 to start. Quantum Lilies now produce seeds.',
            cost: { energy: 30 },
            effect: { unlockSeeds: true, grantSeeds: 5 },
            unlocked: true,
            purchased: false
        },
        largerGarden: {
            id: 'largerGarden',
            name: 'Garden Expansion',
            icon: 'üåø',
            description: 'Expand your garden to 16 plots',
            cost: { energy: 200, seeds: 20 },
            effect: { gardenSize: 16 },
            requires: ['seedProduction'],
            unlocked: false,
            purchased: false
        },
        fasterGrowth: {
            id: 'fasterGrowth',
            name: 'Temporal Growth',
            icon: '‚è±Ô∏è',
            description: 'Plants grow 25% faster',
            cost: { energy: 1000, time: 15 },
            effect: { growthSpeedMultiplier: 1.25 },
            requires: ['seedProduction'],
            unlocked: false,
            purchased: false
        },
        
        // Production Upgrades
        quantumLilyBoost: {
            id: 'quantumLilyBoost',
            name: 'Lily Enhancement',
            icon: 'üå∏',
            description: 'Quantum Lilies produce 50% more energy',
            cost: { energy: 100 },
            effect: { generatorBoost: { quantumLily: 1.5 } },
            unlocked: true,
            purchased: false
        },
        timeTulipBoost: {
            id: 'timeTulipBoost',
            name: 'Temporal Bloom',
            icon: 'üå∑',
            description: 'Time Tulips produce double time crystals',
            cost: { energy: 750, time: 10 },
            effect: { generatorBoost: { timeTulip: 2 } },
            requires: ['quantumLilyBoost'],
            unlocked: false,
            purchased: false
        },
        
        // Time Unlocks
        unlockTime: {
            id: 'unlockTime',
            name: 'Temporal Awareness',
            icon: '‚è≥',
            description: 'Unlock Time Crystals resource',
            cost: { energy: 250 },
            effect: { unlockResource: 'time' },
            unlocked: false,
            unlockAt: { resource: 'energy', amount: 200 },
            purchased: false
        },
        
        // Observer upgrades
        keenObserver: {
            id: 'keenObserver',
            name: 'Keen Observer',
            icon: 'üëÅÔ∏è',
            description: 'Plants grow 50% faster while you watch them',
            cost: { energy: 300, knowledge: 10 },
            effect: { observerBonus: 1.5 },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 5 },
            purchased: false
        },
        
        // Quantum upgrades
        superpositionMastery: {
            id: 'superpositionMastery',
            name: 'Superposition Mastery',
            icon: 'üé≠',
            description: 'Harvest yields have higher variance but better average outcomes',
            cost: { energy: 1500, knowledge: 30 },
            effect: { yieldVarianceBonus: 0.25 },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 20 },
            purchased: false
        },
        coherenceStabilizer: {
            id: 'coherenceStabilizer',
            name: 'Coherence Stabilizer',
            icon: 'üåÄ',
            description: 'Coherence decays 50% slower',
            cost: { energy: 5000, time: 100 },
            effect: { coherenceDecayReduction: 0.5 },
            requires: ['superpositionMastery'],
            unlocked: false,
            purchased: false
        },
        
        // Entanglement upgrades
        entanglementBasics: {
            id: 'entanglementBasics',
            name: 'Quantum Entanglement',
            icon: 'üîó',
            description: 'Unlock the ability to entangle plants. Entangled plants share growth and harvests.',
            cost: { energy: 2000, knowledge: 50 },
            effect: { unlockEntanglement: true },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 40 },
            purchased: false
        },
        deepEntanglement: {
            id: 'deepEntanglement',
            name: 'Deep Entanglement',
            icon: '‚õìÔ∏è',
            description: 'Entangled plants boost each other\'s yield by 25%',
            cost: { energy: 10000, entanglement: 10 },
            effect: { entanglementYieldBonus: 0.25 },
            requires: ['entanglementBasics'],
            unlocked: false,
            purchased: false
        },
        
        // Automation upgrades
        autoHarvest: {
            id: 'autoHarvest',
            name: 'Quantum Auto-Harvester',
            icon: 'ü§ñ',
            description: 'Mature plants are automatically harvested every 10 seconds',
            cost: { energy: 15000, time: 200, knowledge: 100 },
            effect: { autoHarvest: true },
            unlocked: false,
            unlockAt: { resource: 'time', amount: 150 },
            purchased: false
        },
        autoPlant: {
            id: 'autoPlant',
            name: 'Quantum Auto-Planter',
            icon: 'üå±',
            description: 'Empty plots automatically plant your most efficient seed',
            cost: { energy: 25000, time: 300, knowledge: 150 },
            effect: { autoPlant: true },
            requires: ['autoHarvest'],
            unlocked: false,
            purchased: false
        },
        
        // Late game multipliers
        quantumResonance: {
            id: 'quantumResonance',
            name: 'Quantum Resonance Field',
            icon: 'üì°',
            description: 'All generators produce 50% more',
            cost: { energy: 50000, knowledge: 200 },
            effect: { globalProductionMultiplier: 1.5 },
            unlocked: false,
            unlockAt: { resource: 'knowledge', amount: 150 },
            purchased: false
        },
        
        // Garden expansions
        largerGarden2: {
            id: 'largerGarden2',
            name: 'Garden Expansion II',
            icon: 'üå≥',
            description: 'Expand your garden to 25 plots',
            cost: { energy: 5000, seeds: 50, time: 50 },
            effect: { gardenSize: 25 },
            requires: ['largerGarden'],
            unlocked: false,
            purchased: false
        },
        largerGarden3: {
            id: 'largerGarden3',
            name: 'Infinite Garden',
            icon: 'üåå',
            description: 'Expand your garden to 36 plots',
            cost: { energy: 25000, seeds: 100, time: 150 },
            effect: { gardenSize: 36 },
            requires: ['largerGarden2'],
            unlocked: false,
            purchased: false
        }
    },
    
    // Initial game state template
    initialState: {
        resources: {
            energy: { amount: 0, total: 0, rate: 0 },
            seeds: { amount: 0, total: 0, rate: 0 },
            time: { amount: 0, total: 0, rate: 0 },
            knowledge: { amount: 0, total: 0, rate: 0 },
            coherence: { amount: 100, total: 100, rate: 0 },
            entanglement: { amount: 0, total: 0, rate: 0 },
            fragments: { amount: 0, total: 0, rate: 0 }
        },
        generators: {},
        upgrades: {},
        achievements: {},
        garden: {
            size: 9, // 3x3 starting
            plots: []
        },
        stats: {
            totalClicks: 0,
            totalEnergyEarned: 0,
            totalPlantsHarvested: 0,
            quantumEventsWitnessed: 0,
            quantumBursts: 0,
            plantsEntangled: 0,
            highCoherenceTime: 0,
            clicksWithManyGens: 0,
            playTime: 0,
            startDate: Date.now()
        },
        settings: {
            notificationsEnabled: true,
            particlesEnabled: true,
            autosaveInterval: 30, // seconds
            autoHarvestEnabled: true,
            autoPlantEnabled: true
        },
        meta: {
            version: '1.0.0',
            lastSave: null
        }
    },
    
    // Achievements
    achievements: {
        // Click achievements
        firstClick: {
            id: 'firstClick',
            name: 'Quantum Awakening',
            description: 'Make your first click',
            icon: 'üëÜ',
            check: () => StateManager.get('stats.totalClicks') >= 1
        },
        click100: {
            id: 'click100',
            name: 'Probability Manipulator',
            description: 'Click 100 times',
            icon: '‚úã',
            check: () => StateManager.get('stats.totalClicks') >= 100
        },
        click1000: {
            id: 'click1000',
            name: 'Wave Function Collapser',
            description: 'Click 1,000 times',
            icon: 'üñêÔ∏è',
            check: () => StateManager.get('stats.totalClicks') >= 1000
        },
        
        // Energy achievements
        energy100: {
            id: 'energy100',
            name: 'Spark of Creation',
            description: 'Accumulate 100 Quantum Energy',
            icon: '‚ö°',
            check: () => StateManager.get('resources.energy.total') >= 100
        },
        energy10k: {
            id: 'energy10k',
            name: 'Power Surge',
            description: 'Accumulate 10,000 Quantum Energy',
            icon: 'üí´',
            check: () => StateManager.get('resources.energy.total') >= 10000
        },
        energy1m: {
            id: 'energy1m',
            name: 'Supernova',
            description: 'Accumulate 1,000,000 Quantum Energy',
            icon: 'üåü',
            check: () => StateManager.get('resources.energy.total') >= 1000000
        },
        
        // Garden achievements
        firstHarvest: {
            id: 'firstHarvest',
            name: 'First Bloom',
            description: 'Harvest your first plant',
            icon: 'üå∏',
            check: () => StateManager.get('stats.totalPlantsHarvested') >= 1
        },
        harvest10: {
            id: 'harvest10',
            name: 'Green Thumb',
            description: 'Harvest 10 plants',
            icon: 'üåø',
            check: () => StateManager.get('stats.totalPlantsHarvested') >= 10
        },
        harvest100: {
            id: 'harvest100',
            name: 'Master Gardener',
            description: 'Harvest 100 plants',
            icon: 'üë®‚Äçüåæ',
            check: () => StateManager.get('stats.totalPlantsHarvested') >= 100
        },
        fullGarden: {
            id: 'fullGarden',
            name: 'No Empty Plots',
            description: 'Fill every garden plot with a growing plant',
            icon: 'üè°',
            check: () => {
                const plots = StateManager.get('garden.plots') || [];
                const size = StateManager.get('garden.size') || 9;
                return plots.length >= size && plots.every(p => p.plant !== null);
            }
        },
        
        // Generator achievements
        firstGenerator: {
            id: 'firstGenerator',
            name: 'Automation Begins',
            description: 'Purchase your first generator',
            icon: '‚öôÔ∏è',
            check: () => {
                return Object.keys(GameData.generators).some(id => 
                    GeneratorManager.getOwned(id) >= 1
                );
            }
        },
        tenLilies: {
            id: 'tenLilies',
            name: 'Lily Pad',
            description: 'Own 10 Quantum Lilies',
            icon: 'üå∏',
            check: () => GeneratorManager.getOwned('quantumLily') >= 10
        },
        allGenerators: {
            id: 'allGenerators',
            name: 'Biodiversity',
            description: 'Own at least one of every plant type',
            icon: 'üåà',
            check: () => {
                return Object.keys(GameData.generators).every(id => 
                    GeneratorManager.getOwned(id) >= 1
                );
            }
        },
        
        // Quantum achievements
        firstEvent: {
            id: 'firstEvent',
            name: 'Quantum Observer',
            description: 'Witness your first quantum event',
            icon: 'üëÅÔ∏è',
            check: () => StateManager.get('stats.quantumEventsWitnessed') >= 1
        },
        tenEvents: {
            id: 'tenEvents',
            name: 'Reality Bender',
            description: 'Witness 10 quantum events',
            icon: 'üîÆ',
            check: () => StateManager.get('stats.quantumEventsWitnessed') >= 10
        },
        lowCoherence: {
            id: 'lowCoherence',
            name: 'Edge of Classical',
            description: 'Let coherence drop below 10%',
            icon: '‚ö†Ô∏è',
            check: () => {
                const coherence = ResourceManager.get('coherence');
                return ResourceManager.isUnlocked('coherence') && coherence < 10;
            }
        },
        
        // Secret achievements
        speedrunner: {
            id: 'speedrunner',
            name: 'Speedrunner',
            description: 'Reach 1000 energy in under 5 minutes',
            icon: 'üèÉ',
            secret: true,
            check: () => {
                const playTime = StateManager.get('stats.playTime') || 0;
                const energy = StateManager.get('resources.energy.total') || 0;
                return energy >= 1000 && playTime < 300;
            }
        },
        patient: {
            id: 'patient',
            name: 'Patience of a Physicist',
            description: 'Play for over an hour',
            icon: '‚è∞',
            check: () => StateManager.get('stats.playTime') >= 3600
        },
        nightOwl: {
            id: 'nightOwl',
            name: 'Night Owl',
            description: 'Play between midnight and 4 AM',
            icon: 'ü¶â',
            secret: true,
            check: () => {
                const hour = new Date().getHours();
                return hour >= 0 && hour < 4;
            }
        },
        
        // New coherence achievements
        coherenceMaster: {
            id: 'coherenceMaster',
            name: 'Coherence Master',
            description: 'Maintain 90%+ coherence for 5 minutes with 50+ generators',
            icon: 'üåÄ',
            check: () => {
                const generators = Object.keys(GameData.generators).reduce((sum, id) => 
                    sum + GeneratorManager.getOwned(id), 0);
                const coherence = ResourceManager.get('coherence') || 0;
                const highTime = StateManager.get('stats.highCoherenceTime') || 0;
                return generators >= 50 && coherence >= 90 && highTime >= 300;
            }
        },
        zeroCoherence: {
            id: 'zeroCoherence',
            name: 'Completely Classical',
            description: 'Let coherence reach exactly 0%',
            icon: 'üìâ',
            check: () => {
                const coherence = ResourceManager.get('coherence');
                return ResourceManager.isUnlocked('coherence') && coherence <= 0;
            }
        },
        
        // Quantum burst achievements
        firstBurst: {
            id: 'firstBurst',
            name: 'Quantum Surge',
            description: 'Trigger your first Quantum Burst',
            icon: '‚ö°',
            check: () => StateManager.get('stats.quantumBursts') >= 1
        },
        tenBursts: {
            id: 'tenBursts',
            name: 'Chain Reaction',
            description: 'Trigger 10 Quantum Bursts',
            icon: 'üí•',
            check: () => StateManager.get('stats.quantumBursts') >= 10
        },
        
        // Entanglement achievements
        firstEntangle: {
            id: 'firstEntangle',
            name: 'Spooky Action',
            description: 'Entangle two plants together',
            icon: 'üîó',
            check: () => StateManager.get('stats.plantsEntangled') >= 2
        },
        entangleFive: {
            id: 'entangleFive',
            name: 'Quantum Network',
            description: 'Have 5 pairs of entangled plants simultaneously',
            icon: 'üï∏Ô∏è',
            check: () => {
                const plots = StateManager.get('garden.plots') || [];
                const pairs = plots.filter(p => p.entangledWith !== null).length / 2;
                return pairs >= 5;
            }
        },
        
        // Late-game clicking achievement
        clickerReborn: {
            id: 'clickerReborn',
            name: 'Return to Basics',
            description: 'Click 100 times while owning 100+ generators',
            icon: 'üîÑ',
            secret: true,
            check: () => {
                const generators = Object.keys(GameData.generators).reduce((sum, id) => 
                    sum + GeneratorManager.getOwned(id), 0);
                const clicks = StateManager.get('stats.clicksWithManyGens') || 0;
                return generators >= 100 && clicks >= 100;
            }
        },
        
        // Big numbers
        energy100m: {
            id: 'energy100m',
            name: 'Cosmic Power',
            description: 'Accumulate 100,000,000 Quantum Energy',
            icon: 'üåå',
            check: () => StateManager.get('resources.energy.total') >= 100000000
        },
        harvest1000: {
            id: 'harvest1000',
            name: 'Legendary Farmer',
            description: 'Harvest 1,000 plants',
            icon: 'üèÜ',
            check: () => StateManager.get('stats.totalPlantsHarvested') >= 1000
        }
    }
};

// ============================================
// MODULE: Game State Manager
// ============================================
const StateManager = (() => {
    let state = null;
    const events = Utils.createEventEmitter();
    
    function initialize() {
        // Try to load saved game
        const saved = localStorage.getItem('quantumGarden_save');
        if (saved) {
            try {
                state = JSON.parse(saved);
                // Migrate if needed
                migrateState();
                events.emit('loaded', state);
                return true;
            } catch (e) {
                console.error('Failed to load save:', e);
            }
        }
        
        // Create new game
        state = Utils.deepClone(GameData.initialState);
        
        // Initialize generators owned count
        Object.keys(GameData.generators).forEach(id => {
            state.generators[id] = { owned: 0 };
        });
        
        // Initialize upgrades purchased state
        Object.keys(GameData.upgrades).forEach(id => {
            state.upgrades[id] = { purchased: false };
        });
        
        // Initialize achievements
        Object.keys(GameData.achievements).forEach(id => {
            state.achievements[id] = false;
        });
        
        // Initialize garden plots
        for (let i = 0; i < state.garden.size; i++) {
            state.garden.plots.push({ plant: null, progress: 0, plantedAt: null });
        }
        
        // Set initial coherence
        state.resources.coherence = { amount: 100, total: 100, rate: 0 };
        
        events.emit('initialized', state);
        return false;
    }
    
    function migrateState() {
        // Handle version migrations here
        const currentVersion = '1.0.0';
        if (!state.meta) state.meta = { version: currentVersion };
        
        // Ensure all expected properties exist
        if (!state.settings) state.settings = GameData.initialState.settings;
        if (!state.stats) state.stats = GameData.initialState.stats;
        if (!state.achievements) state.achievements = {};
        
        // Ensure new settings exist for existing saves
        if (state.settings.autoHarvestEnabled === undefined) {
            state.settings.autoHarvestEnabled = true;
        }
        if (state.settings.autoPlantEnabled === undefined) {
            state.settings.autoPlantEnabled = true;
        }
        
        // Ensure new resources exist
        if (!state.resources.coherence) {
            state.resources.coherence = { amount: 100, total: 100, rate: 0 };
        }
        if (!state.resources.entanglement) {
            state.resources.entanglement = { amount: 0, total: 0, rate: 0 };
        }
        if (!state.resources.fragments) {
            state.resources.fragments = { amount: 0, total: 0, rate: 0 };
        }
    }
    
    function get(path) {
        if (!path) return state;
        const parts = path.split('.');
        let current = state;
        for (const part of parts) {
            if (current === undefined) return undefined;
            current = current[part];
        }
        return current;
    }
    
    function set(path, value) {
        const parts = path.split('.');
        let current = state;
        for (let i = 0; i < parts.length - 1; i++) {
            if (current[parts[i]] === undefined) current[parts[i]] = {};
            current = current[parts[i]];
        }
        current[parts[parts.length - 1]] = value;
        events.emit('changed', { path, value });
    }
    
    function save() {
        state.meta.lastSave = Date.now();
        localStorage.setItem('quantumGarden_save', JSON.stringify(state));
        events.emit('saved');
        return true;
    }
    
    let isResetting = false;
    
    function reset() {
        isResetting = true;
        localStorage.removeItem('quantumGarden_save');
        initialize();
        events.emit('reset');
    }
    
    function canSave() {
        return !isResetting;
    }
    
    function exportSave() {
        return btoa(JSON.stringify(state));
    }
    
    function importSave(data) {
        try {
            state = JSON.parse(atob(data));
            migrateState();
            save();
            events.emit('imported', state);
            return true;
        } catch (e) {
            console.error('Failed to import save:', e);
            return false;
        }
    }
    
    return {
        initialize,
        get,
        set,
        save,
        reset,
        canSave,
        exportSave,
        importSave,
        on: events.on,
        off: events.off,
        emit: events.emit
    };
})();

// ============================================
// MODULE: Resource Manager
// ============================================
const ResourceManager = (() => {
    const events = Utils.createEventEmitter();
    
    function add(resourceId, amount) {
        const current = StateManager.get(`resources.${resourceId}.amount`) || 0;
        const newAmount = current + amount;
        StateManager.set(`resources.${resourceId}.amount`, newAmount);
        
        if (amount > 0) {
            const total = StateManager.get(`resources.${resourceId}.total`) || 0;
            StateManager.set(`resources.${resourceId}.total`, total + amount);
        }
        
        events.emit('changed', { resourceId, amount: newAmount, delta: amount });
        checkUnlocks();
    }
    
    function spend(resourceId, amount) {
        const current = StateManager.get(`resources.${resourceId}.amount`) || 0;
        if (current < amount) return false;
        StateManager.set(`resources.${resourceId}.amount`, current - amount);
        events.emit('spent', { resourceId, amount });
        return true;
    }
    
    function canAfford(costs) {
        for (const [resourceId, amount] of Object.entries(costs)) {
            const current = StateManager.get(`resources.${resourceId}.amount`) || 0;
            if (current < amount) return false;
        }
        return true;
    }
    
    function spendMultiple(costs) {
        if (!canAfford(costs)) return false;
        for (const [resourceId, amount] of Object.entries(costs)) {
            spend(resourceId, amount);
        }
        return true;
    }
    
    function get(resourceId) {
        return StateManager.get(`resources.${resourceId}.amount`) || 0;
    }
    
    function getRate(resourceId) {
        return StateManager.get(`resources.${resourceId}.rate`) || 0;
    }
    
    function setRate(resourceId, rate) {
        StateManager.set(`resources.${resourceId}.rate`, rate);
    }
    
    function isUnlocked(resourceId) {
        const data = GameData.resources[resourceId];
        if (!data) return false;
        if (data.unlocked) return true;
        
        // Check unlock condition
        if (data.unlockAt) {
            const checkAmount = StateManager.get(`resources.${data.unlockAt.resource}.total`) || 0;
            return checkAmount >= data.unlockAt.amount;
        }
        return false;
    }
    
    function checkUnlocks() {
        Object.keys(GameData.resources).forEach(id => {
            if (!GameData.resources[id].unlocked && isUnlocked(id)) {
                GameData.resources[id].unlocked = true;
                events.emit('unlocked', id);
            }
        });
    }
    
    return {
        add,
        spend,
        canAfford,
        spendMultiple,
        get,
        getRate,
        setRate,
        isUnlocked,
        on: events.on
    };
})();

// ============================================
// MODULE: Generator Manager
// ============================================
const GeneratorManager = (() => {
    const events = Utils.createEventEmitter();
    
    function getOwned(generatorId) {
        return StateManager.get(`generators.${generatorId}.owned`) || 0;
    }
    
    function getCost(generatorId) {
        const data = GameData.generators[generatorId];
        const owned = getOwned(generatorId);
        const costs = {};
        
        for (const [resource, baseCost] of Object.entries(data.baseCost)) {
            costs[resource] = Math.floor(baseCost * Math.pow(data.costMultiplier, owned));
        }
        
        return costs;
    }
    
    function buy(generatorId) {
        const costs = getCost(generatorId);
        
        if (!ResourceManager.spendMultiple(costs)) {
            return false;
        }
        
        const owned = getOwned(generatorId);
        StateManager.set(`generators.${generatorId}.owned`, owned + 1);
        
        events.emit('bought', { generatorId, owned: owned + 1 });
        calculateProduction();
        return true;
    }
    
    function isUnlocked(generatorId) {
        const data = GameData.generators[generatorId];
        if (!data) return false;
        if (data.unlocked) return true;
        
        if (data.unlockAt) {
            const checkAmount = StateManager.get(`resources.${data.unlockAt.resource}.total`) || 0;
            if (checkAmount >= data.unlockAt.amount) {
                data.unlocked = true;
                return true;
            }
        }
        return false;
    }
    
    function getProduction(generatorId) {
        const data = GameData.generators[generatorId];
        const owned = getOwned(generatorId);
        if (owned === 0) return {};
        
        const production = {};
        for (const [resource, baseRate] of Object.entries(data.production)) {
            let rate = baseRate * owned;
            
            // Apply upgrade boosts
            Object.values(GameData.upgrades).forEach(upgrade => {
                if (StateManager.get(`upgrades.${upgrade.id}.purchased`) && upgrade.effect?.generatorBoost?.[generatorId]) {
                    rate *= upgrade.effect.generatorBoost[generatorId];
                }
            });
            
            // Apply global production multiplier
            if (StateManager.get('upgrades.quantumResonance.purchased')) {
                rate *= 1.5;
            }
            
            // COHERENCE EFFECT: Low coherence reduces generator output
            // At 100% coherence: full production
            // At 50% coherence: 90% production  
            // At 0% coherence: 60% production
            const coherence = ResourceManager.get('coherence') || 0;
            const coherenceMultiplier = 0.6 + (coherence / 100) * 0.4;
            rate *= coherenceMultiplier;
            
            production[resource] = rate;
        }
        
        return production;
    }
    
    function calculateProduction() {
        // Reset rates
        Object.keys(GameData.resources).forEach(id => {
            ResourceManager.setRate(id, 0);
        });
        
        // Calculate from generators
        Object.keys(GameData.generators).forEach(id => {
            const prod = getProduction(id);
            for (const [resource, rate] of Object.entries(prod)) {
                const current = ResourceManager.getRate(resource);
                ResourceManager.setRate(resource, current + rate);
            }
        });
        
        events.emit('productionUpdated');
    }
    
    return {
        getOwned,
        getCost,
        buy,
        isUnlocked,
        getProduction,
        calculateProduction,
        on: events.on
    };
})();

// ============================================
// MODULE: Upgrade Manager
// ============================================
const UpgradeManager = (() => {
    const events = Utils.createEventEmitter();
    
    function isPurchased(upgradeId) {
        return StateManager.get(`upgrades.${upgradeId}.purchased`) || false;
    }
    
    function isUnlocked(upgradeId) {
        const data = GameData.upgrades[upgradeId];
        if (!data) return false;
        if (isPurchased(upgradeId)) return true;
        if (data.unlocked) return true;
        
        // Check unlock condition
        if (data.unlockAt) {
            const checkAmount = StateManager.get(`resources.${data.unlockAt.resource}.total`) || 0;
            if (checkAmount >= data.unlockAt.amount) {
                return true;
            }
        }
        
        // Check requirements
        if (data.requires) {
            for (const reqId of data.requires) {
                if (!isPurchased(reqId)) return false;
            }
            return true;
        }
        
        return data.unlocked;
    }
    
    function canBuy(upgradeId) {
        if (isPurchased(upgradeId)) return false;
        if (!isUnlocked(upgradeId)) return false;
        
        const data = GameData.upgrades[upgradeId];
        return ResourceManager.canAfford(data.cost);
    }
    
    function buy(upgradeId) {
        if (!canBuy(upgradeId)) return false;
        
        const data = GameData.upgrades[upgradeId];
        if (!ResourceManager.spendMultiple(data.cost)) return false;
        
        StateManager.set(`upgrades.${upgradeId}.purchased`, true);
        applyEffect(upgradeId);
        
        events.emit('purchased', upgradeId);
        return true;
    }
    
    function applyEffect(upgradeId) {
        const data = GameData.upgrades[upgradeId];
        if (!data.effect) return;
        
        const effect = data.effect;
        
        // Handle unlock seeds
        if (effect.unlockSeeds) {
            GameData.resources.seeds.unlocked = true;
        }
        
        // Handle grant seeds
        if (effect.grantSeeds) {
            ResourceManager.add('seeds', effect.grantSeeds);
        }
        
        // Handle garden size
        if (effect.gardenSize) {
            GardenManager.expandTo(effect.gardenSize);
        }
        
        // Handle resource unlocks
        if (effect.unlockResource) {
            GameData.resources[effect.unlockResource].unlocked = true;
        }
        
        // Recalculate production for multiplier effects
        GeneratorManager.calculateProduction();
    }
    
    function getClickPower() {
        let power = 1;
        let bonus = 0;
        
        Object.values(GameData.upgrades).forEach(upgrade => {
            if (StateManager.get(`upgrades.${upgrade.id}.purchased`)) {
                if (upgrade.effect?.clickPowerMultiplier) {
                    power *= upgrade.effect.clickPowerMultiplier;
                }
                if (upgrade.effect?.clickPowerBonus) {
                    bonus += upgrade.effect.clickPowerBonus;
                }
            }
        });
        
        return power + bonus;
    }
    
    function getGrowthMultiplier() {
        let mult = 1;
        
        Object.values(GameData.upgrades).forEach(upgrade => {
            if (StateManager.get(`upgrades.${upgrade.id}.purchased`) && upgrade.effect?.growthSpeedMultiplier) {
                mult *= upgrade.effect.growthSpeedMultiplier;
            }
        });
        
        return mult;
    }
    
    return {
        isPurchased,
        isUnlocked,
        canBuy,
        buy,
        getClickPower,
        getGrowthMultiplier,
        on: events.on
    };
})();

// ============================================
// MODULE: Garden Manager
// ============================================
const GardenManager = (() => {
    const events = Utils.createEventEmitter();
    let entanglementMode = false;
    let entanglementSource = null;
    let autoHarvestTimer = 0;
    let autoPlantTimer = 0;
    
    function getPlot(index) {
        return StateManager.get(`garden.plots.${index}`);
    }
    
    function getSize() {
        return StateManager.get('garden.size') || 9;
    }
    
    function plant(plotIndex, generatorId) {
        const plot = getPlot(plotIndex);
        if (plot.plant) return false;
        
        // Check if we have seeds
        if (ResourceManager.get('seeds') < 1) {
            events.emit('error', 'Not enough seeds!');
            return false;
        }
        
        ResourceManager.spend('seeds', 1);
        
        // Preserve autoPlantType when planting
        StateManager.set(`garden.plots.${plotIndex}`, {
            plant: generatorId,
            progress: 0,
            plantedAt: Date.now(),
            entangledWith: null,
            autoPlantType: plot.autoPlantType || null
        });
        
        events.emit('planted', { plotIndex, generatorId });
        return true;
    }
    
    function harvest(plotIndex) {
        const plot = getPlot(plotIndex);
        if (!plot.plant || plot.progress < 1) return false;
        
        const data = GameData.generators[plot.plant];
        
        // Use quantum collapsed yield instead of fixed yield
        let actualYield = QuantumMechanics.collapseYield(plot.plant);
        
        // Apply entanglement bonus if applicable
        if (plot.entangledWith !== null && UpgradeManager.isPurchased('deepEntanglement')) {
            for (const resource in actualYield) {
                actualYield[resource] = Math.floor(actualYield[resource] * 1.25);
            }
        }
        
        // Grant harvest yield
        for (const [resource, amount] of Object.entries(actualYield)) {
            ResourceManager.add(resource, amount);
        }
        
        // Handle entangled partner
        const partnerId = plot.entangledWith;
        let partnerYield = null;
        
        if (partnerId !== null) {
            const partner = getPlot(partnerId);
            if (partner && partner.plant && partner.entangledWith === plotIndex) {
                // Harvest partner too!
                partnerYield = QuantumMechanics.collapseYield(partner.plant);
                
                if (UpgradeManager.isPurchased('deepEntanglement')) {
                    for (const resource in partnerYield) {
                        partnerYield[resource] = Math.floor(partnerYield[resource] * 1.25);
                    }
                }
                
                for (const [resource, amount] of Object.entries(partnerYield)) {
                    ResourceManager.add(resource, amount);
                }
                
                // Clear partner plot but PRESERVE autoPlantType
                const partnerAutoPlantType = partner.autoPlantType;
                StateManager.set(`garden.plots.${partnerId}`, {
                    plant: null,
                    progress: 0,
                    plantedAt: null,
                    entangledWith: null,
                    autoPlantType: partnerAutoPlantType || null
                });
            }
        }
        
        // Clear plot but PRESERVE autoPlantType
        const autoPlantType = plot.autoPlantType;
        StateManager.set(`garden.plots.${plotIndex}`, {
            plant: null,
            progress: 0,
            plantedAt: null,
            entangledWith: null,
            autoPlantType: autoPlantType || null
        });
        
        // Update stats
        const harvested = StateManager.get('stats.totalPlantsHarvested') || 0;
        StateManager.set('stats.totalPlantsHarvested', harvested + (partnerYield ? 2 : 1));
        
        events.emit('harvested', { plotIndex, plant: plot.plant, yield: actualYield, partnerYield });
        return actualYield; // Return actual yield for display
    }
    
    function entangle(plotIndex1, plotIndex2) {
        const plot1 = getPlot(plotIndex1);
        const plot2 = getPlot(plotIndex2);
        
        if (!plot1.plant || !plot2.plant) return false;
        if (plot1.entangledWith !== null || plot2.entangledWith !== null) return false;
        if (plotIndex1 === plotIndex2) return false;
        
        // Consume entanglement thread
        if (ResourceManager.get('entanglement') < 1) {
            return false;
        }
        ResourceManager.spend('entanglement', 1);
        
        // Link them
        StateManager.set(`garden.plots.${plotIndex1}.entangledWith`, plotIndex2);
        StateManager.set(`garden.plots.${plotIndex2}.entangledWith`, plotIndex1);
        
        // Track stat
        const entangled = StateManager.get('stats.plantsEntangled') || 0;
        StateManager.set('stats.plantsEntangled', entangled + 2);
        
        events.emit('entangled', { plot1: plotIndex1, plot2: plotIndex2 });
        return true;
    }
    
    function isEntanglementUnlocked() {
        return UpgradeManager.isPurchased('entanglementBasics');
    }
    
    function setEntanglementMode(enabled, sourcePlot = null) {
        entanglementMode = enabled;
        entanglementSource = sourcePlot;
    }
    
    function getEntanglementMode() {
        return { active: entanglementMode, source: entanglementSource };
    }
    
    function update(deltaTime) {
        const plots = StateManager.get('garden.plots') || [];
        const growthMult = UpgradeManager.getGrowthMultiplier();
        
        plots.forEach((plot, index) => {
            if (plot.plant && plot.progress < 1) {
                const data = GameData.generators[plot.plant];
                let growthPerSecond = (1 / data.growthTime) * growthMult;
                
                // Entangled plants share growth progress
                if (plot.entangledWith !== null) {
                    const partner = plots[plot.entangledWith];
                    if (partner && partner.plant) {
                        // Average their growth rates
                        const partnerData = GameData.generators[partner.plant];
                        const partnerRate = (1 / partnerData.growthTime) * growthMult;
                        growthPerSecond = (growthPerSecond + partnerRate) / 2;
                    }
                }
                
                const newProgress = Math.min(1, plot.progress + growthPerSecond * deltaTime);
                StateManager.set(`garden.plots.${index}.progress`, newProgress);
                
                // Sync entangled partner
                if (plot.entangledWith !== null) {
                    StateManager.set(`garden.plots.${plot.entangledWith}.progress`, newProgress);
                }
                
                if (newProgress >= 1 && plot.progress < 1) {
                    events.emit('ready', { plotIndex: index, plant: plot.plant });
                }
            }
        });
        
        // Check for entanglement breaking at very low coherence
        const coherence = ResourceManager.get('coherence') || 100;
        if (coherence < 10) {
            checkEntanglementStability(plots);
        }
        
        // Auto-harvest
        if (UpgradeManager.isPurchased('autoHarvest') && StateManager.get('settings.autoHarvestEnabled')) {
            autoHarvestTimer += deltaTime;
            if (autoHarvestTimer >= 10) {
                autoHarvestTimer = 0;
                autoHarvestAll();
            }
        }
        
        // Auto-plant
        if (UpgradeManager.isPurchased('autoPlant') && StateManager.get('settings.autoPlantEnabled')) {
            autoPlantTimer += deltaTime;
            if (autoPlantTimer >= 5) {
                autoPlantTimer = 0;
                autoPlantAll();
            }
        }
    }
    
    function checkEntanglementStability(plots) {
        // At very low coherence, entanglement can break
        const coherence = ResourceManager.get('coherence') || 0;
        const breakChance = (10 - coherence) * 0.001; // Up to 1% per tick at 0% coherence
        
        plots.forEach((plot, index) => {
            if (plot.entangledWith !== null && Math.random() < breakChance) {
                const partnerId = plot.entangledWith;
                
                // Break the link
                StateManager.set(`garden.plots.${index}.entangledWith`, null);
                StateManager.set(`garden.plots.${partnerId}.entangledWith`, null);
                
                UI.addLogEntry('‚ö†Ô∏è Entanglement collapsed due to low coherence!', 'warning');
                UI.renderGarden();
            }
        });
    }
    
    function autoHarvestAll() {
        const plots = StateManager.get('garden.plots') || [];
        let harvestedCount = 0;
        
        plots.forEach((plot, index) => {
            if (plot.plant && plot.progress >= 1) {
                const result = harvest(index);
                if (result) harvestedCount++;
            }
        });
        
        if (harvestedCount > 0) {
            UI.addLogEntry(`ü§ñ Auto-harvested ${harvestedCount} plant(s)`, 'success');
            UI.renderGarden();
            UI.renderResources();
        }
    }
    
    function autoPlantAll() {
        const plots = StateManager.get('garden.plots') || [];
        const seeds = ResourceManager.get('seeds');
        if (seeds < 1) return;
        
        // Get the currently selected plot (modal open) to skip it
        const modalOpen = document.getElementById('plant-modal')?.classList.contains('active');
        const openPlotIndex = modalOpen ? UI.getSelectedPlotIndex() : -1;
        
        // Find the most efficient unlocked plant (default fallback)
        let defaultPlant = null;
        let bestEfficiency = 0;
        
        Object.entries(GameData.generators).forEach(([id, data]) => {
            if (!data.gardenPlantable) return;
            if (!GeneratorManager.isUnlocked(id)) return;
            
            const energyYield = data.harvestYield.energy || 0;
            const efficiency = energyYield / data.growthTime;
            
            if (efficiency > bestEfficiency) {
                bestEfficiency = efficiency;
                defaultPlant = id;
            }
        });
        
        if (!defaultPlant) return;
        
        let plantedCount = 0;
        for (let i = 0; i < plots.length && ResourceManager.get('seeds') >= 1; i++) {
            // Skip if plot has a plant or modal is open for this plot
            if (plots[i].plant) continue;
            if (i === openPlotIndex) continue;
            
            // Use plot preference if set, otherwise use default
            const preferredPlant = plots[i].autoPlantType;
            let plantToUse = defaultPlant;
            
            if (preferredPlant && GeneratorManager.isUnlocked(preferredPlant)) {
                plantToUse = preferredPlant;
            }
            
            if (plant(i, plantToUse)) {
                plantedCount++;
            }
        }
        
        if (plantedCount > 0) {
            UI.addLogEntry(`üå± Auto-planted ${plantedCount} plant(s)`, 'highlight');
            UI.renderGarden();
            UI.renderResources();
        }
    }
    
    function expandTo(newSize) {
        const currentSize = getSize();
        if (newSize <= currentSize) return;
        
        const plots = StateManager.get('garden.plots') || [];
        for (let i = currentSize; i < newSize; i++) {
            plots.push({ plant: null, progress: 0, plantedAt: null, entangledWith: null });
        }
        
        StateManager.set('garden.size', newSize);
        StateManager.set('garden.plots', plots);
        events.emit('expanded', newSize);
    }
    
    function getPlantsGrowing() {
        const plots = StateManager.get('garden.plots') || [];
        return plots.filter(p => p.plant && p.progress < 1).length;
    }
    
    function getPlantsReady() {
        const plots = StateManager.get('garden.plots') || [];
        return plots.filter(p => p.plant && p.progress >= 1).length;
    }
    
    return {
        getPlot,
        getSize,
        plant,
        harvest,
        entangle,
        isEntanglementUnlocked,
        setEntanglementMode,
        getEntanglementMode,
        update,
        expandTo,
        getPlantsGrowing,
        getPlantsReady,
        on: events.on
    };
})();

// ============================================
// MODULE: Quantum Mechanics
// ============================================
const QuantumMechanics = (() => {
    const events = Utils.createEventEmitter();
    let observedPlotIndex = null;
    let observationTime = 0;
    let observerFloatTimer = 0;
    let lastEventTime = 0;
    
    // Mysterious narrative messages that appear in the log
    const narrativeMessages = [
        { threshold: 100, message: "The garden remembers...", shown: false },
        { threshold: 500, message: "You feel something watching back.", shown: false },
        { threshold: 1000, message: "The flowers whisper in frequencies you almost understand.", shown: false },
        { threshold: 2500, message: "Reality feels... thin here.", shown: false },
        { threshold: 5000, message: "WÃ∑hÃ∑oÃ∑ Ã∑pÃ∑lÃ∑aÃ∑nÃ∑tÃ∑eÃ∑dÃ∑ Ã∑tÃ∑hÃ∑eÃ∑ Ã∑fÃ∑iÃ∑rÃ∑sÃ∑tÃ∑ Ã∑sÃ∑eÃ∑eÃ∑dÃ∑?Ã∑", shown: false },
        { threshold: 10000, message: "The quantum state is YOU.", shown: false },
        { threshold: 25000, message: "Every click echoes across infinite gardens.", shown: false },
        { threshold: 50000, message: "They're beautiful when they bloom in other dimensions too.", shown: false },
        { threshold: 100000, message: "You've been here before. You'll be here again.", shown: false },
    ];
    
    // Quantum events that can occur randomly
    const quantumEvents = [
        {
            id: 'tunneling',
            name: 'Quantum Tunneling',
            description: 'Energy has tunneled through the probability barrier!',
            weight: 30,
            minEnergy: 100,
            effect: () => {
                const bonus = Math.floor(ResourceManager.get('energy') * 0.1) + 10;
                ResourceManager.add('energy', bonus);
                return `+${Utils.formatNumber(bonus)} ‚ö° appeared from nowhere!`;
            }
        },
        {
            id: 'superbloom',
            name: 'Quantum Superbloom',
            description: 'All plants momentarily exist in their fully-grown state!',
            weight: 15,
            minEnergy: 500,
            effect: () => {
                const plots = StateManager.get('garden.plots') || [];
                let boosted = 0;
                plots.forEach((plot, index) => {
                    if (plot.plant && plot.progress < 1) {
                        const newProgress = Math.min(1, plot.progress + 0.5);
                        StateManager.set(`garden.plots.${index}.progress`, newProgress);
                        boosted++;
                    }
                });
                return boosted > 0 ? `${boosted} plants jumped forward in time!` : 'No plants to affect.';
            }
        },
        {
            id: 'entanglementSurge',
            name: 'Entanglement Surge',
            description: 'Quantum correlations strengthen across your garden!',
            weight: 20,
            minEnergy: 1000,
            requires: { resource: 'knowledge', amount: 25 },
            effect: () => {
                ResourceManager.add('entanglement', 3);
                return '+3 üîó Entanglement Threads gained!';
            }
        },
        {
            id: 'temporalEcho',
            name: 'Temporal Echo',
            description: 'A ripple from a future timeline grants you resources.',
            weight: 25,
            minEnergy: 750,
            effect: () => {
                const timeGain = Math.floor(ResourceManager.get('time') * 0.2) + 5;
                ResourceManager.add('time', timeGain);
                return `+${Utils.formatNumber(timeGain)} ‚è≥ echoed from the future!`;
            }
        },
        {
            id: 'observerParadox',
            name: 'Observer Paradox',
            description: 'Your observation creates what you observe...',
            weight: 10,
            minEnergy: 2000,
            effect: () => {
                ResourceManager.add('knowledge', 15);
                ResourceManager.add('seeds', 5);
                return 'The paradox resolves: +15 üìö, +5 üå±';
            }
        },
        {
            id: 'coherenceDrift',
            name: 'Coherence Drift',
            description: 'Reality stabilizes momentarily.',
            weight: 20,
            minEnergy: 3000,
            requires: { resource: 'coherence', unlocked: true },
            effect: () => {
                const current = ResourceManager.get('coherence');
                const gain = Math.min(20, 100 - current);
                ResourceManager.add('coherence', gain);
                return gain > 0 ? `+${gain} üåÄ Coherence restored!` : 'Coherence already stable.';
            }
        },
        {
            id: 'schrodingersSeed',
            name: "Schr√∂dinger's Seed",
            description: 'A seed exists in superposition until you check your inventory.',
            weight: 25,
            minEnergy: 200,
            effect: () => {
                // 50/50 chance of getting seeds or losing them
                if (Math.random() > 0.5) {
                    ResourceManager.add('seeds', 8);
                    return 'The waveform collapsed favorably: +8 üå±!';
                } else {
                    const loss = Math.min(3, ResourceManager.get('seeds'));
                    ResourceManager.spend('seeds', loss);
                    return loss > 0 ? `The waveform collapsed poorly: -${loss} üå±` : 'No seeds to lose!';
                }
            }
        },
        {
            id: 'realityGlitch',
            name: 'Reality Glitch',
            description: 'FÃ∏oÃ∑rÃµ Ã∏aÃ∑ ÃµmÃ∏oÃ∑mÃ∂eÃ∑nÃ¥tÃµ,Ã∑ Ã¥eÃµvÃ∑eÃ¥rÃ∑yÃ∏tÃµhÃ∏iÃ¥nÃ∏gÃ∑ Ã¥fÃ∂lÃ∏iÃ∑cÃ∑kÃ∂eÃ∑rÃ¥sÃ¥.Ã∑',
            weight: 5,
            minEnergy: 5000,
            effect: () => {
                // Screen shake effect
                document.getElementById('game-container').classList.add('reality-unstable');
                setTimeout(() => {
                    document.getElementById('game-container').classList.remove('reality-unstable');
                }, 2000);
                
                // Random resource boost
                const resources = ['energy', 'time', 'knowledge'];
                const chosen = resources[Math.floor(Math.random() * resources.length)];
                const amount = Math.floor(Math.random() * 100) + 50;
                ResourceManager.add(chosen, amount);
                return `Reality reconstitutes: +${amount} ${GameData.resources[chosen].icon}`;
            }
        }
    ];
    
    // Observer Effect: Track what plot the mouse is over
    function setObservedPlot(index) {
        if (observedPlotIndex !== index) {
            observedPlotIndex = index;
            observationTime = 0;
        }
    }
    
    function clearObservedPlot() {
        observedPlotIndex = null;
        observationTime = 0;
        observerFloatTimer = 0;
    }
    
    // Update quantum mechanics each tick
    function update(deltaTime) {
        // Update observation time
        if (observedPlotIndex !== null) {
            observationTime += deltaTime;
            observerFloatTimer += deltaTime;
            
            // Observer effect: Watched plants grow faster
            const plot = StateManager.get(`garden.plots.${observedPlotIndex}`);
            if (plot && plot.plant && plot.progress < 1) {
                // Bonus growth from observation (up to 50% faster, or 75% with Keen Observer)
                const baseObserverBonus = Math.min(0.5, observationTime * 0.1);
                const keenMultiplier = UpgradeManager.isPurchased('keenObserver') ? 1.5 : 1;
                const observerBonus = baseObserverBonus * keenMultiplier;
                
                const data = GameData.generators[plot.plant];
                const growthMult = UpgradeManager.getGrowthMultiplier();
                const bonusGrowth = (1 / data.growthTime) * growthMult * observerBonus * deltaTime;
                
                const newProgress = Math.min(1, plot.progress + bonusGrowth);
                StateManager.set(`garden.plots.${observedPlotIndex}.progress`, newProgress);
                
                // Show floating speed boost text every 0.8 seconds when observer effect is active
                if (observerFloatTimer >= 0.8 && observerBonus > 0.05) {
                    observerFloatTimer = 0;
                    const speedBoost = Math.round(observerBonus * 100);
                    showObserverFloat(observedPlotIndex, `+${speedBoost}%`);
                    
                    // Also boost entangled partner!
                    if (plot.entangledWith !== null) {
                        const partner = StateManager.get(`garden.plots.${plot.entangledWith}`);
                        if (partner && partner.plant && partner.progress < 1) {
                            const partnerData = GameData.generators[partner.plant];
                            const partnerBonusGrowth = (1 / partnerData.growthTime) * growthMult * observerBonus * 0.5 * deltaTime;
                            const partnerNewProgress = Math.min(1, partner.progress + partnerBonusGrowth);
                            StateManager.set(`garden.plots.${plot.entangledWith}.progress`, partnerNewProgress);
                            
                            // Show reduced boost on entangled partner
                            const partnerBoost = Math.round(observerBonus * 50);
                            showObserverFloat(plot.entangledWith, `+${partnerBoost}%`, true);
                        }
                    }
                }
            }
        }
        
        // Check for random quantum events
        checkForRandomEvent(deltaTime);
        
        // Check for narrative messages
        checkNarrativeMessages();
        
        // Coherence decay (if unlocked)
        if (ResourceManager.isUnlocked('coherence')) {
            updateCoherence(deltaTime);
        }
    }
    
    function showObserverFloat(plotIndex, text, isEntangled = false) {
        const plotEl = document.querySelector(`.garden-plot[data-index="${plotIndex}"]`);
        if (!plotEl) return;
        
        const floater = document.createElement('div');
        floater.className = 'observer-float' + (isEntangled ? ' entangled-boost' : '');
        floater.textContent = text;
        
        // Random position within the plot
        floater.style.left = (20 + Math.random() * 40) + '%';
        floater.style.top = (30 + Math.random() * 20) + '%';
        
        plotEl.appendChild(floater);
        
        // Remove after animation
        setTimeout(() => floater.remove(), 1000);
    }
    
    function checkForRandomEvent(deltaTime) {
        lastEventTime += deltaTime;
        
        // Quantum events require coherence to occur!
        const coherence = ResourceManager.get('coherence') || 0;
        if (coherence < 20) {
            // No quantum events when coherence is too low
            return;
        }
        
        // Event chance scales with coherence (higher coherence = more events)
        const coherenceBonus = coherence / 100;
        const eventChance = deltaTime * 0.02 * coherenceBonus; // ~2% per second at 100% coherence
        
        if (lastEventTime > 30 && Math.random() < eventChance) {
            triggerRandomEvent();
            lastEventTime = 0;
        }
    }
    
    function triggerRandomEvent() {
        const energy = ResourceManager.get('energy');
        
        // Filter eligible events
        const eligible = quantumEvents.filter(e => {
            if (energy < e.minEnergy) return false;
            if (e.requires) {
                if (e.requires.resource && e.requires.amount) {
                    if (ResourceManager.get(e.requires.resource) < e.requires.amount) return false;
                }
                if (e.requires.unlocked && !ResourceManager.isUnlocked(e.requires.resource)) return false;
            }
            return true;
        });
        
        if (eligible.length === 0) return;
        
        // Weighted random selection
        const totalWeight = eligible.reduce((sum, e) => sum + e.weight, 0);
        let roll = Math.random() * totalWeight;
        
        let selected = null;
        for (const event of eligible) {
            roll -= event.weight;
            if (roll <= 0) {
                selected = event;
                break;
            }
        }
        
        if (selected) {
            showQuantumEvent(selected);
        }
    }
    
    function showQuantumEvent(event) {
        const resultMessage = event.effect();
        
        // Track in stats
        const witnessed = StateManager.get('stats.quantumEventsWitnessed') || 0;
        StateManager.set('stats.quantumEventsWitnessed', witnessed + 1);
        
        // Create event popup
        const popup = document.createElement('div');
        popup.className = 'quantum-event';
        popup.innerHTML = `
            <h3>‚öõÔ∏è ${event.name}</h3>
            <p>${event.description}</p>
            <p style="color: var(--quantum-green); font-weight: bold;">${resultMessage}</p>
            <button onclick="this.parentElement.remove()">Acknowledge</button>
        `;
        document.body.appendChild(popup);
        
        // Auto-remove after 5 seconds
        setTimeout(() => {
            if (popup.parentElement) {
                popup.style.opacity = '0';
                popup.style.transform = 'translate(-50%, -50%) scale(0.8)';
                setTimeout(() => popup.remove(), 300);
            }
        }, 5000);
        
        events.emit('quantumEvent', event);
    }
    
    function checkNarrativeMessages() {
        const totalEnergy = StateManager.get('resources.energy.total') || 0;
        
        for (const msg of narrativeMessages) {
            if (!msg.shown && totalEnergy >= msg.threshold) {
                msg.shown = true;
                
                // Delay slightly for dramatic effect
                setTimeout(() => {
                    UI.addLogEntry(msg.message, 'mysterious');
                }, Math.random() * 3000 + 1000);
            }
        }
    }
    
    function updateCoherence(deltaTime) {
        // Coherence slowly decays as you play
        const generators = Object.keys(GameData.generators).reduce((sum, id) => {
            return sum + GeneratorManager.getOwned(id);
        }, 0);
        
        // More generators = faster decay (more classical the system becomes)
        let decayRate = 0.01 + (generators * 0.002);
        
        // Apply coherence stabilizer if purchased
        if (UpgradeManager.isPurchased('coherenceStabilizer')) {
            decayRate *= 0.5;
        }
        
        const current = ResourceManager.get('coherence');
        
        if (current > 0) {
            const newCoherence = Math.max(0, current - decayRate * deltaTime);
            StateManager.set('resources.coherence.amount', newCoherence);
            
            // Warn at 50% - production starting to drop
            if (current > 50 && newCoherence <= 50) {
                UI.addLogEntry('‚ö†Ô∏è Coherence at 50%: Generator production reduced to 80%', 'warning');
            }
            
            // Warn at 25% - production significantly impacted
            if (current > 25 && newCoherence <= 25) {
                UI.addLogEntry('‚ö†Ô∏è Coherence critical! Production at 70%. Click to restore!', 'warning');
            }
            
            // Warn at 20% - quantum events stop
            if (current > 20 && newCoherence <= 20) {
                UI.addLogEntry('üåÄ Quantum events suspended - coherence too low!', 'warning');
            }
            
            // Warn at 10% - entanglement unstable
            if (current > 10 && newCoherence <= 10) {
                UI.addLogEntry('‚õìÔ∏è Entanglement unstable! Links may break!', 'warning');
            }
            
            if (current > 0 && newCoherence <= 0) {
                UI.addLogEntry('üåÄ Coherence depleted! Production at minimum (60%).', 'warning');
                events.emit('coherenceDepleted');
            }
        }
    }
    
    // Calculate superposition yield variance for a plant
    function getSuperpositionYield(generatorId) {
        const data = GameData.generators[generatorId];
        const baseYield = data.harvestYield;
        const coherence = ResourceManager.get('coherence') || 0;
        
        // Higher coherence = more variance (quantum effects)
        // Lower coherence = more predictable (classical)
        const varianceFactor = coherence / 100;
        
        const possibleYields = [];
        
        // Generate 3 possible outcomes
        for (let i = 0; i < 3; i++) {
            const possibleYield = {};
            for (const [resource, amount] of Object.entries(baseYield)) {
                const variance = amount * varianceFactor * 0.5;
                const min = Math.max(1, Math.floor(amount - variance));
                const max = Math.ceil(amount + variance * 2); // Slight positive bias
                possibleYield[resource] = { min, max, expected: amount };
            }
            possibleYields.push(possibleYield);
        }
        
        return possibleYields;
    }
    
    // Collapse superposition and get actual yield
    function collapseYield(generatorId) {
        const data = GameData.generators[generatorId];
        const baseYield = data.harvestYield;
        const coherence = ResourceManager.get('coherence') || 0;
        let varianceFactor = coherence / 100;
        
        // Superposition Mastery increases variance but improves average
        const hasMastery = UpgradeManager.isPurchased('superpositionMastery');
        if (hasMastery) {
            varianceFactor += 0.25;
        }
        
        const actualYield = {};
        
        for (const [resource, amount] of Object.entries(baseYield)) {
            const variance = amount * varianceFactor * 0.5;
            const min = Math.max(1, Math.floor(amount - variance));
            let max = Math.ceil(amount + variance * 2);
            
            // Superposition Mastery also increases max yield
            if (hasMastery) {
                max = Math.ceil(max * 1.2);
            }
            
            // Random within range, weighted toward expected (slightly better with mastery)
            const roll = Math.random();
            const range = max - min;
            const power = hasMastery ? 0.7 : 0.8; // Lower power = more likely to roll high
            actualYield[resource] = Math.floor(min + range * Math.pow(roll, power));
        }
        
        return actualYield;
    }
    
    // Force a quantum event (for testing/special occasions)
    function forceEvent(eventId) {
        const event = quantumEvents.find(e => e.id === eventId);
        if (event) {
            showQuantumEvent(event);
        }
    }
    
    return {
        update,
        setObservedPlot,
        clearObservedPlot,
        getSuperpositionYield,
        collapseYield,
        forceEvent,
        on: events.on
    };
})();

// ============================================
// MODULE: Achievement Manager
// ============================================
const AchievementManager = (() => {
    const events = Utils.createEventEmitter();
    let checkTimer = 0;
    
    function isUnlocked(achievementId) {
        return StateManager.get(`achievements.${achievementId}`) === true;
    }
    
    function unlock(achievementId) {
        if (isUnlocked(achievementId)) return false;
        
        StateManager.set(`achievements.${achievementId}`, true);
        
        const data = GameData.achievements[achievementId];
        if (data) {
            events.emit('unlocked', data);
            
            // Show notification
            UI.showNotification(
                `üèÜ Achievement Unlocked!`,
                `${data.icon} ${data.name}: ${data.description}`,
                'success'
            );
            
            UI.addLogEntry(`üèÜ Achievement: ${data.name}`, 'highlight');
        }
        
        return true;
    }
    
    function checkAll() {
        Object.entries(GameData.achievements).forEach(([id, data]) => {
            if (!isUnlocked(id) && data.check()) {
                unlock(id);
            }
        });
    }
    
    function update(deltaTime) {
        // Check achievements every second
        checkTimer += deltaTime;
        if (checkTimer >= 1) {
            checkAll();
            checkTimer = 0;
        }
    }
    
    function getUnlockedCount() {
        return Object.keys(GameData.achievements).filter(id => isUnlocked(id)).length;
    }
    
    function getTotalCount() {
        return Object.keys(GameData.achievements).length;
    }
    
    function getAll() {
        return Object.entries(GameData.achievements).map(([id, data]) => ({
            ...data,
            unlocked: isUnlocked(id)
        }));
    }
    
    return {
        isUnlocked,
        unlock,
        checkAll,
        update,
        getUnlockedCount,
        getTotalCount,
        getAll,
        on: events.on
    };
})();

// ============================================
// MODULE: UI Renderer
// ============================================
const UI = (() => {
    let selectedPlotIndex = null;
    
    function initialize() {
        setupEventListeners();
        renderAll();
    }
    
    function setupEventListeners() {
        // Quantum Core click
        document.getElementById('quantum-core').addEventListener('click', handleCoreClick);
        
        // Tab navigation
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });
        
        // Header buttons
        document.getElementById('save-btn').addEventListener('click', () => {
            StateManager.save();
            showNotification('Game Saved', 'Your progress has been saved.', 'success');
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            // Show custom confirmation since confirm() is blocked in sandbox
            const resetBtn = document.getElementById('reset-btn');
            if (resetBtn.dataset.confirmPending === 'true') {
                // Second click - actually reset
                // Stop game loop
                GameLoop.stop();
                // Clear localStorage
                localStorage.removeItem('quantumGarden_save');
                // Reset all game data unlocks
                Object.values(GameData.generators).forEach(g => {
                    if (g.unlockAt) g.unlocked = false;
                });
                Object.values(GameData.upgrades).forEach(u => {
                    if (u.requires || u.unlockAt) u.unlocked = false;
                });
                Object.values(GameData.resources).forEach(r => {
                    if (r.unlockAt) r.unlocked = false;
                });
                // Reset narrative messages
                if (typeof QuantumMechanics !== 'undefined') {
                    // Narrative messages are inside the module, we'll just reinit
                }
                // Reinitialize state
                StateManager.initialize();
                // Recalculate production
                GeneratorManager.calculateProduction();
                // Re-render everything
                UI.renderAll();
                // Restart game loop
                GameLoop.start();
                // Reset button state
                resetBtn.dataset.confirmPending = 'false';
                resetBtn.textContent = 'üóëÔ∏è Reset';
                resetBtn.style.background = '';
                resetBtn.style.color = 'var(--quantum-red)';
                // Log it
                UI.addLogEntry('Game reset! Welcome back to your Quantum Garden.', 'highlight');
            } else {
                // First click - ask for confirmation
                resetBtn.dataset.confirmPending = 'true';
                resetBtn.textContent = '‚ö†Ô∏è Click again to confirm!';
                resetBtn.style.background = 'var(--quantum-red)';
                resetBtn.style.color = 'white';
                
                // Reset button state after 3 seconds
                setTimeout(() => {
                    resetBtn.dataset.confirmPending = 'false';
                    resetBtn.textContent = 'üóëÔ∏è Reset';
                    resetBtn.style.background = '';
                    resetBtn.style.color = 'var(--quantum-red)';
                }, 3000);
            }
        });
        
        // Plant modal
        document.getElementById('close-plant-modal').addEventListener('click', closePlantModal);
        document.getElementById('plant-modal').addEventListener('click', (e) => {
            if (e.target.id === 'plant-modal') closePlantModal();
        });
        
        // Event delegation for generator buy buttons (survives re-renders)
        document.getElementById('generators-list').addEventListener('click', (e) => {
            const btn = e.target.closest('.generator-buy-btn');
            if (!btn || btn.disabled) return;
            
            const id = btn.dataset.generator;
            if (id && GeneratorManager.buy(id)) {
                renderGenerators();
                renderResources();
                addLogEntry('Purchased ' + GameData.generators[id].name, 'success');
            }
        });
        
        // Event delegation for upgrade items (survives re-renders)
        document.getElementById('upgrades-list').addEventListener('click', (e) => {
            const item = e.target.closest('.upgrade-item');
            if (!item || item.classList.contains('purchased') || item.classList.contains('locked')) return;
            
            const id = item.dataset.upgrade;
            if (id && UpgradeManager.buy(id)) {
                renderUpgrades();
                renderResources();
                renderGarden();
                updateClickPowerDisplay();
                addLogEntry('Purchased upgrade: ' + GameData.upgrades[id].name, 'success');
            }
        });
        
        // Event delegation for plant modal options
        document.getElementById('plant-options').addEventListener('click', (e) => {
            const opt = e.target.closest('.plant-option');
            if (!opt || opt.classList.contains('locked')) return;
            
            const genId = opt.dataset.generator;
            const isPreference = opt.dataset.preference === 'true';
            
            if (isPreference) {
                // Setting auto-plant preference
                if (genId === '__clear__') {
                    StateManager.set(`garden.plots.${selectedPlotIndex}.autoPlantType`, null);
                    addLogEntry(`Cleared auto-plant preference for plot`, '');
                } else {
                    StateManager.set(`garden.plots.${selectedPlotIndex}.autoPlantType`, genId);
                    addLogEntry(`Set plot to auto-plant ${GameData.generators[genId].name}`, 'highlight');
                }
                closePlantModal();
                renderGarden();
            } else {
                // Actually planting
                if (genId && GardenManager.plant(selectedPlotIndex, genId)) {
                    closePlantModal();
                    renderGarden();
                    renderResources();
                    addLogEntry('Planted ' + GameData.generators[genId].name, 'highlight');
                }
            }
        });
    }
    
    // Quantum burst charge (builds up with clicks)
    let quantumBurstCharge = 0;
    const BURST_THRESHOLD = 100;
    
    function handleCoreClick(e) {
        const power = UpgradeManager.getClickPower();
        const coherence = ResourceManager.get('coherence') || 0;
        
        // Click power is boosted by coherence!
        // At 100% coherence: 150% click power
        // At 0% coherence: 100% click power (base)
        const coherenceBonus = 1 + (coherence / 100) * 0.5;
        const actualPower = Math.floor(power * coherenceBonus);
        
        ResourceManager.add('energy', actualPower);
        
        // CLICKING RESTORES COHERENCE!
        // Each click restores 0.5-2% coherence based on click power
        const coherenceRestore = Math.min(2, 0.5 + Math.log10(power + 1) * 0.3);
        const currentCoherence = ResourceManager.get('coherence') || 0;
        const newCoherence = Math.min(100, currentCoherence + coherenceRestore);
        StateManager.set('resources.coherence.amount', newCoherence);
        
        // Build quantum burst charge
        quantumBurstCharge += 1 + (coherence / 50); // Faster charge at high coherence
        
        if (quantumBurstCharge >= BURST_THRESHOLD) {
            triggerQuantumBurst();
            quantumBurstCharge = 0;
        }
        
        // Update quantum burst indicator
        updateBurstIndicator();
        
        // Update stats
        const clicks = StateManager.get('stats.totalClicks') || 0;
        StateManager.set('stats.totalClicks', clicks + 1);
        
        // Track clicks with many generators (for achievement)
        const generators = Object.keys(GameData.generators).reduce((sum, id) => 
            sum + GeneratorManager.getOwned(id), 0);
        if (generators >= 100) {
            const clicksWithManyGens = StateManager.get('stats.clicksWithManyGens') || 0;
            StateManager.set('stats.clicksWithManyGens', clicksWithManyGens + 1);
        }
        
        // Particle effect - show coherence restoration too
        if (StateManager.get('settings.particlesEnabled')) {
            createClickParticle(e.clientX, e.clientY, actualPower, coherenceBonus > 1.1);
        }
        
        // Quick render of resources only
        renderResources();
        updateCoherenceBar();
    }
    
    function triggerQuantumBurst() {
        // Quantum burst: Boost all growing plants by 20% instantly!
        const plots = StateManager.get('garden.plots') || [];
        let boosted = 0;
        
        plots.forEach((plot, index) => {
            if (plot.plant && plot.progress < 1) {
                const newProgress = Math.min(1, plot.progress + 0.2);
                StateManager.set(`garden.plots.${index}.progress`, newProgress);
                boosted++;
            }
        });
        
        // Track stat
        const bursts = StateManager.get('stats.quantumBursts') || 0;
        StateManager.set('stats.quantumBursts', bursts + 1);
        
        // Visual feedback
        document.getElementById('quantum-core').classList.add('burst');
        setTimeout(() => {
            document.getElementById('quantum-core').classList.remove('burst');
        }, 500);
        
        // Restore significant coherence
        const currentCoherence = ResourceManager.get('coherence') || 0;
        StateManager.set('resources.coherence.amount', Math.min(100, currentCoherence + 10));
        
        if (boosted > 0) {
            addLogEntry(`‚ö° Quantum Burst! ${boosted} plants boosted by 20%!`, 'highlight');
        } else {
            addLogEntry(`‚ö° Quantum Burst! +10% coherence restored!`, 'highlight');
        }
        
        showNotification('‚ö° QUANTUM BURST!');
        renderGarden();
    }
    
    function updateBurstIndicator() {
        let indicator = document.getElementById('burst-indicator');
        if (!indicator) {
            // Create burst indicator under click power
            const powerDisplay = document.getElementById('core-power-display');
            indicator = document.createElement('div');
            indicator.id = 'burst-indicator';
            indicator.innerHTML = `
                <div class="burst-bar">
                    <div class="burst-fill" id="burst-fill"></div>
                </div>
                <div class="burst-label">Quantum Burst</div>
            `;
            powerDisplay.after(indicator);
        }
        
        const fill = document.getElementById('burst-fill');
        if (fill) {
            fill.style.width = (quantumBurstCharge / BURST_THRESHOLD * 100) + '%';
        }
    }
    
    function createClickParticle(x, y, value, isCoherenceBoosted = false) {
        const particle = document.createElement('div');
        particle.className = 'click-particle' + (isCoherenceBoosted ? ' coherence-boosted' : '');
        particle.textContent = '+' + Utils.formatNumber(value);
        particle.style.left = (x + (Math.random() - 0.5) * 40) + 'px';
        particle.style.top = (y - 20) + 'px';
        document.body.appendChild(particle);
        
        setTimeout(() => particle.remove(), 1000);
    }
    
    function switchTab(tabId) {
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tab === tabId);
        });
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.toggle('active', content.id === tabId + '-tab');
        });
    }
    
    function renderAll() {
        renderResources();
        renderGarden();
        renderGenerators();
        renderUpgrades();
        renderStats();
        updateClickPowerDisplay();
    }
    
    function renderResources() {
        const container = document.getElementById('resources-section');
        let html = '';
        
        // Calculate harvest rates from garden
        const harvestRates = calculateHarvestRates();
        
        // Tooltip descriptions
        const tooltipData = {
            energy: {
                title: '‚ö° Quantum Energy',
                description: 'Primary currency. Earned by clicking, generators, and harvesting.',
            },
            seeds: {
                title: 'üå± Seeds',
                description: 'Required to plant (1 per plant). Earned back when harvesting.',
            },
            time: {
                title: '‚è≥ Time Crystals',
                description: 'Secondary currency for mid-tier upgrades.',
            },
            knowledge: {
                title: 'üìö Quantum Knowledge',
                description: 'Advanced currency for quantum upgrades.',
            },
            coherence: {
                title: 'üåÄ Coherence',
                description: 'Quantum stability. Affects generator production and click power. Click the quantum core to restore!',
            },
            entanglement: {
                title: 'üîó Entanglement Threads',
                description: 'Used to link plants. Entangled plants share growth and harvest together.',
            },
            fragments: {
                title: 'üí† Reality Fragments',
                description: 'Permanent currency surviving prestige. Coming soon!',
            }
        };
        
        Object.entries(GameData.resources).forEach(([id, data]) => {
            if (!ResourceManager.isUnlocked(id)) return;
            
            const amount = ResourceManager.get(id);
            const generatorRate = ResourceManager.getRate(id);
            const harvestRate = harvestRates[id] || 0;
            const totalRate = generatorRate + harvestRate;
            const maxAmount = data.maxAmount;
            
            // Special display for coherence (show as percentage)
            let displayAmount = Utils.formatNumber(amount, 1);
            if (id === 'coherence') {
                displayAmount = Math.floor(amount) + '%';
            }
            
            // Rate display
            let rateHtml = '';
            if (totalRate > 0) {
                rateHtml = `<div class="resource-rate positive">+${Utils.formatNumber(totalRate, 1)}/s</div>`;
            } else if (totalRate < 0) {
                rateHtml = `<div class="resource-rate negative">${Utils.formatNumber(totalRate, 1)}/s</div>`;
            }
            
            html += `
                <div class="resource-item" data-resource="${id}">
                    <div class="resource-info">
                        <span class="resource-icon">${data.icon}</span>
                        <span class="resource-name">${data.name}</span>
                    </div>
                    <div class="resource-values">
                        <div class="resource-amount ${data.color}">${displayAmount}${maxAmount ? '/' + maxAmount : ''}</div>
                        ${rateHtml}
                    </div>
                </div>
            `;
        });
        
        container.innerHTML = html;
        
        // Attach tooltips
        container.querySelectorAll('.resource-item').forEach(el => {
            const id = el.dataset.resource;
            const data = tooltipData[id];
            if (data) {
                TooltipManager.attach(el, data, () => getResourceDetail(id));
            }
        });
    }
    
    function getResourceDetail(resourceId) {
        const generatorRate = ResourceManager.getRate(resourceId);
        const harvestRates = calculateHarvestRates();
        const harvestRate = harvestRates[resourceId] || 0;
        
        let details = [];
        
        if (generatorRate > 0) {
            details.push(`Generators: +${Utils.formatNumber(generatorRate, 2)}/s`);
        }
        
        if (harvestRate > 0) {
            details.push(`Garden (avg): +${Utils.formatNumber(harvestRate, 2)}/s`);
        }
        
        // Show coherence effect on energy production
        if (resourceId === 'energy' && ResourceManager.isUnlocked('coherence')) {
            const coherence = ResourceManager.get('coherence') || 0;
            const coherenceMultiplier = 0.6 + (coherence / 100) * 0.4;
            const percent = Math.round(coherenceMultiplier * 100);
            if (percent < 100) {
                details.push(`<span style="color: var(--quantum-red)">Coherence: ${percent}% production</span>`);
            } else {
                details.push(`<span style="color: var(--quantum-green)">Coherence: ${percent}% production</span>`);
            }
        }
        
        if (resourceId === 'coherence') {
            const generators = Object.keys(GameData.generators).reduce((sum, id) => {
                return sum + GeneratorManager.getOwned(id);
            }, 0);
            const decayRate = 0.01 + (generators * 0.002);
            const stabilizer = UpgradeManager.isPurchased('coherenceStabilizer') ? 0.5 : 1;
            const finalDecay = decayRate * stabilizer;
            details.push(`Decay: -${Utils.formatNumber(finalDecay, 3)}/s`);
            details.push(`(${generators} generators)`);
            if (stabilizer < 1) {
                details.push(`Stabilizer: -50% decay`);
            }
            details.push(`<br>üí° Click quantum core to restore!`);
        }
        
        return details.length > 0 ? details.join('<br>') : null;
    }
    
    function calculateHarvestRates() {
        // Only calculate if auto-harvest is on
        if (!UpgradeManager.isPurchased('autoHarvest')) return {};
        if (!StateManager.get('settings.autoHarvestEnabled')) return {};
        
        const plots = StateManager.get('garden.plots') || [];
        const growthMult = UpgradeManager.getGrowthMultiplier();
        const rates = {};
        
        plots.forEach(plot => {
            if (!plot.plant) return;
            
            const data = GameData.generators[plot.plant];
            if (!data || !data.harvestYield) return;
            
            // Calculate harvests per second
            const growTime = data.growthTime / growthMult;
            const harvestsPerSecond = 1 / growTime;
            
            // Add expected yield per second
            for (const [resource, amount] of Object.entries(data.harvestYield)) {
                if (!rates[resource]) rates[resource] = 0;
                rates[resource] += amount * harvestsPerSecond;
            }
        });
        
        return rates;
    }
    
    function renderGarden() {
        const grid = document.getElementById('garden-grid');
        const size = GardenManager.getSize();
        const cols = Math.ceil(Math.sqrt(size));
        
        grid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
        
        let html = '';
        const plots = StateManager.get('garden.plots') || [];
        const entangleMode = GardenManager.getEntanglementMode();
        
        for (let i = 0; i < size; i++) {
            const plot = plots[i] || { plant: null, progress: 0, entangledWith: null };
            const hasPlant = plot.plant !== null;
            const isReady = hasPlant && plot.progress >= 1;
            const plantData = hasPlant ? GameData.generators[plot.plant] : null;
            const isEntangled = plot.entangledWith !== null;
            const isEntangleSource = entangleMode.active && entangleMode.source === i;
            const canEntangle = entangleMode.active && entangleMode.source !== i && hasPlant && !isEntangled;
            
            let plotClass = 'garden-plot';
            if (!hasPlant) plotClass += ' empty';
            else if (isReady) plotClass += ' ready';
            else plotClass += ' planted';
            if (isEntangled) plotClass += ' entangled';
            if (isEntangleSource) plotClass += ' entangle-source';
            if (canEntangle) plotClass += ' entangle-target';
            
            html += `
                <div class="${plotClass}" data-index="${i}">
                    ${hasPlant ? `
                        <div class="plot-plant">${plantData.icon}</div>
                        ${!isReady ? `<div class="plot-progress" style="width: ${plot.progress * 100}%"></div>` : ''}
                        ${!isReady ? `<div class="plot-timer">${Utils.formatTime(plantData.growthTime * (1 - plot.progress))}</div>` : ''}
                    ` : ''}
                    ${plot.autoPlantType && UpgradeManager.isPurchased('autoPlant') ? `
                        <div class="plot-preference" title="Auto-plants: ${GameData.generators[plot.autoPlantType]?.name || '?'}">
                            ${GameData.generators[plot.autoPlantType]?.icon || '?'}
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        grid.innerHTML = html;
        
        // Add click listeners and observer effect tracking
        grid.querySelectorAll('.garden-plot').forEach(plotEl => {
            const index = parseInt(plotEl.dataset.index);
            
            plotEl.addEventListener('click', () => handlePlotClick(index));
            
            // Observer effect - track when mouse is over a growing plant
            plotEl.addEventListener('mouseenter', () => {
                const plot = GardenManager.getPlot(index);
                if (plot && plot.plant && plot.progress < 1) {
                    QuantumMechanics.setObservedPlot(index);
                    plotEl.classList.add('observed');
                }
            });
            
            plotEl.addEventListener('mouseleave', () => {
                QuantumMechanics.clearObservedPlot();
                plotEl.classList.remove('observed');
            });
        });
        
        // Update plot info
        const used = plots.filter(p => p.plant).length;
        document.getElementById('plots-used').textContent = used;
        document.getElementById('plots-total').textContent = size;
        
        // Show/hide entangle button
        updateEntangleButton();
        
        // Draw entanglement connections
        updateEntanglementLines();
    }
    
    function updateEntanglementLines() {
        const svg = document.getElementById('entanglement-lines');
        if (!svg) return;
        
        const grid = document.getElementById('garden-grid');
        const section = document.getElementById('garden-section');
        
        // Position SVG to cover the grid
        svg.style.left = grid.offsetLeft + 'px';
        svg.style.top = grid.offsetTop + 'px';
        svg.setAttribute('width', grid.offsetWidth);
        svg.setAttribute('height', grid.offsetHeight);
        
        let svgContent = '';
        const plots = StateManager.get('garden.plots') || [];
        const drawnPairs = new Set();
        
        plots.forEach((plot, index) => {
            if (plot.entangledWith !== null && !drawnPairs.has(`${Math.min(index, plot.entangledWith)}-${Math.max(index, plot.entangledWith)}`)) {
                const plot1El = document.querySelector(`.garden-plot[data-index="${index}"]`);
                const plot2El = document.querySelector(`.garden-plot[data-index="${plot.entangledWith}"]`);
                
                if (plot1El && plot2El) {
                    // Use offsetLeft/offsetTop relative to grid (since grid is position:relative)
                    const x1 = plot1El.offsetLeft + plot1El.offsetWidth / 2;
                    const y1 = plot1El.offsetTop + plot1El.offsetHeight / 2;
                    const x2 = plot2El.offsetLeft + plot2El.offsetWidth / 2;
                    const y2 = plot2El.offsetTop + plot2El.offsetHeight / 2;
                    
                    // Draw curved line between centers
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    const dx = x2 - x1;
                    const dy = y2 - y1;
                    // Perpendicular offset for curve
                    const curveFactor = 0.15;
                    const ctrlX = midX - dy * curveFactor;
                    const ctrlY = midY + dx * curveFactor;
                    
                    svgContent += `<path class="entanglement-line" d="M ${x1} ${y1} Q ${ctrlX} ${ctrlY} ${x2} ${y2}" />`;
                    
                    // Add pulsing particles at each end
                    svgContent += `<circle class="entanglement-particle" cx="${x1}" cy="${y1}" r="4">
                        <animate attributeName="r" values="3;6;3" dur="1s" repeatCount="indefinite" />
                        <animate attributeName="opacity" values="1;0.5;1" dur="1s" repeatCount="indefinite" />
                    </circle>`;
                    svgContent += `<circle class="entanglement-particle" cx="${x2}" cy="${y2}" r="4">
                        <animate attributeName="r" values="3;6;3" dur="1s" repeatCount="indefinite" begin="0.5s" />
                        <animate attributeName="opacity" values="1;0.5;1" dur="1s" repeatCount="indefinite" begin="0.5s" />
                    </circle>`;
                    
                    drawnPairs.add(`${Math.min(index, plot.entangledWith)}-${Math.max(index, plot.entangledWith)}`);
                }
            }
        });
        
        svg.innerHTML = svgContent;
    }
    
    function updateGardenControls() {
        const container = document.getElementById('garden-controls');
        let html = '';
        
        // Auto-Harvest toggle
        if (UpgradeManager.isPurchased('autoHarvest')) {
            const enabled = StateManager.get('settings.autoHarvestEnabled');
            html += `
                <div class="auto-toggle ${enabled ? 'active' : ''}" id="toggle-autoharvest" title="Auto-harvest mature plants every 10s">
                    <span class="toggle-indicator"></span>
                    <span>ü§ñ Harvest</span>
                </div>
            `;
        }
        
        // Auto-Plant toggle
        if (UpgradeManager.isPurchased('autoPlant')) {
            const enabled = StateManager.get('settings.autoPlantEnabled');
            html += `
                <div class="auto-toggle ${enabled ? 'active' : ''}" id="toggle-autoplant" title="Auto-plant in empty plots every 5s">
                    <span class="toggle-indicator"></span>
                    <span>üå± Plant</span>
                </div>
            `;
        }
        
        // Entangle button
        if (GardenManager.isEntanglementUnlocked()) {
            const mode = GardenManager.getEntanglementMode();
            const threads = ResourceManager.get('entanglement');
            
            if (mode.active) {
                html += `<button class="header-btn" id="entangle-btn" style="background: var(--quantum-red); color: white;">‚ùå Cancel</button>`;
            } else {
                const disabled = threads < 1 ? 'disabled' : '';
                html += `<button class="header-btn" id="entangle-btn" ${disabled}>üîó Entangle (${Math.floor(threads)})</button>`;
            }
        }
        
        container.innerHTML = html;
        
        // Attach event listeners
        const autoHarvestBtn = document.getElementById('toggle-autoharvest');
        if (autoHarvestBtn) {
            autoHarvestBtn.addEventListener('click', () => {
                const current = StateManager.get('settings.autoHarvestEnabled');
                StateManager.set('settings.autoHarvestEnabled', !current);
                updateGardenControls();
                addLogEntry(`Auto-harvest ${!current ? 'enabled' : 'disabled'}`, '');
            });
        }
        
        const autoPlantBtn = document.getElementById('toggle-autoplant');
        if (autoPlantBtn) {
            autoPlantBtn.addEventListener('click', () => {
                const current = StateManager.get('settings.autoPlantEnabled');
                StateManager.set('settings.autoPlantEnabled', !current);
                updateGardenControls();
                addLogEntry(`Auto-plant ${!current ? 'enabled' : 'disabled'}`, '');
            });
        }
        
        const entangleBtn = document.getElementById('entangle-btn');
        if (entangleBtn) {
            entangleBtn.addEventListener('click', toggleEntangleMode);
        }
    }
    
    // Keep old function name for compatibility
    function updateEntangleButton() {
        updateGardenControls();
    }
    
    function toggleEntangleMode() {
        const mode = GardenManager.getEntanglementMode();
        if (mode.active) {
            GardenManager.setEntanglementMode(false, null);
            addLogEntry('Entanglement cancelled', '');
        } else {
            GardenManager.setEntanglementMode(true, null);
            addLogEntry('Select first plant to entangle...', 'highlight');
        }
        renderGarden();
    }
    
    function handlePlotClick(index) {
        const plot = GardenManager.getPlot(index);
        const entangleMode = GardenManager.getEntanglementMode();
        
        // Handle entanglement mode
        if (entangleMode.active) {
            if (entangleMode.source === null) {
                // Selecting first plant
                if (plot.plant && !plot.entangledWith) {
                    GardenManager.setEntanglementMode(true, index);
                    addLogEntry('Now select second plant to entangle with...', 'highlight');
                    renderGarden();
                }
            } else if (entangleMode.source !== index) {
                // Selecting second plant
                if (plot.plant && !plot.entangledWith) {
                    if (GardenManager.entangle(entangleMode.source, index)) {
                        addLogEntry('üîó Plants entangled! They now share fate.', 'success');
                        GardenManager.setEntanglementMode(false, null);
                        renderGarden();
                        renderResources();
                    } else {
                        addLogEntry('Cannot entangle these plants!', 'warning');
                    }
                }
            }
            return;
        }
        
        if (plot.plant && plot.progress >= 1) {
            // Harvest ready plant - get quantum yield
            const plantData = GameData.generators[plot.plant];
            const actualYield = GardenManager.harvest(index);
            
            if (actualYield) {
                // Show floating harvest numbers
                ResourceGainTracker.showHarvestFloat(index, actualYield);
                
                // Format yield for log
                const yieldText = Object.entries(actualYield)
                    .map(([r, a]) => `${GameData.resources[r].icon}${a}`)
                    .join(' ');
                    
                addLogEntry(`Harvested ${plantData.name}: ${yieldText}`, 'success');
                renderGarden();
                renderResources();
            }
        } else if (plot.plant && plot.progress < 1) {
            // Click on growing plant - if auto-plant is unlocked, allow setting preference
            if (UpgradeManager.isPurchased('autoPlant')) {
                selectedPlotIndex = index;
                openPlantModal(true); // true = setting preference
            }
        } else if (!plot.plant) {
            // Open plant selector
            selectedPlotIndex = index;
            openPlantModal(false);
        }
    }
    
    function openPlantModal(settingPreference = false) {
        const modal = document.getElementById('plant-modal');
        const optionsContainer = document.getElementById('plant-options');
        const modalTitle = document.querySelector('#plant-modal-content h3');
        
        if (settingPreference) {
            modalTitle.textContent = 'üîÑ Set Auto-Plant Type';
        } else {
            modalTitle.textContent = 'üå± Select a Plant';
        }
        
        let html = '';
        const seeds = ResourceManager.get('seeds');
        const plot = GardenManager.getPlot(selectedPlotIndex);
        const currentPreference = plot?.autoPlantType || null;
        
        // Add clear option when setting preference
        if (settingPreference) {
            html += `
                <div class="plant-option clear-option" data-generator="__clear__" data-preference="true">
                    <div class="plant-option-icon">üö´</div>
                    <div class="plant-option-info">
                        <div class="plant-option-name">Clear Preference</div>
                        <div class="plant-option-desc">Use default auto-plant behavior for this plot</div>
                    </div>
                </div>
            `;
        }
        
        Object.entries(GameData.generators).forEach(([id, data]) => {
            if (!data.gardenPlantable) return;
            if (!GeneratorManager.isUnlocked(id)) return;
            
            const canPlant = settingPreference || seeds >= 1;
            const isCurrentPref = currentPreference === id;
            
            // Format harvest yield
            const yieldText = Object.entries(data.harvestYield).map(([r, a]) => 
                `${GameData.resources[r]?.icon || '?'}${a}`
            ).join(' ');
            
            html += `
                <div class="plant-option ${!canPlant ? 'locked' : ''} ${isCurrentPref ? 'selected' : ''}" 
                     data-generator="${id}" 
                     data-preference="${settingPreference}">
                    <div class="plant-option-icon">${data.icon}</div>
                    <div class="plant-option-info">
                        <div class="plant-option-name">${data.name} ${isCurrentPref ? '‚úì' : ''}</div>
                        <div class="plant-option-desc">${data.description}</div>
                        <div class="plant-option-cost">‚è±Ô∏è ${Utils.formatTime(data.growthTime)} ‚Üí ${yieldText}</div>
                    </div>
                </div>
            `;
        });
        
        if (!html) {
            html = '<p style="color: var(--text-secondary);">No plants available yet. Buy some generators first!</p>';
        }
        
        optionsContainer.innerHTML = html;
        // Note: Click handling via event delegation set up in setupEventListeners
        
        modal.classList.add('active');
    }
    
    function closePlantModal() {
        document.getElementById('plant-modal').classList.remove('active');
        selectedPlotIndex = null;
    }
    
    function getSelectedPlotIndex() {
        return selectedPlotIndex;
    }
    
    function renderGenerators() {
        const container = document.getElementById('generators-list');
        let html = '';
        
        Object.entries(GameData.generators).forEach(([id, data]) => {
            const isUnlocked = GeneratorManager.isUnlocked(id);
            if (!isUnlocked && !data.unlockAt) return;
            
            const owned = GeneratorManager.getOwned(id);
            const cost = GeneratorManager.getCost(id);
            const canAfford = ResourceManager.canAfford(cost);
            const production = GeneratorManager.getProduction(id);
            
            let costText = Object.entries(cost).map(([r, a]) => 
                `${GameData.resources[r].icon} ${Utils.formatNumber(a)}`
            ).join(' ');
            
            let prodText = Object.entries(data.production).map(([r, a]) => 
                `+${Utils.formatNumber(a * (owned || 1), 2)} ${GameData.resources[r].icon}/s`
            ).join(', ');
            
            // Harvest yield info
            let harvestInfo = '';
            if (data.gardenPlantable && data.harvestYield) {
                const harvestText = Object.entries(data.harvestYield).map(([r, a]) => 
                    `${GameData.resources[r]?.icon || '?'}${a}`
                ).join(' ');
                harvestInfo = `<div class="generator-harvest">üå± ${Utils.formatTime(data.growthTime)} ‚Üí ${harvestText}</div>`;
            }
            
            html += `
                <div class="generator-item ${!isUnlocked ? 'locked' : ''}" data-generator-id="${id}">
                    <div class="generator-header">
                        <span class="generator-icon">${data.icon}</span>
                        <div class="generator-title">
                            <div class="generator-name">${data.name}</div>
                            <div class="generator-owned">${owned} owned</div>
                        </div>
                    </div>
                    <div class="generator-desc">${data.description}</div>
                    <div class="generator-stats">
                        <span>Produces: ${prodText}</span>
                    </div>
                    ${harvestInfo}
                    <button class="generator-buy-btn" 
                            data-generator="${id}" 
                            ${!isUnlocked || !canAfford ? 'disabled' : ''}>
                        ${isUnlocked ? `Buy (${costText})` : 'Locked'}
                    </button>
                </div>
            `;
        });
        
        container.innerHTML = html;
        // Note: No individual click listeners here - we use event delegation
    }
    
    function renderUpgrades() {
        const container = document.getElementById('upgrades-list');
        let html = '';
        
        Object.entries(GameData.upgrades).forEach(([id, data]) => {
            const isPurchased = UpgradeManager.isPurchased(id);
            const isUnlocked = UpgradeManager.isUnlocked(id);
            
            if (!isUnlocked && !isPurchased) return;
            
            const canBuy = UpgradeManager.canBuy(id);
            
            let costText = Object.entries(data.cost).map(([r, a]) => 
                `${GameData.resources[r].icon} ${Utils.formatNumber(a)}`
            ).join(' ');
            
            html += `
                <div class="upgrade-item ${isPurchased ? 'purchased' : ''} ${!isUnlocked ? 'locked' : ''}" 
                     data-upgrade="${id}">
                    <div class="upgrade-header">
                        <span class="upgrade-icon">${data.icon}</span>
                        <span class="upgrade-name">${data.name}</span>
                        <span class="upgrade-cost">${isPurchased ? '‚úì' : costText}</span>
                    </div>
                    <div class="upgrade-desc">${data.description}</div>
                </div>
            `;
        });
        
        container.innerHTML = html || '<p style="color: var(--text-secondary);">No upgrades available yet.</p>';
        // Note: No individual click listeners here - we use event delegation
    }
    
    function renderStats() {
        const container = document.getElementById('stats-content');
        const stats = StateManager.get('stats') || {};
        
        const playTime = ((Date.now() - (stats.startDate || Date.now())) / 1000);
        
        // Get achievements
        const achievements = AchievementManager.getAll();
        const unlockedAchievements = achievements.filter(a => a.unlocked);
        const lockedAchievements = achievements.filter(a => !a.unlocked && !a.secret);
        
        container.innerHTML = `
            <div class="stat-group">
                <h4>üèÜ Achievements (${unlockedAchievements.length}/${achievements.length})</h4>
                <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-bottom: 12px;">
                    ${unlockedAchievements.map(a => `
                        <div class="achievement-badge unlocked" title="${a.name}: ${a.description}">
                            ${a.icon}
                        </div>
                    `).join('')}
                    ${lockedAchievements.map(a => `
                        <div class="achievement-badge locked" title="???">
                            ‚ùì
                        </div>
                    `).join('')}
                </div>
            </div>
            <div class="stat-group">
                <h4>General</h4>
                <div class="stat-row">
                    <span class="stat-label">Total Clicks</span>
                    <span class="stat-value">${Utils.formatNumber(stats.totalClicks || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Plants Harvested</span>
                    <span class="stat-value">${Utils.formatNumber(stats.totalPlantsHarvested || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Quantum Events</span>
                    <span class="stat-value">${Utils.formatNumber(stats.quantumEventsWitnessed || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Quantum Bursts</span>
                    <span class="stat-value">${Utils.formatNumber(stats.quantumBursts || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Plants Entangled</span>
                    <span class="stat-value">${Utils.formatNumber(stats.plantsEntangled || 0)}</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Play Time</span>
                    <span class="stat-value">${Utils.formatTime(playTime)}</span>
                </div>
            </div>
            <div class="stat-group">
                <h4>Resources Earned (All Time)</h4>
                ${Object.entries(GameData.resources).map(([id, data]) => {
                    if (!ResourceManager.isUnlocked(id)) return '';
                    const total = StateManager.get(`resources.${id}.total`) || 0;
                    return `
                        <div class="stat-row">
                            <span class="stat-label">${data.icon} ${data.name}</span>
                            <span class="stat-value">${Utils.formatNumber(total)}</span>
                        </div>
                    `;
                }).join('')}
            </div>
            <div class="stat-group">
                <h4>Generators Owned</h4>
                ${Object.entries(GameData.generators).map(([id, data]) => {
                    const owned = GeneratorManager.getOwned(id);
                    if (owned === 0) return '';
                    return `
                        <div class="stat-row">
                            <span class="stat-label">${data.icon} ${data.name}</span>
                            <span class="stat-value">${owned}</span>
                        </div>
                    `;
                }).join('') || '<p style="color: var(--text-dim);">None yet</p>'}
            </div>
        `;
    }
    
    function updateClickPowerDisplay() {
        const power = UpgradeManager.getClickPower();
        const coherence = ResourceManager.get('coherence') || 0;
        const coherenceBonus = 1 + (coherence / 100) * 0.5;
        const actualPower = power * coherenceBonus;
        
        const display = document.getElementById('click-power-value');
        display.textContent = Utils.formatNumber(actualPower, 1);
        
        // Color based on coherence bonus
        if (coherenceBonus >= 1.4) {
            display.style.color = 'var(--quantum-cyan)';
        } else if (coherenceBonus >= 1.2) {
            display.style.color = 'var(--quantum-green)';
        } else if (coherenceBonus < 1.1) {
            display.style.color = 'var(--quantum-red)';
        } else {
            display.style.color = '';
        }
    }
    
    function updateGardenProgress() {
        // Update progress bars and timers in-place without re-rendering
        const plots = StateManager.get('garden.plots') || [];
        const growthMult = UpgradeManager.getGrowthMultiplier();
        
        plots.forEach((plot, index) => {
            const plotEl = document.querySelector(`.garden-plot[data-index="${index}"]`);
            if (!plotEl) return;
            
            if (plot.plant) {
                const data = GameData.generators[plot.plant];
                const progressBar = plotEl.querySelector('.plot-progress');
                const timer = plotEl.querySelector('.plot-timer');
                
                if (plot.progress >= 1) {
                    // Plant is ready - update class if needed
                    if (!plotEl.classList.contains('ready')) {
                        plotEl.classList.remove('planted');
                        plotEl.classList.add('ready');
                        if (progressBar) progressBar.remove();
                        if (timer) timer.remove();
                    }
                } else {
                    // Update progress bar and timer
                    if (progressBar) {
                        progressBar.style.width = (plot.progress * 100) + '%';
                    }
                    if (timer) {
                        const remainingTime = data.growthTime * (1 - plot.progress) / growthMult;
                        timer.textContent = Utils.formatTime(remainingTime);
                    }
                }
            }
        });
        
        // Update plot counter
        const used = plots.filter(p => p.plant).length;
        document.getElementById('plots-used').textContent = used;
    }
    
    function updateBuyButtons() {
        // Update generator buy buttons
        document.querySelectorAll('.generator-buy-btn').forEach(btn => {
            const id = btn.dataset.generator;
            if (!id) return;
            
            const isUnlocked = GeneratorManager.isUnlocked(id);
            const cost = GeneratorManager.getCost(id);
            const canAfford = ResourceManager.canAfford(cost);
            
            btn.disabled = !isUnlocked || !canAfford;
            
            if (isUnlocked) {
                let costText = Object.entries(cost).map(([r, a]) => 
                    `${GameData.resources[r].icon} ${Utils.formatNumber(a)}`
                ).join(' ');
                btn.textContent = `Buy (${costText})`;
            }
        });
        
        // Update upgrade items
        document.querySelectorAll('.upgrade-item:not(.purchased)').forEach(item => {
            const id = item.dataset.upgrade;
            if (!id) return;
            
            const canBuy = UpgradeManager.canBuy(id);
            const isUnlocked = UpgradeManager.isUnlocked(id);
            
            item.classList.toggle('locked', !isUnlocked);
            
            // Visual feedback for affordability
            if (isUnlocked && canBuy) {
                item.style.borderColor = 'var(--quantum-gold)';
            } else if (isUnlocked) {
                item.style.borderColor = 'var(--border-dim)';
            }
        });
        
        // Update coherence bar
        updateCoherenceBar();
    }
    
    function updateCoherenceBar() {
        const container = document.getElementById('coherence-bar-container');
        const fill = document.getElementById('coherence-fill');
        const value = document.getElementById('coherence-value');
        const quantumCore = document.getElementById('quantum-core');
        
        if (ResourceManager.isUnlocked('coherence')) {
            container.classList.remove('hidden');
            const coherence = ResourceManager.get('coherence');
            fill.style.width = coherence + '%';
            value.textContent = Math.floor(coherence) + '%';
            
            // Color changes based on level
            if (coherence > 50) {
                fill.style.background = 'linear-gradient(90deg, var(--quantum-green), var(--quantum-cyan))';
            } else if (coherence > 25) {
                fill.style.background = 'linear-gradient(90deg, var(--quantum-gold), var(--quantum-green))';
            } else {
                fill.style.background = 'linear-gradient(90deg, var(--quantum-red), var(--quantum-gold))';
            }
            
            // Pulse quantum core when coherence is low (encourage clicking!)
            if (coherence < 30) {
                quantumCore.classList.add('low-coherence');
            } else {
                quantumCore.classList.remove('low-coherence');
            }
        } else {
            container.classList.add('hidden');
            quantumCore.classList.remove('low-coherence');
        }
    }
    
    function addLogEntry(message, type = '') {
        const container = document.getElementById('log-container');
        const entry = document.createElement('div');
        entry.className = 'log-entry' + (type ? ' ' + type : '');
        entry.textContent = message;
        
        container.insertBefore(entry, container.firstChild);
        
        // Keep only last 20 entries
        while (container.children.length > 20) {
            container.removeChild(container.lastChild);
        }
    }
    
    function showNotification(title, message, type = '') {
        const container = document.getElementById('notification-container');
        const notification = document.createElement('div');
        notification.className = 'notification' + (type ? ' ' + type : '');
        notification.innerHTML = `
            <div class="notification-title">${title}</div>
            <div class="notification-message">${message}</div>
        `;
        
        container.appendChild(notification);
        
        setTimeout(() => {
            notification.style.opacity = '0';
            notification.style.transform = 'translateX(100px)';
            setTimeout(() => notification.remove(), 300);
        }, 3000);
    }
    
    return {
        initialize,
        renderAll,
        renderResources,
        renderGarden,
        renderGenerators,
        renderUpgrades,
        renderStats,
        updateGardenProgress,
        updateBuyButtons,
        updateClickPowerDisplay,
        updateCoherenceBar,
        addLogEntry,
        showNotification,
        getSelectedPlotIndex
    };
})();

// ============================================
// MODULE: Game Loop
// ============================================
const GameLoop = (() => {
    let lastTime = Date.now();
    let running = false;
    let saveTimer = 0;
    let uiTimer = 0;
    
    function start() {
        running = true;
        lastTime = Date.now();
        requestAnimationFrame(tick);
    }
    
    function stop() {
        running = false;
    }
    
    function tick() {
        if (!running) return;
        
        const now = Date.now();
        const deltaTime = Math.min((now - lastTime) / 1000, 1); // Cap at 1 second
        lastTime = now;
        
        // Update game state
        update(deltaTime);
        
        // UI updates (throttled)
        uiTimer += deltaTime;
        if (uiTimer >= 0.1) { // 10 FPS for UI
            UI.renderResources();
            UI.updateGardenProgress(); // Only update progress bars, not full re-render
            UI.updateBuyButtons(); // Check if buttons should enable/disable
            UI.updateClickPowerDisplay(); // Update click power with coherence bonus
            UI.updateCoherenceBar(); // Update coherence bar
            uiTimer = 0;
        }
        
        // Autosave
        const saveInterval = StateManager.get('settings.autosaveInterval') || 30;
        saveTimer += deltaTime;
        if (saveTimer >= saveInterval) {
            StateManager.save();
            saveTimer = 0;
        }
        
        requestAnimationFrame(tick);
    }
    
    function update(deltaTime) {
        // Generator production
        Object.keys(GameData.generators).forEach(id => {
            const prod = GeneratorManager.getProduction(id);
            for (const [resource, rate] of Object.entries(prod)) {
                ResourceManager.add(resource, rate * deltaTime);
            }
        });
        
        // Garden growth
        GardenManager.update(deltaTime);
        
        // Quantum mechanics (observer effect, events, coherence)
        QuantumMechanics.update(deltaTime);
        
        // Achievement checking
        AchievementManager.update(deltaTime);
        
        // Update play time
        const playTime = StateManager.get('stats.playTime') || 0;
        StateManager.set('stats.playTime', playTime + deltaTime);
        
        // Track high coherence time (for achievement)
        const coherence = ResourceManager.get('coherence') || 0;
        const generators = Object.keys(GameData.generators).reduce((sum, id) => 
            sum + GeneratorManager.getOwned(id), 0);
        if (coherence >= 90 && generators >= 50) {
            const highTime = StateManager.get('stats.highCoherenceTime') || 0;
            StateManager.set('stats.highCoherenceTime', highTime + deltaTime);
        } else {
            // Reset if conditions not met
            StateManager.set('stats.highCoherenceTime', 0);
        }
        
        // Check unlocks (throttled - every 0.5s worth of updates is fine)
        checkUnlocks();
    }
    
    function checkUnlocks() {
        // Check generator unlocks
        let changed = false;
        Object.entries(GameData.generators).forEach(([id, data]) => {
            if (!data.unlocked && GeneratorManager.isUnlocked(id)) {
                data.unlocked = true;
                UI.addLogEntry('Unlocked: ' + data.name + '!', 'highlight');
                changed = true;
            }
        });
        
        // Check upgrade unlocks
        Object.entries(GameData.upgrades).forEach(([id, data]) => {
            if (!data.unlocked && !UpgradeManager.isPurchased(id) && UpgradeManager.isUnlocked(id)) {
                data.unlocked = true;
                UI.addLogEntry('New upgrade available: ' + data.name, 'highlight');
                changed = true;
            }
        });
        
        if (changed) {
            UI.renderGenerators();
            UI.renderUpgrades();
        }
    }
    
    return { start, stop };
})();

// ============================================
// INITIALIZATION
// ============================================
(function init() {
    // Initialize tooltip system
    TooltipManager.init();
    
    // Initialize state
    const wasLoaded = StateManager.initialize();
    
    // Initialize UI
    UI.initialize();
    
    // Calculate initial production
    GeneratorManager.calculateProduction();
    
    // Start game loop
    GameLoop.start();
    
    // Log startup
    if (wasLoaded) {
        UI.addLogEntry('Welcome back to your Quantum Garden!');
    } else {
        UI.addLogEntry('Welcome to Quantum Garden! Click the quantum core to begin.');
        UI.addLogEntry('Tip: Gather 30 energy to unlock seeds and start planting!', 'highlight');
    }
    
    // Setup window events
    window.addEventListener('beforeunload', () => {
        if (StateManager.canSave() && !window.quantumGardenResetting) {
            StateManager.save();
        }
    });
    
    // Attach coherence bar tooltip
    const coherenceBar = document.getElementById('coherence-bar-container');
    if (coherenceBar) {
        TooltipManager.attach(coherenceBar, {
            title: 'üåÄ Quantum Coherence',
            description: 'Affects harvest yield variance. High coherence = unpredictable but potentially higher yields. Low coherence = predictable, consistent yields.'
        }, () => {
            const generators = Object.keys(GameData.generators).reduce((sum, id) => {
                return sum + GeneratorManager.getOwned(id);
            }, 0);
            let decayRate = 0.01 + (generators * 0.002);
            const hasStabilizer = UpgradeManager.isPurchased('coherenceStabilizer');
            if (hasStabilizer) decayRate *= 0.5;
            
            let detail = `Decay: -${Utils.formatNumber(decayRate, 3)}/s`;
            detail += `<br>From: ${generators} generators`;
            if (hasStabilizer) detail += `<br>Stabilizer: -50% decay`;
            return detail;
        });
    }
    
    // Attach quantum core tooltip
    const quantumCore = document.getElementById('quantum-core');
    if (quantumCore) {
        TooltipManager.attach(quantumCore, {
            title: '‚öõÔ∏è Quantum Core',
            description: 'Click to gather Quantum Energy!'
        }, () => {
            const power = UpgradeManager.getClickPower();
            let detail = `Click power: ${Utils.formatNumber(power)}`;
            
            // Show breakdown
            let multiplier = 1;
            let bonus = 0;
            const sources = [];
            
            if (UpgradeManager.isPurchased('efficientClicking')) {
                sources.push('Quantum Resonance: √ó2');
                multiplier *= 2;
            }
            if (UpgradeManager.isPurchased('improvedClicking')) {
                sources.push('Harmonic Amplification: √ó3');
                multiplier *= 3;
            }
            if (UpgradeManager.isPurchased('quantumClicking')) {
                sources.push('Superposition Click: +5');
                bonus += 5;
            }
            
            if (sources.length > 0) {
                detail += '<br><br>' + sources.join('<br>');
            }
            
            return detail;
        });
    }
    
    console.log('üå∏ Quantum Garden initialized');
})();
</script>
</body>
</html>
